{"classes":[{"flags":262145,"methods":[{"declaration":"CScriptInfo@+ get_ScriptInfo()","documentation":"Gets this module's script info object."},{"declaration":"string GetModuleName() const","documentation":"Gets the name of this module."}],"properties":[],"className":"CModule","documentation":"Module class.<br/>Represents this module.","namespace":""},{"flags":1,"methods":[{"declaration":"void SetMinimumAdminLevel(const AdminLevel_t minimumAdminLevel)","documentation":"Sets the minimum admin level required for commands. You cannot lower the minimum level."},{"declaration":"AdminLevel_t GetMinimumAdminLevel() const","documentation":"Gets the minimum admin level required for commands."},{"declaration":"void SetContactInfo(const string& in szContactInfo)","documentation":"Sets the author's contact info."},{"declaration":"const string& GetContactInfo() const","documentation":"Gets the author's contact info."},{"declaration":"void SetAuthor(const string& in szAuthor)","documentation":"Sets the author name."},{"declaration":"const string& GetAuthor() const","documentation":"Gets the author name."}],"properties":[],"className":"CScriptInfo","documentation":"Script info object.</br>Contains script information.","namespace":""},{"flags":262145,"methods":[{"declaration":"void RemoveHook(uint uiHookCode, ?& in pHookFunction)","documentation":"Removes a hook. Pass in the hook function or delegate to remove."},{"declaration":"void RemoveHook(uint uiHookCode)","documentation":"Removes all functions hooked into the given hook."},{"declaration":"bool RegisterHook(uint uiHookCode, ?& in pHookFunction)","documentation":"Registers a hook. Pass in a hook function or delegate."}],"properties":[],"className":"CModuleHookManager","documentation":"Module hook manager","namespace":""},{"flags":262145,"methods":[{"declaration":"const string& FindItemMapping(const string& in szItemName) const","documentation":"Gets the item mapped to the given item name, or an empty string if no mapping exists."},{"declaration":"void SetItemMappings(array<ItemMapping@>@ pItemMappings)","documentation":"Sets the item mappings to use from now on.</br>Does not affect previous mappings.</br>Pass null to disable all mappings."},{"declaration":"void SetShouldRestartOnChange(const bool bShouldRestart)","documentation":"Sets whether the map should restart if Classic Mode is changed."},{"declaration":"bool ShouldRestartOnChange() const","documentation":"Returns whether the map should restart if Classic Mode is changed or not. Defaults to true if not changed by a script. Reset on map change."},{"declaration":"void EnableMapSupport()","documentation":"Tells the game that the current map wants to use Classic Mode. Must be called in MapInit. Cannot be disabled once set.This will ask players whether they want to enable Classic Mode. Reset on map change."},{"declaration":"void Toggle()","documentation":"Toggles Classic Mode."},{"declaration":"void SetEnabled(const bool fEnabled)","documentation":"Enable or disable Classic Mode."},{"declaration":"bool IsEnabled() const","documentation":"Returns whether Classic Mode is enabled or not."},{"declaration":"void ResetState()","documentation":"Resets the Classic Mode state setting to undefined."},{"declaration":"bool IsStateDefined() const","documentation":"Returns whether the Classic Mode state setting is defined. If not defined, no voting has taken place to choose whether or not to enable Classic Mode."}],"properties":[],"className":"CClassicMode","documentation":"Classic Mode handler","namespace":""},{"flags":1,"methods":[{"declaration":"const string& get_To() const","documentation":"Gets the To item name"},{"declaration":"const string& get_From() const","documentation":"Gets the From item name"},{"declaration":"ItemMapping@ ItemMapping(const string& in szFrom, const string& in szTo)","documentation":"Constructor"}],"properties":[],"className":"ItemMapping","documentation":"Item mapping for classic mode.","namespace":""},{"flags":1,"methods":[{"declaration":"void set_ShouldHide(bool fShouldHide)","documentation":"Sets whether this text will be hidden or not"},{"declaration":"bool get_ShouldHide() const","documentation":"Gets whether this text will be hidden or not"},{"declaration":"const CCommand@ GetArguments() const","documentation":"Gets the arguments in this command."},{"declaration":"const string& GetCommand() const","documentation":"Gets the entire command string"},{"declaration":"ClientSayType GetSayType() const","documentation":"Gets the say type of this text"},{"declaration":"CBasePlayer@ GetPlayer() const","documentation":"Gets the player that is saying something"}],"properties":[],"className":"SayParameters","documentation":"ClientSay parameters","namespace":""},{"flags":262145,"methods":[{"declaration":"CBasePlayer@ GetCurrentPlayer() const","documentation":"If the current command was executed by a player, this returns that player."}],"properties":[],"className":"CConCommandSystem","documentation":"Script console command manager.","namespace":""},{"flags":5,"methods":[{"declaration":"void SetBool(const bool bValue)","documentation":"Sets the given boolean as the value."},{"declaration":"void SetInt(const int iValue)","documentation":"Sets the given integer as the value."},{"declaration":"void SetFloat(const float flValue)","documentation":"Sets the given float as the value."},{"declaration":"void SetString(const string& in szValue)","documentation":"Sets the given string as the value."},{"declaration":"bool GetBool() const","documentation":"Converts the value to a boolean."},{"declaration":"int GetInt() const","documentation":"Converts the value to an integer."},{"declaration":"float GetFloat() const","documentation":"Converts the value to a float."},{"declaration":"const string& GetString() const","documentation":"Converts the value to a string."},{"declaration":"const string& GetDefaultValue() const","documentation":"Gets the default value for this cvar."},{"declaration":"CCVar@ CCVar(const string& in szName, const string& in szValue, const string& in szHelpInfo = , const ConCommandFlags_t flags = ConCommandFlag::None, CVarCallback@ pCallback = null)","documentation":"Constructor"},{"declaration":"CCVar@ CCVar(const string& in szName, float flValue = 0, const string& in szHelpInfo = , const ConCommandFlags_t flags = ConCommandFlag::None, CVarCallback@ pCallback = null)","documentation":"Constructor"},{"declaration":"bool HasBeenAdded() const","documentation":"Whether this command was added to the list of commands.</br>Must be added to be usable from the console."},{"declaration":"const string& GetOwningModuleName() const","documentation":"Gets the name of the module that owns (created) this command."},{"declaration":"ConCommandKind::Type GetKind() const","documentation":"Gets the type of this console command."},{"declaration":"const string& GetHelpInfo() const","documentation":"Gets the help info describing this command."},{"declaration":"const string& GetFullyQualifiedName() const","documentation":"Gets the fully qualified name of this command. This is the name that the command is referred by when called."},{"declaration":"const string& GetName() const","documentation":"Gets the name of this command."}],"properties":[],"className":"CCVar","documentation":"CVar class","namespace":""},{"flags":5,"methods":[{"declaration":"CClientCommand@ CClientCommand(const string& in szName, const string& in szHelpInfo, ClientCommandCallback@ pCallback, const ConCommandFlags_t flags = ConCommandFlag::None)","documentation":"Constructor"},{"declaration":"bool HasBeenAdded() const","documentation":"Whether this command was added to the list of commands.</br>Must be added to be usable from the console."},{"declaration":"const string& GetOwningModuleName() const","documentation":"Gets the name of the module that owns (created) this command."},{"declaration":"ConCommandKind::Type GetKind() const","documentation":"Gets the type of this console command."},{"declaration":"const string& GetHelpInfo() const","documentation":"Gets the help info describing this command."},{"declaration":"const string& GetFullyQualifiedName() const","documentation":"Gets the fully qualified name of this command. This is the name that the command is referred by when called."},{"declaration":"const string& GetName() const","documentation":"Gets the name of this command."}],"properties":[],"className":"CClientCommand","documentation":"Client console command class","namespace":""},{"flags":5,"methods":[{"declaration":"CConCommand@ CConCommand(const string& in szName, const string& in szHelpInfo, ConCommandCallback@ pCallback, const ConCommandFlags_t flags = ConCommandFlag::None)","documentation":"Constructor"},{"declaration":"bool HasBeenAdded() const","documentation":"Whether this command was added to the list of commands.</br>Must be added to be usable from the console."},{"declaration":"const string& GetOwningModuleName() const","documentation":"Gets the name of the module that owns (created) this command."},{"declaration":"ConCommandKind::Type GetKind() const","documentation":"Gets the type of this console command."},{"declaration":"const string& GetHelpInfo() const","documentation":"Gets the help info describing this command."},{"declaration":"const string& GetFullyQualifiedName() const","documentation":"Gets the fully qualified name of this command. This is the name that the command is referred by when called."},{"declaration":"const string& GetName() const","documentation":"Gets the name of this command."}],"properties":[],"className":"CConCommand","documentation":"Console command class","namespace":""},{"flags":1,"methods":[{"declaration":"int FindIntArg(const string& in szArgument, const int iDefault = 0) const","documentation":"Find an int value for a given argument. Returns iDefault if no such argument exists, or no value exists for it. Otherwise, returns the value, converted to an int"},{"declaration":"string FindArg(const string& in szArgument) const","documentation":"Find a value for a given argument. If the argument does not exist or has no value, an empty string is returned. Otherwise, returns the value."},{"declaration":"string opIndex(const int iIndex) const","documentation":"Gets the argument by index."},{"declaration":"string Arg(const int iIndex) const","documentation":"Gets the argument by index."},{"declaration":"string GetArgumentsString() const","documentation":"Gets all arguments as a single string."},{"declaration":"string GetCommandString() const","documentation":"Gets the entire command as a string."},{"declaration":"int ArgC() const","documentation":"Gets the number of arguments."}],"properties":[],"className":"CCommand","documentation":"Command arguments.","namespace":""},{"flags":262145,"methods":[{"declaration":"bool PrintF(const string& in szFormat, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in)","documentation":"Prints formatted data to the file. Uses SC printf formatting style."},{"declaration":"bool PrintF(const string& in szFormat, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in)","documentation":"Prints formatted data to the file. Uses SC printf formatting style."},{"declaration":"bool PrintF(const string& in szFormat, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in)","documentation":"Prints formatted data to the file. Uses SC printf formatting style."},{"declaration":"bool PrintF(const string& in szFormat, ?& in, ?& in, ?& in, ?& in, ?& in)","documentation":"Prints formatted data to the file. Uses SC printf formatting style."},{"declaration":"bool PrintF(const string& in szFormat, ?& in, ?& in, ?& in, ?& in)","documentation":"Prints formatted data to the file. Uses SC printf formatting style."},{"declaration":"bool PrintF(const string& in szFormat, ?& in, ?& in, ?& in)","documentation":"Prints formatted data to the file. Uses SC printf formatting style."},{"declaration":"bool PrintF(const string& in szFormat, ?& in, ?& in)","documentation":"Prints formatted data to the file. Uses SC printf formatting style."},{"declaration":"bool PrintF(const string& in szFormat, ?& in)","documentation":"Prints formatted data to the file. Uses SC printf formatting style."},{"declaration":"bool PrintF(const string& in szFormat)","documentation":"Prints formatted data to the file. Uses SC printf formatting style."}],"properties":[],"className":"CLog","documentation":"This class can log data to the Angelscript log file.","namespace":""},{"flags":33,"methods":[{"declaration":"void WriteFloat(float flValue)","documentation":"Writes a float to the buffer."},{"declaration":"void WriteEntity(CBaseEntity@ pEntity)","documentation":"Writes an entity index to the buffer."},{"declaration":"void WriteEntity(int iEntity)","documentation":"Writes an entity index to the buffer."},{"declaration":"void WriteString(const string& in szString)","documentation":"Writes a string to the buffer."},{"declaration":"void WriteVector(const Vector& in vecVector)","documentation":"Writes a vector to the buffer."},{"declaration":"void WriteCoord(float flValue)","documentation":"Writes a coordinate to the buffer."},{"declaration":"void WriteAngle(float flValue)","documentation":"Writes an angle to the buffer."},{"declaration":"void WriteLong(int32 long)","documentation":"Writes a long to the buffer."},{"declaration":"void WriteShort(int16 short)","documentation":"Writes a short to the buffer."},{"declaration":"void WriteChar(const string& in szChar)","documentation":"Writes a character to the buffer."},{"declaration":"void WriteByte(int8 byte)","documentation":"Writes a byte to the buffer."},{"declaration":"void End()","documentation":"Ends the message. Must be called to send the message."},{"declaration":"NetworkMessage@ NetworkMessage(NetworkMessageDest dest, NetworkMessages::NetworkMessageType type, const Vector& in vecOrigin, edict_t@ pEdict = null)","documentation":"Constructor"},{"declaration":"NetworkMessage@ NetworkMessage(NetworkMessageDest dest, NetworkMessages::NetworkMessageType type, edict_t@ pEdict = null)","documentation":"Constructor"}],"properties":[],"className":"NetworkMessage","documentation":"Network message class. Used to send messages to clients.","namespace":""},{"flags":262145,"methods":[{"declaration":"bool SlapPlayer(CBasePlayer@ pSlappee, float flDamage, int iDamageType = 0)","documentation":"Slaps the given player. Slap direction is randomized."},{"declaration":"bool SlapPlayer(CBasePlayer@ pSlapper, CBasePlayer@ pSlappee, float flDamage, int iDamageType = 0)","documentation":"Slaps the given player. Slapping player must have admin rights. Target player cannot be an admin. Slap direction is randomized."},{"declaration":"bool SlapPlayer(CBasePlayer@ pSlappee, float flDamage, const Vector& in vecDirection, int iDamageType = 0)","documentation":"Slaps the given player."},{"declaration":"bool SlapPlayer(CBasePlayer@ pSlapper, CBasePlayer@ pSlappee, float flDamage, const Vector& in vecDirection, int iDamageType = 0)","documentation":"Slaps the given player. Slapping player must have admin rights. Target player cannot be an admin."},{"declaration":"bool BanPlayer(CBasePlayer@ pBannee, const float flCustomBanTime = -1)","documentation":"Bans the given player."},{"declaration":"bool BanPlayer(CBasePlayer@ pBanner, CBasePlayer@ pBannee, const float flCustomBanTime = -1)","documentation":"Bans the given player. Banning player must have admin rights Target player cannot be an admin."},{"declaration":"bool KickPlayer(CBasePlayer@ pKickee, const float flCustomBanTime = -1)","documentation":"Kicks the given player."},{"declaration":"bool KickPlayer(CBasePlayer@ pKicker, CBasePlayer@ pKickee, const float flCustomBanTime = -1)","documentation":"Kicks the given player. Kicking player must have admin rights. Target player cannot be an admin."},{"declaration":"bool KillPlayer(CBasePlayer@ pKillee, float flRespawntime = -1.0f)","documentation":"Kills the given player."},{"declaration":"bool KillPlayer(CBasePlayer@ pKiller, CBasePlayer@ pKillee, float flRespawntime = -1.0f)","documentation":"Kills the given player. Killing player must have admin rights. Target player cannot be an admin."},{"declaration":"uint GetReservedSlots() const","documentation":"Gets the number of reserved slots."},{"declaration":"void SetReservedSlots(uint uiReservedSlots)","documentation":"Sets the number of reserved slots."}],"properties":[],"className":"CAdminControl","documentation":"Admin control panel.","namespace":""},{"flags":7938,"methods":[{"declaration":"void SetTime(const DateTime& in time)","documentation":"Sets the time difference to the range between 0 and time."},{"declaration":"void SetDifferenceBetween(const DateTime& in end, const DateTime& in begin)","documentation":"Sets the time difference to the range between beginning and end. If begin is later than end, is negative."},{"declaration":"void MakeAbsolute()","documentation":"Makes the time difference absolute."},{"declaration":"int GetYears() const","documentation":"Gets the time difference in years."},{"declaration":"int GetDays() const","documentation":"Gets the time difference in days."},{"declaration":"int GetHours() const","documentation":"Gets the time difference in hours."},{"declaration":"int GetMinutes() const","documentation":"Gets the time difference in minutes."},{"declaration":"int GetSeconds() const","documentation":"Gets the time difference in seconds."},{"declaration":"bool IsPositive() const","documentation":"Returns whether the time difference is positive."},{"declaration":"double GetTimeDifference() const","documentation":"Gets the time difference"},{"declaration":"TimeDifference& opAssign( const DateTime& in time)","documentation":"Assignment operator"},{"declaration":"TimeDifference& opAssign(double timeDiff)","documentation":"Assignment operator"},{"declaration":"TimeDifference& opAssign(const TimeDifference& in other)","documentation":"Assignment operator"},{"declaration":"void DestructTimeDifference()","documentation":"Destructor"},{"declaration":"void TimeDifference(const DateTime& in time)","documentation":"Sets the time difference to the range between 0 and time."},{"declaration":"void TimeDifference(const DateTime& in end, const DateTime& in begin)","documentation":"Sets the time difference to the range between beginning and end. If begin is later than end, is negative."},{"declaration":"void TimeDifference(double flValue)","documentation":"Sets the time difference to the given value, in seconds"},{"declaration":"void TimeDifference(const TimeDifference& in other)","documentation":"Copy constructor"},{"declaration":"void TimeDifference()","documentation":"Default constructor"}],"properties":[],"className":"TimeDifference","documentation":"Represents the difference between 2 times.","namespace":""},{"flags":7938,"methods":[{"declaration":"DateTime opAdd(const TimeDifference& in diffTime) const","documentation":"Adds this DateTime and the given TimeDifferene together, returning a copy containing the new time."},{"declaration":"DateTime& opAddAssign(const TimeDifference& in diffTime)","documentation":"Adds the given TimeDifference to this one."},{"declaration":"TimeDifference opSub(const DateTime& in other) const","documentation":"Subtracts the given DateTime from this one, resulting in a TimeDifference object."},{"declaration":"int opCmp(const DateTime& in other) const","documentation":"Comparison operator."},{"declaration":"bool opEquals(const DateTime& in other) const","documentation":"Returns whether these two DateTimes represent the same time."},{"declaration":"void ToString(string& out szResult) const","documentation":"Returns a string representation of this datetime."},{"declaration":"int Format(string& out szResult, const string& in szFormat) const","documentation":"Formats this datetime as a string.<br/>Returns the length of the destination string, or 0 if the buffer was not large enough."},{"declaration":"void SetYear(int iYear)","documentation":"Set year."},{"declaration":"void SetMonth(int iMonth)","documentation":"Set month (0-11)."},{"declaration":"void SetDayOfMonth(int iDay)","documentation":"Set day of month (0-30)."},{"declaration":"void SetHour(int iHours)","documentation":"Set hours (0-23)."},{"declaration":"void SetMinutes(int iMinutes)","documentation":"Set minutes (0-59)."},{"declaration":"void SetSeconds(int iSeconds)","documentation":"Set seconds (0-59)."},{"declaration":"void SetMilliseconds(uint uiMilliseconds)","documentation":"Set milliseconds."},{"declaration":"int GetYear() const","documentation":"Get year."},{"declaration":"int GetMonth() const","documentation":"Get month (0-11)."},{"declaration":"int GetDayOfMonth() const","documentation":"Get day of month (0-30)."},{"declaration":"int GetHour() const","documentation":"Get hours (0-23)."},{"declaration":"int GetMinutes() const","documentation":"Get minutes (0-59)."},{"declaration":"int GetSeconds() const","documentation":"Get seconds (0-59)."},{"declaration":"uint GetMilliseconds() const","documentation":"Get milliseconds."},{"declaration":"void SetUnixTimestamp(time_t time)","documentation":"Sets time as a unix timestamp."},{"declaration":"time_t ToUnixTimestamp() const","documentation":"Get time as a unix timestamp."},{"declaration":"DateTime& opAssign(time_t time)","documentation":"Assignment operator."},{"declaration":"DateTime& opAssign(const DateTime& in ref)","documentation":"Assignment operator."},{"declaration":"void DestructDateTime()","documentation":"Destructor."},{"declaration":"void DateTime(const DateTime& in ref)","documentation":"Copy constructor."},{"declaration":"void DateTime(time_t time)","documentation":"Unix timestamp constructor."},{"declaration":"void DateTime(uint uiMilliseconds, int iSeconds, int iMinutes, int iHour, int iDayOfMonth, int iMonth, int iYear)","documentation":"Init constructor."},{"declaration":"void DateTime()","documentation":"Default constructor."}],"properties":[],"className":"DateTime","documentation":"DateTime class.<br/>Note: milliseconds default to 0 due to limited accuracy.","namespace":""},{"flags":5,"methods":[{"declaration":"void ClearUserData()","documentation":"Clears the user data set on this vote."},{"declaration":"void SetUserData(any@ pUserData)","documentation":"Sets the user data on this vote."},{"declaration":"any@ GetUserData()","documentation":"Gets the user data set on this vote."},{"declaration":"void Start()","documentation":"Starts this vote."},{"declaration":"void SetVoteEndCallback(VoteEnd@ pCallback)","documentation":"Sets the vote end callback."},{"declaration":"void SetVoteBlockedCallback(VoteBlocked@ pCallback)","documentation":"Sets the vote blocked callback."},{"declaration":"void SetNoText(const string& in szNoText)","documentation":"Sets the no button text."},{"declaration":"const string& GetNoText() const","documentation":"Gets the no button text."},{"declaration":"void SetYesText(const string& in szYesText)","documentation":"Sets the yes button text."},{"declaration":"const string& GetYesText() const","documentation":"Gets the yes button text."},{"declaration":"void SetVoteText(const string& in szVoteText)","documentation":"Sets the vote text."},{"declaration":"const string& GetVoteText() const","documentation":"Gets the vote text."},{"declaration":"const string& GetName() const","documentation":"Gets name of this vote."},{"declaration":"Vote@ Vote(const string& in szName, const string& in szVoteText, float flVoteLength, float flPercentageNeeded)","documentation":"Constructor"}],"properties":[],"className":"Vote","documentation":"Vote class. Can be used to start custom votes.","namespace":""},{"flags":262145,"methods":[],"properties":[{"namespace":"","declaration":"const TextMenuId_t INVALID_TEXT_MENU_ID","documentation":"Invalid text menu id."}],"className":"CTextMenus","documentation":"Text menu manager.","namespace":""},{"flags":5,"methods":[{"declaration":"void AddItem( const string& in szName, any@ pUserData = null)","documentation":"Adds an item to the menu."},{"declaration":"void SetTitle(const string& in szTitle)","documentation":"Sets the title."},{"declaration":"const string& GetTitle() const","documentation":"Gets the title."},{"declaration":"const CTextMenuItem@ GetItem(const size_t uiIndex) const","documentation":"Gets the item at the given index."},{"declaration":"uint GetPageCount() const","documentation":"Gets the number of pages in this menu."},{"declaration":"size_t GetItemCount() const","documentation":"Gets the number of items in this menu."},{"declaration":"void Open(const int iDisplayTime, const uint page, CBasePlayer@ pPlayer)","documentation":"Opens the menu and keeps it open for the given amount of time.<br/>Time must be a positive value. Maximum 255 seconds. Pass 0 for infinite.<br/>You must pass the player that receives this menu."},{"declaration":"void Open(const int iDisplayTime, const uint page, array<edict_t@>@ pPlayers = null)","documentation":"Opens the menu and keeps it open for the given amount of time.<br/>Time must be a positive value. Maximum 255 seconds. Pass 0 for infinite.<br/>You can optionally pass a list of players that receive this menu."},{"declaration":"void Unregister()","documentation":"Unregisters this text menu."},{"declaration":"bool Register()","documentation":"Registers this text menu."},{"declaration":"bool IsRegistered() const","documentation":"Returns whether this menu is registered or not."},{"declaration":"TextMenuId_t get_Id() const","documentation":"Gets this text menu's id. If CTextMenus::INVALID_TEXT_MENU_ID, this is an unregistered menu."},{"declaration":"CTextMenu@ CTextMenu(TextMenuPlayerSlotCallback@ inputCB)","documentation":"Constructor. You must pass a player slot callback and handle the input yourself."}],"properties":[],"className":"CTextMenu","documentation":"Text menu.","namespace":""},{"flags":262145,"methods":[],"properties":[{"namespace":"","declaration":"any@ m_pUserData","documentation":"User data. For internal use."},{"namespace":"","declaration":"const string m_szName","documentation":"Item name. Used for display."}],"className":"CTextMenuItem","documentation":"Text menu item. Do not store handles to this object.","namespace":""},{"flags":262145,"methods":[{"declaration":"uint GetAmount(const string& in szEntry) const","documentation":"Gets the amount of a given entry.<br/>Returns 0 if the entry doesn't exist."},{"declaration":"bool Limit(const string& in szItem, uint uiAmount)","documentation":"Limits the inventory content of the given item to at most uiAmount.<br/>Does nothing if there is less than uiAmount in the inventory."},{"declaration":"bool Restock(const string& in szItem, uint uiAmount)","documentation":"Restocks the inventory with up to uiAmount of the given item.<br/>Does nothing if the current amount already exceeds the given amount."},{"declaration":"bool Remove(const string& in szEntry)","documentation":"Removes an entry from the inventory."},{"declaration":"bool Add(const string& in szEntry, uint uiAmount, bool fAdd = true)","documentation":"Add or subtract from an existing value.<br/>Inserts if the value is not already in the inventory."},{"declaration":"void Set(const string& in szEntry)","documentation":"Set an entry to the inventory."},{"declaration":"void Set(const string& in szItem, uint uiAmount)","documentation":"Set an item in the inventory.<br/>Sets the amount if the item is already in the inventory."},{"declaration":"bool Exists(const string& in szEntry) const","documentation":"Returns whether the given entry is present in the inventory."},{"declaration":"bool IsAvailable() const","documentation":"Returns whether inventory modification is available."}],"properties":[],"className":"CStartInventory","documentation":"Player start inventory manager<br/>Can be used to modify the player's start inventory during a map<br/>Always check if inventory modification is available before trying to make any changes","namespace":""},{"flags":262145,"methods":[{"declaration":"array<string>@ GetPluginList() const","documentation":"Gets the list of plugins as strings."}],"properties":[],"className":"CPluginManager","documentation":"Plugin manager for handling basic plugin operations","namespace":""},{"flags":262145,"methods":[{"declaration":"void Clear(const PersistID_t ID)","documentation":"Clears all values."},{"declaration":"void Clear(const PersistID_t ID, const string& in szKey)","documentation":"Clears the given value."},{"declaration":"void Set(const PersistID_t ID, const string& in szKey, float flValue)","documentation":"Sets the given value as a string."},{"declaration":"void Set(const PersistID_t ID, const string& in szKey, uint32 uiValue)","documentation":"Sets the given value as a string."},{"declaration":"void Set(const PersistID_t ID, const string& in szKey, int32 iValue)","documentation":"Sets the given value as a string."},{"declaration":"void Set(const PersistID_t ID, const string& in szKey, bool fValue)","documentation":"Sets the given value as a boolean."},{"declaration":"void Set(const PersistID_t ID, const string& in szKey, const string& in szValue)","documentation":"Sets the given value as a string."},{"declaration":"float GetFloat(const PersistID_t ID, const string& in szKey)","documentation":"Returns the given value as a float, or 0.0 if it does not exist."},{"declaration":"uint32 GetUlong(const PersistID_t ID, const string& in szKey, int iRadix = 10)","documentation":"Returns the given value as a unsigned long, or 0 if it does not exist."},{"declaration":"int32 GetLong(const PersistID_t ID, const string& in szKey, int iRadix = 10)","documentation":"Returns the given value as a long, or 0 if it does not exist."},{"declaration":"bool GetBoolean(const PersistID_t ID, const string& in szKey)","documentation":"Returns the given value as a boolean, or false if it does not exist."},{"declaration":"const string& GetString(const PersistID_t ID, const string& in szKey)","documentation":"Returns the given value as a string, or  if it does not exist."},{"declaration":"bool Exists(const PersistID_t ID, const string& in szKey)","documentation":"Returns whether the given key exists in this instance."},{"declaration":"size_t Size(int iId) const","documentation":"Returns the number of persisted items in this instance."},{"declaration":"const string& GetName(const PersistID_t ID) const","documentation":"Returns the name of this instance."},{"declaration":"void Clear()","documentation":"Clears all persistence instances.<br/>Make sure to avoid calling handles referencing the cleared instances."},{"declaration":"void ClearInstance(const PersistID_t ID)","documentation":"Clears the specified persistence instance."},{"declaration":"void ClearInstance(const string& in szName)","documentation":"Clears the specified persistence instance."},{"declaration":"const string& GetCurrentMapName() const","documentation":"Returns the name of the current map."},{"declaration":"const string& GetPreviousMapName() const","documentation":"Returns the name of the previous map. Can be empty if the server has just started."},{"declaration":"PersistID_t RegisterInstance(const string& in szName)","documentation":"Returns a persistence instance tied to the given name. Will be created if it does not already exist."},{"declaration":"bool KeepIfPrevious(const string& in szMapName)","documentation":"Will make the persistence manager keep the previous map's persistence instancesif the previous map's name matches the given map name."},{"declaration":"bool KeepIfPrevious(const array<string>@ pArray)","documentation":"Will make the persistence manager keep the previous map's persistence instancesif the previous map's name matches any of the elements in the array."},{"declaration":"void SetKeep(bool fValue)","documentation":"Sets whether the previous map's persistence instances will be kept."},{"declaration":"bool ShouldKeep() const","documentation":"Returns whether the previous map's persistence instances will be kept."},{"declaration":"bool IsValidHandle(const PersistID_t ID) const","documentation":"Returns whether the given persistence instance handle is valid."},{"declaration":"bool Exists(const string& in szName) const","documentation":"Returns whether the given persistence instance exists."}],"properties":[{"namespace":"","declaration":"const PersistID_t INVALID_ID","documentation":"Id used by invalid persistence objects."}],"className":"CPersistence","documentation":"Persistence manager","namespace":""},{"flags":262145,"methods":[{"declaration":"bool HasForcedPlayerModels() const","documentation":"Get if player models are forced"}],"properties":[],"className":"CMap","documentation":"Map state variables","namespace":""},{"flags":262145,"methods":[{"declaration":"string GetNextMap(const string& in szMapName) const","documentation":"Gets the next map in the cycle after the given one."},{"declaration":"string GetNextMap() const","documentation":"Gets the next map in the cycle."},{"declaration":"size_t Count() const","documentation":"Returns the number of maps in the map cycle."},{"declaration":"array<string>@ GetMapCycle() const","documentation":"Gets the map cycle as an array of strings."}],"properties":[],"className":"CMapCycle","documentation":"Map cycle read only manager","namespace":""},{"flags":262145,"methods":[{"declaration":"uint GetMinorVersion() const","documentation":"Gets the minor version of the Angelscript Sven Co-op implementation"},{"declaration":"uint GetMajorVersion() const","documentation":"Gets the major version of the Angelscript Sven Co-op implementation"},{"declaration":"uint GetAngelscriptVersion() const","documentation":"Gets the current version of Angelscript"},{"declaration":"string GetAngelscriptVersionString() const","documentation":"Gets the current version of Angelscript as a string"},{"declaration":"string GetAngelscriptDescription() const","documentation":"Returns a brief description of Angelscript"}],"properties":[],"className":"CAngelscript","documentation":"Angelscript debugging functions","namespace":""},{"flags":262145,"methods":[{"declaration":"void DumpGlobals() const","documentation":"Dumps all global state objects to the console"},{"declaration":"bool EntityInTable(const string& in globalName) const","documentation":"Returns whether the global state object is in the table of objects"},{"declaration":"const GLOBALESTATE EntityGetState(const string& in globalName) const","documentation":"Gets the state of the specified global state object"},{"declaration":"const GlobalEntity@ EntityFromTable(const string& in globalName) const","documentation":"Finds a global state object by name"},{"declaration":"void EntityUpdate(const string& in globalName, const string& in mapName)","documentation":"Updates the level name of the specified global state object"},{"declaration":"void EntitySetState(const string& in globalName, GLOBALESTATE state)","documentation":"Sets the state of an existing global state object"},{"declaration":"void EntityAdd(const string& in globalName, const string& in mapName , GLOBALESTATE state)","documentation":"Adds a new global state object"},{"declaration":"void ClearStates()","documentation":"Clears all global states"}],"properties":[],"className":"CGlobalState","documentation":"Global state manager","namespace":""},{"flags":262145,"methods":[{"declaration":"string levelName() const","documentation":"Name of the level where this global state was last updated"},{"declaration":"string name() const","documentation":"Gets the name of this global state"}],"properties":[{"namespace":"","declaration":"GlobalEntity@ next","documentation":"Next global state entity in the list"},{"namespace":"","declaration":"GLOBALESTATE state","documentation":"Global state of this entity"}],"className":"GlobalEntity","documentation":"Global state entity","namespace":""},{"flags":262145,"methods":[{"declaration":"void RadiusDamage(const Vector& in vecSrc, entvars_t@ pevInflictor, entvars_t@ pevAttacker, float flDamage, float flRadius, int iClassIgnore, int bitsDamageType)","documentation":"Deals radius damage."},{"declaration":"int DamageDecal(CBaseEntity@ pEntity, int bitsDamageType)","documentation":"Creates a damage decal on the given entity."},{"declaration":"void SpawnBlood(const Vector& in vecSpot, int bloodColor, float flDamage)","documentation":"Spawns blood at the given location."},{"declaration":"void DecalGunshot(TraceResult& in trace, int iBulletType)","documentation":"Creates a gunshot decal at the trace hit point."},{"declaration":"float WeaponTimeBase()","documentation":"Gets the weapon time base."},{"declaration":"void AddMultiDamage(entvars_t@ pevInflictor, CBaseEntity@ pEntity, float flDamage, int bitsDamageType)","documentation":"Add multi damage."},{"declaration":"void ApplyMultiDamage(entvars_t@ pevInflictor, entvars_t@ pevAttacker)","documentation":"Applies multi damage."},{"declaration":"void ClearMultiDamage()","documentation":"Clears the multi damage data."}],"properties":[],"className":"CWeaponFuncs","documentation":"Weapon functions class.","namespace":""},{"flags":262145,"methods":[{"declaration":" void BotDisconnect(CBasePlayer@ pBot)","documentation":"Disconnects the bot. This will call ClientDisconnect and removes the entity. Do not use the entity after this call."},{"declaration":"CBasePlayer@ CreateBot(const string& in szName)","documentation":"Creates a bot with the given name."},{"declaration":"int GetAmmoIndex(const string& in szAmmoName)","documentation":"Gets the index of the given ammo, or -1 if it is invalid"},{"declaration":"float SharedRandomFloat(uint iRandomSeed, float iLow, float iHigh)","documentation":"Gets a random float whose value is the same on both the client and server."},{"declaration":"int SharedRandomLong(uint iRandomSeed, int iLow, int iHigh)","documentation":"Gets a random long whose value is the same on both the client and server."},{"declaration":"bool IsSpawnPointOccupied(CBaseEntity@ pSpawnEnt)","documentation":"Returns whether the given spawn point entity is occupied"},{"declaration":"bool IsSpawnPointValid(CBaseEntity@ pSpawnEnt, CBaseEntity@ pPlayer)","documentation":"Returns whether the given spawn point is valid for the given player"},{"declaration":"bool SpawnPointFilterPasses(CBaseEntity@ pSpawnEnt, CBaseEntity@ pPlayer)","documentation":"Returns whether the given player passes the given spawn point's filter"},{"declaration":"void RespawnAllPlayers(bool fMoveLivingPlayers = true, bool fRespawnDeadPlayers = false)","documentation":"Relocates all players to active spawn points. If a player is dead and fRespawnDeadPlayers is true, the player is respawned."},{"declaration":"void RespawnPlayer(CBasePlayer@ pPlayer, bool fMoveLivingPlayers = true, bool fRespawnDeadPlayers = false)","documentation":"Relocates the given player to an active spawn point. If the player is dead and fRespawnDeadPlayers is true, the player is respawned."},{"declaration":"void ApplyMapCfgToPlayer(CBasePlayer@ pPlayer, bool fReEquip = false)","documentation":"Applies the map configuration on the given player.<br/>Will stack if called multiple times, unless fReEquip is true, in which case the player is stripped of all weapons and ammo first."},{"declaration":"AdminLevel_t StringToAdminLevel(const string& in szString) const","documentation":"Converts a string containing one of AdminLevelToString's return values to an admin level.Returns ADMIN_NO if the string cannot be converted to a suitable constant"},{"declaration":"string AdminLevelToString(const AdminLevel_t adminLevel) const","documentation":"Converts the admin level to a string. If the level is an invalid value, an empty string is returned"},{"declaration":"AdminLevel_t AdminLevel(CBasePlayer@ pPlayer) const","documentation":"Returns the admin level for a given player."},{"declaration":"bool CheatsAllowed(CBasePlayer@ pPlayer, const string& in szCheatName, bool fMustBeAlive = true) const","documentation":"Returns whether cheats are enabled for the given player."},{"declaration":"bool GetNextBestWeapon(CBasePlayer@ pPlayer, CBasePlayerItem@ pCurrentWeapon)","documentation":"Makes the given player select the next best weapon available, based on the current weapon."},{"declaration":"void ScreenFadeAll(const Vector& in color, float fadeTime, float fadeHold, int alpha, int flags)","documentation":"Shows a message to all players."},{"declaration":"void ScreenFade(CBaseEntity@ pEntity, const Vector& in color, float fadeTime, float fadeHold, int alpha, int flags)","documentation":"Shows a message to a given player."},{"declaration":"void ScreenShakeAll(const Vector& in center, float amplitude, float frequency, float duration)","documentation":"Shakes the screen for all players"},{"declaration":"void ScreenShake(const Vector& in center, float amplitude, float frequency, float duration, float radius)","documentation":"Shakes the screen for players near a certain location"},{"declaration":"int GetNumPlayers() const","documentation":"Gets the number of players that are currently connected to the server."},{"declaration":"CBasePlayer@ FindPlayerByName(const string& in szName, bool bCaseSensitive = true)","documentation":"Finds a player by name"},{"declaration":"CBasePlayer@ FindPlayerByIndex(int index)","documentation":"Finds a player by index"},{"declaration":"void PrintKeyBindingStringAll(const string& in szString)","documentation":"Prints a string containing key bindings to the screen of all players."},{"declaration":"void PrintKeyBindingString(CBasePlayer@ pPlayer, const string& in szString)","documentation":"Prints a string containing key bindings to the screen of the given player."},{"declaration":"void HudMessageAll(const HUDTextParams& in textParams, const string& in szMessage)","documentation":"Shows a HUD message to all players."},{"declaration":"void HudMessage(CBasePlayer@ pTargetPlayer, const HUDTextParams& in textParams, const string& in szMessage)","documentation":"Shows a HUD message to a given player."},{"declaration":"void ShowMessageAll(const string& in szString)","documentation":"Shows a message to all players."},{"declaration":"void ShowMessage(CBasePlayer@ pTargetPlayer, const string& in szString)","documentation":"Shows a message to the given player."},{"declaration":"void CenterPrintAll(const string& in szMessage, const string& in szLine2 = \"\", const string& in szLine3 = \"\", const string& in szLine4 = \"\", const string& in szLine5 = \"\")","documentation":"Prints one or more messages centered on the HUD of all players."},{"declaration":"void ClientPrintAll(HUD iMsgDest, const string& in szMessage, const string& in szLine2 = \"\", const string& in szLine3 = \"\", const string& in szLine4 = \"\", const string& in szLine5 = \"\")","documentation":"Prints one or more messages on the HUD of all players.<br/>See HUD enum."},{"declaration":"void ClientPrint(CBasePlayer@ pTargetPlayer, HUD iMsgDest, const string& in szMessage, const string& in szLine2 = \"\", const string& in szLine3 = \"\", const string& in szLine4 = \"\", const string& in szLine5 = \"\")","documentation":"Prints one or more messages on the HUD of the given player.<br/>See HUD enum."},{"declaration":"void SayTextAll(CBasePlayer@ pOriginatingPlayer, const string& in szText)","documentation":"Says text to all players"},{"declaration":"void SayText(CBasePlayer@ pTargetPlayer, const string& in szText)","documentation":"Says text to a specific player"}],"properties":[],"className":"CPlayerFuncs","documentation":"Global player functions","namespace":""},{"flags":2,"methods":[{"declaration":"HUDTextParams& opAssign(const HUDTextParams& in other)","documentation":"Assignment operator"},{"declaration":"void DestructHUDTextParams()","documentation":"Constructor"},{"declaration":"void HUDTextParams(const HUDTextParams& in other)","documentation":"Copy constructor"},{"declaration":"void HUDTextParams()","documentation":"Constructor"}],"properties":[{"namespace":"","declaration":"int channel","documentation":"Channel. 1-4."},{"namespace":"","declaration":"float fxTime","documentation":"Scan time (scan effect only)"},{"namespace":"","declaration":"float holdTime","documentation":"Hold time"},{"namespace":"","declaration":"float fadeoutTime","documentation":"Fade out time"},{"namespace":"","declaration":"float fadeinTime","documentation":"Fade in time"},{"namespace":"","declaration":"uint8 a2","documentation":"Alpha 2"},{"namespace":"","declaration":"uint8 b2","documentation":"Blue 2"},{"namespace":"","declaration":"uint8 g2","documentation":"Green 2"},{"namespace":"","declaration":"uint8 r2","documentation":"Red 2"},{"namespace":"","declaration":"uint8 a1","documentation":"Alpha 1"},{"namespace":"","declaration":"uint8 b1","documentation":"Blue 1"},{"namespace":"","declaration":"uint8 g1","documentation":"Green 1"},{"namespace":"","declaration":"uint8 r1","documentation":"Red 1"},{"namespace":"","declaration":"int effect","documentation":"Effects.<br/>0 : Fade In/Out<br/>1 : Credits<br/>2 : Scan Out"},{"namespace":"","declaration":"float y","documentation":"Y (0 - 1.0 = top to bottom) (-1 centers)"},{"namespace":"","declaration":"float x","documentation":"X (0 - 1.0 = left to right) (-1 centers)"}],"className":"HUDTextParams","documentation":"Parameters for text output to the HUD.","namespace":""},{"flags":262145,"methods":[{"declaration":"void PrecacheMaterialSounds(const Materials material)","documentation":"Precaches the sounds used by a particular material"},{"declaration":"CBaseEntity@ RandomTargetname(const string& in szTargetname)","documentation":"Returns a randomly selected entity that has the given target name."},{"declaration":"ScriptClassInterface@ CastToScriptClass(CBaseEntity@ pEntity)","documentation":"Casts an CBaseEntity@ representing a custom entity to the ScriptClassBaseClass type"},{"declaration":"void EjectBrass(const Vector& in vecOrigin, const Vector& in vecVelocity, float flRotation, int iModel, TE_BOUNCE soundtype)","documentation":"tosses a brass shell from passed origin at passed velocity."},{"declaration":"edict_t@ IndexEnt(int iEdictNum)","documentation":"Gets the edict for the given index."},{"declaration":"int EntIndex(edict_t@ pEdict)","documentation":"Gets the index for the given edict."},{"declaration":"bool IsValidEntity(edict_t@ pEntity)","documentation":"Returns whether this is a valid entity."},{"declaration":"void Remove(CBaseEntity@ pEntity)","documentation":"Removes the given entity before the next frame starts."},{"declaration":"bool IsMasterTriggered(const string& in szMaster, CBaseEntity@ pActivator)","documentation":"Returns whether the master with the given name would be triggered if activated by the given entity."},{"declaration":"void FireTargets(const string& in szTargetName, CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f, float flDelay = 0.0f)","documentation":"Triggers targets. If flDelay is nonzero, causes a temporary entity to be spawned to trigger the target at the given time.<br/>The temporary entity becomes the caller, not the entity passed in."},{"declaration":"CBaseEntity@ Instance(int iEdictNum)","documentation":"Gets the entity instance based on an edict number"},{"declaration":"CBaseEntity@ Instance(entvars_t@ vars)","documentation":"Gets the entity instance of an entvars instance"},{"declaration":"CBaseEntity@ Instance(edict_t@ edict)","documentation":"Gets the entity instance of an edict instance"},{"declaration":"void DispatchObjectCollisionBox(edict_t@ entity)","documentation":"Dispatches the initialization of the collision box of an entity"},{"declaration":"bool EntvarsKeyvalue(edict_t@ entity, const string& in szKeyName, const string& in szValue)","documentation":"Handles the initialization of keyvalues located in the entity's entvars_t object."},{"declaration":"bool DispatchKeyValue(edict_t@ entity, const string& in szKeyName, const string& in szValue)","documentation":"Dispatches the passing of a key value pair to an entity"},{"declaration":"int DispatchSpawn(edict_t@ entity)","documentation":"Dispatches the spawning of an entity"},{"declaration":"int BrushEntsInBox(array<CBaseEntity@>@ pArray, const Vector& in mins, const Vector& in maxs )","documentation":"Finds brush entities in a box"},{"declaration":"int TargetsInBox(array<CBaseEntity@>@ pArray, const Vector& in mins, const Vector& in maxs)","documentation":"Finds targets in a box"},{"declaration":"int EntitiesInBox(array<CBaseEntity@>@ pArray, const Vector& in mins, const Vector& in maxs, int flagMask)","documentation":"Finds entities in a box"},{"declaration":"int MonstersInSphere(array<CBaseEntity@>@ pArray, const Vector& in vecCenter, float flRadius)","documentation":"Finds monsters in a sphere"},{"declaration":"CBaseEntity@ FindEntityGeneric(const string& in szName, const Vector& in vecSrc, float flRadius)","documentation":"Finds an entity by target name in a sphere"},{"declaration":"CBaseEntity@ FindEntityByTargetname(CBaseEntity@ startEntity, const string& in name)","documentation":"Finds an entity by target name"},{"declaration":"CBaseEntity@ FindEntityByClassname(CBaseEntity@ startEntity, const string& in name)","documentation":"Finds an entity by class name"},{"declaration":"CBaseEntity@ FindEntityByString(CBaseEntity@ pStartEntity,const string& in szKeyword, const string& in szValue)","documentation":"Finds an entity based on a key value pair"},{"declaration":"CBaseEntity@ FindEntityInSphere(CBaseEntity@ pStartEntity, const Vector& in vecCenter, float flRadius,const string& in szValue = \"\", const string& in szKeyword = \"targetname\")","documentation":"Finds an entity in a sphere"},{"declaration":"void SetSize(entvars_t@ pev, const Vector& in vecMin, const Vector& in vecMax)","documentation":"Set the size of an entity"},{"declaration":"void SetModel(CBaseEntity@ entity, const string& in szFileName)","documentation":"Set the model of an entity"},{"declaration":"void SetOrigin(CBaseEntity@ entity, const Vector& in vecOrigin)","documentation":"Set the origin of an entity"},{"declaration":"void SpawnStickyGibs(entvars_t@ pevVictim, const Vector& in vecOrigin, int cGibs)","documentation":"Spawns sticky gibs for the target victim.<br/>cGibs specifies how many gibs there are."},{"declaration":"void SpawnRandomGibs(entvars_t@ pevVictim, int cGibs, int iHuman)","documentation":"Spawns random gibs for the target victim.<br/>iHuman specifies whether the gibs are human or alien."},{"declaration":"void SpawnHeadGib(entvars_t@ pevVictim)","documentation":"Spawns a head gib for the target victim."},{"declaration":"void UseSatchelCharges(entvars_t@ pevOwner, SATCHELCODE code)","documentation":"Triggers all satchel charges owned by pevOwner to either be released from ownership, or detonated."},{"declaration":"CGrenade@ ShootBananaCluster(entvars_t@ pevOwner, const Vector& in vecStart, const Vector& in vecVelocity)","documentation":"Spawn a banana bomb."},{"declaration":"CGrenade@ ShootMortar(entvars_t@ pevOwner, const Vector& in vecStart, const Vector& in vecVelocity)","documentation":"Spawns a mortar grenade."},{"declaration":"CGrenade@ ShootContact(entvars_t@ pevOwner, const Vector& in vecStart, const Vector& in vecVelocity)","documentation":"Spawns a contact grenade."},{"declaration":"CGrenade@ ShootTimed(entvars_t@ pevOwner, const Vector& in vecStart, const Vector& in vecVelocity, float flTime)","documentation":"Spawns a timed grenade."},{"declaration":"CGib@ CreateGib( const Vector& in vecOrigin, const Vector& in vecAngles)","documentation":"Creates a server side gib."},{"declaration":"CBaseEntity@ CreateRPGRocket(const Vector& in vecOrigin, const Vector& in vecAngles, const Vector& in vecVelocity, edict_t@ pOwner)","documentation":"Creates an rpg rocket with custom velocity."},{"declaration":"CBaseEntity@ CreateRPGRocket(const Vector& in vecOrigin, const Vector& in vecAngles, edict_t@ pOwner)","documentation":"Creates an rpg rocket."},{"declaration":"CBaseEntity@ CreateDisplacerPortal(const Vector& in vecOrigin, const Vector& in vecVelocity, edict_t@ pOwner, float flDamage, float flRadius)","documentation":"Creates a displacer portal."},{"declaration":"void CreateExplosion(const Vector& in vecCenter, const Vector& in vecAngles, edict_t@ pOwner, int iMagnitude, bool fDoDamage)","documentation":"Creates an explosion.<br/>If fDoDamage is true, also deals damage to entities within its effect radius, which is determined by the magnitude."},{"declaration":"CBeam@ CreateBeam(const string& in szSpriteName, int width)","documentation":"Creates a beam entity with the given sprite and width set."},{"declaration":"CSprite@ CreateSprite(const string& in szSpriteName, const Vector& in vecOrigin, bool fAnimated, float flFrameRate = 10.0f)","documentation":"Creates a sprite. flFrameRate must be set to a valid value to animate the sprite."},{"declaration":"void CreateDecal(const string& in szDecalName, const Vector& in vecOrigin, const string& in szTargetName = \"\")","documentation":"Creates a decal with the specified name.<br/>If given a name, has to be triggered to be placed, otherwise, is placed immediately."},{"declaration":"CBaseEntity@ Create(const string& in szClassname, const Vector& in vecOrigin, const Vector& in vecAngles, bool fCreateAndDontSpawn, edict_t@ entOwner = null)","documentation":"Creates an entity by class name."},{"declaration":"CBaseEntity@ CreateEntity(const string& in szClassName, dictionary@ pDictionary = null, bool fSpawn = true)","documentation":"Create an entity by class name. Pass keyvalues in using the dictionary, if any. Keyvalues must be strings.<br/>The class name can be either one of the entities included with the game or a custom entity."}],"properties":[],"className":"CEntityFuncs","documentation":"Global entity functions","namespace":""},{"flags":262145,"methods":[],"properties":[{"namespace":"","declaration":"int maxEntities","documentation":"Maximum entities"},{"namespace":"","declaration":"int maxClients","documentation":"Maximum connected clients"},{"namespace":"","declaration":"int cdAudioTrack","documentation":"CD audio track"},{"namespace":"","declaration":"int msg_entity","documentation":"Message entity"},{"namespace":"","declaration":"int trace_flags","documentation":"Trace flags"},{"namespace":"","declaration":"int trace_hitgroup","documentation":"Trace hit group"},{"namespace":"","declaration":"float trace_inwater","documentation":"Trace is in water flag"},{"namespace":"","declaration":"float trace_inopen","documentation":"Trace is in open flag"},{"namespace":"","declaration":"edict_t@ trace_ent","documentation":"Trace entity"},{"namespace":"","declaration":"float trace_plane_dist","documentation":"Trace plane distance"},{"namespace":"","declaration":"Vector trace_plane_normal","documentation":"Trace plane normal"},{"namespace":"","declaration":"Vector trace_endpos","documentation":"Trace end position"},{"namespace":"","declaration":"float trace_fraction","documentation":"Trace fraction"},{"namespace":"","declaration":"float trace_startsolid","documentation":"Trace start is solid flag"},{"namespace":"","declaration":"float trace_allsolid","documentation":"Trace all is solid flag"},{"namespace":"","declaration":"Vector v_right","documentation":"Right vector"},{"namespace":"","declaration":"Vector v_up","documentation":"Up vector"},{"namespace":"","declaration":"Vector v_forward","documentation":"Forward vector"},{"namespace":"","declaration":"float found_secrets","documentation":"Found secrets"},{"namespace":"","declaration":"float serverflags","documentation":"Server flags"},{"namespace":"","declaration":"float teamplay","documentation":"Flag telling whether this is teamplay"},{"namespace":"","declaration":"float coop","documentation":"Flag telling whether this is coop"},{"namespace":"","declaration":"float deathmatch","documentation":"Flag telling whether this is deathmatch"},{"namespace":"","declaration":"string_t startspot","documentation":"Start location in the map"},{"namespace":"","declaration":"string_t mapname","documentation":"Name of the current map"},{"namespace":"","declaration":"float frametime","documentation":"Time between frames"},{"namespace":"","declaration":"float time","documentation":"Current time"}],"className":"CEngine","documentation":"Engine global variables","namespace":""},{"flags":262145,"methods":[{"declaration":"float PlayHitSound( TraceResult& in tr, const Vector& in vecSrc, const Vector& in vecEnd, int iBulletType )","documentation":"Plays a hit sound based on the trace result's hit target. Returns the volume at which the hit is being played."},{"declaration":"void EmitAmbientSound(edict_t@ entity, const Vector& in vecOrigin, const string& in szSample,float flVolume, float flAttenuation, int fFlags, int iPitch)","documentation":"Plays a sentence group sequentially"},{"declaration":"int PlaySentenceGroupSequential(edict_t@ entity, const string& in szGroupName,float volume, float attenuation, int flags, int pitch, int ipick, const bool bReset)","documentation":"Plays a sentence group sequentially"},{"declaration":"int PlaySentenceGroup(edict_t@ entity, int iGroupIndex, float volume, float attenuation, int flags, int pitch)","documentation":"Plays a sentence group"},{"declaration":"int PlaySentenceGroup(edict_t@ entity, const string& in szGroupName, float volume, float attenuation, int flags, int pitch)","documentation":"Plays a sentence group"},{"declaration":"int LookupSentenceGroupIndex(const string& in szGroup)","documentation":"Looks up the sentence group index of the given sentence"},{"declaration":"int LookupSentenceIndex(const string& in sentenceName)","documentation":"Looks up the sentence index of the given sentence"},{"declaration":"void EmitGroupNameSuit(edict_t@ entity, const string& in szSample)","documentation":"Play a sentence, randomly selected from the passed in groupname."},{"declaration":"void EmitGroupIdSuit(edict_t@ entity, int isentencereg)","documentation":"Play a sentence, randomly selected from the passed in group id, over the HEV suit speaker."},{"declaration":"void EmitSoundSuit(edict_t@ entity, const string& in szSample)","documentation":"Play a specific sentence over the HEV suit speaker - just pass player entity, and !sentencename."},{"declaration":"void EmitSound(edict_t@ entity, SOUND_CHANNEL channel, const string& in szSample, float flVolume, float flAttenuation)","documentation":"Plays the given sound with the given parameters. Sound replacement will affect this."},{"declaration":"void EmitSoundDyn(edict_t@ entity, SOUND_CHANNEL channel, const string& in szSample,float flVolume, float flAttenuation, int iFlags = 0, int iPitch = PITCH_NORM, int target_ent_unreliable = 0)","documentation":"Plays the given sound with the given parameters. Sound replacement will affect this."},{"declaration":"void StopSound(edict_t@ entity, SOUND_CHANNEL channel, const string& in szSample, const bool fUseSoundReplacement = true)","documentation":"Stops the given sound on the given entity on the given channel. If the sound was started using PlaySound, set fUseSoundReplacement to false."},{"declaration":"void PlaySound(edict_t@ entity, SOUND_CHANNEL channel, const string& in sample,float volume, float attenuation, int flags = 0, int pitch = PITCH_NORM,int target_ent_unreliable = 0, bool setOrigin = false, const Vector& in vecOrigin = g_vecZero)","documentation":"Plays the given sound with the given parameters. Sound replacement is not used here."},{"declaration":"string FindSoundReplacementSample(CBaseEntity@ pEntity, const string& in szSample) const","documentation":"Finds the sound replacement sample for the given entity and sample.If the sample is replaced, it will return the sample used instead. Otherwise, szSample is returned."},{"declaration":"void PrecacheSound(const string& in szFilename)","documentation":"Precaches the given sound.<br/>Must be called in MapInit"}],"properties":[],"className":"CSoundEngine","documentation":"Sound engine.<br/>Can either play sounds given to it directly, or use sound replacement to look up a replacement sample.","namespace":""},{"flags":262145,"methods":[{"declaration":"uint32 GetGameVersion() const","documentation":"Returns the game version as a number, e.g. 500:<br/>major version, minor version (3.0 becomes 300, 4.0b1 becomes 401, 4.06 becomes 406, 4.5 becomes 450, etc...)"},{"declaration":"string GetGameVersionString() const","documentation":"Returns the game version as a string, e.g. \"5.0\"."},{"declaration":"string GetGameName() const","documentation":"Returns the game name."},{"declaration":"void PrecacheGeneric(const string& in szFileName)","documentation":"Precaches a file for download to clients."},{"declaration":"void PrecacheMonster(const string& in szClassName, bool fAlly)","documentation":"Precaches a monster entity.<br/>This effectively instances a monster entity with the given class name, calls precache on it, and removes the entity."},{"declaration":"void PrecacheOther(const string& in szClassName)","documentation":"Precaches an entity.<br/>This effectively instances an entity with the given class name, calls precache on it, and removes the entity."},{"declaration":"int PrecacheModel(CBaseEntity@ pEntity, const string& in szFileName)","documentation":"Precaches a model.<br/>Shuts down the game if not found.\nCan only be called from entity Precache methods."},{"declaration":"int PrecacheModel(const string& in szFileName)","documentation":"Precaches a model.<br/>Shuts down the game if not found.\nCan only be called from MapInit."},{"declaration":"bool AlertMessage(ALERT_TYPE aType, const string& in szFormat, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in)","documentation":"Outputs a message to the console. Uses SC printf formatting style."},{"declaration":"bool AlertMessage(ALERT_TYPE aType, const string& in szFormat, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in)","documentation":"Outputs a message to the console. Uses SC printf formatting style."},{"declaration":"bool AlertMessage(ALERT_TYPE aType, const string& in szFormat, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in)","documentation":"Outputs a message to the console. Uses SC printf formatting style."},{"declaration":"bool AlertMessage(ALERT_TYPE aType, const string& in szFormat, ?& in, ?& in, ?& in, ?& in, ?& in)","documentation":"Outputs a message to the console. Uses SC printf formatting style."},{"declaration":"bool AlertMessage(ALERT_TYPE aType, const string& in szFormat, ?& in, ?& in, ?& in, ?& in)","documentation":"Outputs a message to the console. Uses SC printf formatting style."},{"declaration":"bool AlertMessage(ALERT_TYPE aType, const string& in szFormat, ?& in, ?& in, ?& in)","documentation":"Outputs a message to the console. Uses SC printf formatting style."},{"declaration":"bool AlertMessage(ALERT_TYPE aType, const string& in szFormat, ?& in, ?& in)","documentation":"Outputs a message to the console. Uses SC printf formatting style."},{"declaration":"bool AlertMessage(ALERT_TYPE aType, const string& in szFormat, ?& in)","documentation":"Outputs a message to the console. Uses SC printf formatting style."},{"declaration":"bool AlertMessage(ALERT_TYPE aType, const string& in szFormat)","documentation":"Outputs a message to the console. Uses SC printf formatting style."}],"properties":[],"className":"CGame","documentation":"Game functions","namespace":""},{"flags":262145,"methods":[{"declaration":"void FindHullIntersection(const Vector& in vecSrc, TraceResult& in inTr, TraceResult& out outTr,const Vector& in vecMins, const Vector& in vecMaxs, edict_t@ pEntity, float flDistance = 1e6f)","documentation":"Finds the hull intersection from a traceline in a given set of bounds. The bounds are relative to the input traceline's endpoint.</br>The given entity is the entity performing the traceline."},{"declaration":"int CountPlayersInBrushVolume(const bool fIgnoreDeadPlayers, CBaseEntity@ pBrushVolume,int& out iOutPlayersInsideVolume, int& out iOutPlayersOutsideVolume, PlayerInVolumeListener@ pListener)","documentation":"Counts the number of players inside and outside a brush volume."},{"declaration":"void GetCircularGaussianSpread(float& out x, float& out y) const","documentation":"Gets circular gaussian spread."},{"declaration":"bool VoteActive() const","documentation":"Returns whether a vote is active. This only covers the votes started using the in-game vote menu, trigger_vote and the Vote class."},{"declaration":"bool IsPlayerInVolume(CBasePlayer@ pPlayer, CBaseEntity@ pEntityVolume)","documentation":"Returns whether the given player is in the given volume."},{"declaration":"TraceResult GetGlobalTrace()","documentation":"Gets the global trace data stored in g_Engine as a TraceResult object."},{"declaration":"CBaseEntity@ FindEntityForward(CBaseEntity@ pLooker)","documentation":"Convience function that finds the entity that the given entity is currently looking at. Uses a maximum distance of 12048 units."},{"declaration":"CBaseEntity@ FindEntityForward(CBaseEntity@ pLooker, float flMaxDistance)","documentation":"Convience function that finds the entity that the given entity is currently looking at."},{"declaration":"string TraceTexture(edict_t@ pEntity, const Vector& in vecStart, const Vector& in vecEnd)","documentation":"Trace texture"},{"declaration":"void TraceModel(const Vector& in vecStart, const Vector& in vecEnd, int iHullNumber, edict_t@ pEntityToIgnore, TraceResult& out ptr)","documentation":"TraceModel"},{"declaration":"bool TraceMonsterHull(edict_t@ pEntity, const Vector& in vecStart, const Vector& in vecEnd, IGNORE_MONSTERS igmon, edict_t@ pEntityToIgnore, TraceResult& out ptr)","documentation":"Trace monster hull. Returns true if the trace was entirely in a solid object, or hit something."},{"declaration":"void TraceToss(edict_t@ pEntity, edict_t@ pEntityToIgnore, TraceResult& out traceResult)","documentation":"Trace toss"},{"declaration":"void TraceHull(const Vector& in vecStart, const Vector& in vecEnd, IGNORE_MONSTERS igmon,HULL_NUMBER hullNumber, edict_t@ pEntIgnore, TraceResult& out ptr)","documentation":"Calculates a trace along the given line, storing the results in ptr, using the specified hull type."},{"declaration":"void TraceLine(const Vector& in vecStart, const Vector& in vecEnd, IGNORE_MONSTERS igmon,IGNORE_GLASS ignoreGlass, edict_t@ pEntIgnore, TraceResult& out ptr)","documentation":"Calculates a trace along the given line, storing the results in ptr."},{"declaration":"void TraceLine(const Vector& in vecStart, const Vector& in vecEnd, IGNORE_MONSTERS igmon,edict_t@ pEntIgnore, TraceResult& out ptr)","documentation":"Calculates a trace along the given line, storing the results in ptr."},{"declaration":"bool IsString3DVec(const string& in szString)","documentation":"Returns whether the given string is a 3D vector"},{"declaration":"bool IsWholeNumber(const float flNum, int& out iRounded)","documentation":"Returns whether the given float is a whole number, and returns the rounded number"},{"declaration":"bool IsStringFloat(const string& in szString)","documentation":"Returns whether the given string is a float"},{"declaration":"bool IsStringInt(const string& in szString)","documentation":"Returns whether the given string is an integer"},{"declaration":"void StringToVector(Vector& out vecVector, const string& in szString, const char delimiter = char(' '))","documentation":"Converts the given string to a vector"},{"declaration":"void BubbleTrail(const Vector& in vecFrom, const Vector& in vecTo, int iCount)","documentation":"Creates a trail of bubbles"},{"declaration":"void Bubbles(const Vector& in vecMins, const Vector& in vecMaxs, int iCount)","documentation":"Creates a box filled with bubbles"},{"declaration":"float WaterLevel(const Vector& in vecPosition, float minz, float maxz)","documentation":"Determines the Z level at which a water surface level is, given a position to start searching from and a range to search."},{"declaration":"void Ricochet(const Vector& in vecPosition, float flScale)","documentation":"Creates a ricochet at the given location"},{"declaration":"void Sparks(const Vector& in vecPosition)","documentation":"Creates sparks at the given location"},{"declaration":"void GunshotDecalTrace(TraceResult& in trace, int iDecalNumber)","documentation":"Applies gunshot decal to the trace hit location"},{"declaration":"void PlayerDecalTrace(TraceResult& in trace, int iPlayerNum, int iDecalNumber, const bool bIsCustom)","documentation":"Applies player decal to the trace hit location"},{"declaration":"void DecalTrace(TraceResult& in trace, int iDecalNumber)","documentation":"Applies decal to the trace hit location"},{"declaration":"void BloodDecalTrace(TraceResult& in trace, int iBloodColor)","documentation":"Applies blood decal to the trace hit location"},{"declaration":"bool ShouldShowBlood(int iBloodColor)","documentation":"Returns whether blood of the given type should be shown."},{"declaration":"Vector RandomBloodVector()","documentation":"Returns a random blood direction vector"},{"declaration":"void BloodDrips(const Vector& in vecOrigin, const Vector& in vecDirection, int iColor, int iAmount)","documentation":"Creates blood drips. Use BLOOD_COLOR enum for the color."},{"declaration":"void BloodStream(const Vector& in vecOrigin, const Vector& in vecDirection, int iColor, int iAmount)","documentation":"Creates a blood stream. Use BLOOD_COLOR enum for the color."}],"properties":[],"className":"CUtility","documentation":"Utility methods","namespace":""},{"flags":262145,"methods":[{"declaration":"void EndRevive(float flTimeUntilRevive)","documentation":"Calls the base class implementation of EndRevive"},{"declaration":"void BeginRevive(float flTimeUntilRevive)","documentation":"Calls the base class implementation of BeginRevive"},{"declaration":"bool IsRevivable()","documentation":"Calls the base class implementation of IsRevivable"},{"declaration":"float GetPointsForDamage(float flDamage)","documentation":"Calls the base class implementation of GetPointsForDamage"},{"declaration":"void TraceBleed(float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)","documentation":"Calls the base class implementation of TraceBleed"},{"declaration":"int BloodColor()","documentation":"Calls the base class implementation of BloodColor"},{"declaration":"void Killed(entvars_t@ pevAttacker, int iGib)","documentation":"Calls the base class implementation of Killed"},{"declaration":"bool TakeArmor(float flArmor, int bitsDamageType, float armor_cap = 0)","documentation":"Calls the base class implementation of TakeArmor"},{"declaration":"bool TakeHealth(float flHealth, int bitsDamageType, float health_cap = 0)","documentation":"Calls the base class implementation of TakeHealth"},{"declaration":"int TakeDamage(entvars_t@ pevInflictor, entvars_t@ pevAttacker, float flDamage, int bitsDamageType)","documentation":"Calls the base class implementation of TakeDamage"},{"declaration":"void TraceAttack(entvars_t@ pevAttacker, float flDamage, const Vector& in vecDir, TraceResult& in ptr, int bitsDamageType)","documentation":"Calls the base class implementation of TraceAttack"},{"declaration":"int ObjectCaps()","documentation":"Calls the base class implementation of ObjectCaps"},{"declaration":"void UpdateOnRemove()","documentation":"Calls the base class implementation of UpdateOnRemove"},{"declaration":"void Blocked(CBaseEntity@ pOther)","documentation":"Calls the base class implementation of Blocked"},{"declaration":"void Use(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f)","documentation":"Calls the base class implementation of Use"},{"declaration":"void Touch(CBaseEntity@ pOther)","documentation":"Calls the base class implementation of Touch"},{"declaration":"void Think()","documentation":"Calls the base class implementation of Think"},{"declaration":"void PostSpawn()","documentation":"Calls the base class implementation of PostSpawn"},{"declaration":"void Spawn()","documentation":"Calls the base class implementation of Spawn"},{"declaration":"void PreSpawn()","documentation":"Calls the base class implementation of PreSpawn"},{"declaration":"void Precache()","documentation":"Calls the base class implementation of Precache"},{"declaration":"bool KeyValue(const string& in szKeyName, const string& in szValue)","documentation":"Calls the base class implementation of KeyValue"},{"declaration":"BaseEntity@ opImplCast()","documentation":"Implicitly casts to base type."}],"properties":[],"className":"BaseItem","documentation":"Baseclass for CItem.<br/>Allows calling of the base implementation of certain methods.","namespace":""},{"flags":262145,"methods":[{"declaration":"void EndRevive(float flTimeUntilRevive)","documentation":"Calls the base class implementation of EndRevive"},{"declaration":"void BeginRevive(float flTimeUntilRevive)","documentation":"Calls the base class implementation of BeginRevive"},{"declaration":"bool IsRevivable()","documentation":"Calls the base class implementation of IsRevivable"},{"declaration":"float GetPointsForDamage(float flDamage)","documentation":"Calls the base class implementation of GetPointsForDamage"},{"declaration":"void TraceBleed(float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)","documentation":"Calls the base class implementation of TraceBleed"},{"declaration":"int BloodColor()","documentation":"Calls the base class implementation of BloodColor"},{"declaration":"void Killed(entvars_t@ pevAttacker, int iGib)","documentation":"Calls the base class implementation of Killed"},{"declaration":"bool TakeArmor(float flArmor, int bitsDamageType, float armor_cap = 0)","documentation":"Calls the base class implementation of TakeArmor"},{"declaration":"bool TakeHealth(float flHealth, int bitsDamageType, float health_cap = 0)","documentation":"Calls the base class implementation of TakeHealth"},{"declaration":"int TakeDamage(entvars_t@ pevInflictor, entvars_t@ pevAttacker, float flDamage, int bitsDamageType)","documentation":"Calls the base class implementation of TakeDamage"},{"declaration":"void TraceAttack(entvars_t@ pevAttacker, float flDamage, const Vector& in vecDir, TraceResult& in ptr, int bitsDamageType)","documentation":"Calls the base class implementation of TraceAttack"},{"declaration":"int ObjectCaps()","documentation":"Calls the base class implementation of ObjectCaps"},{"declaration":"void UpdateOnRemove()","documentation":"Calls the base class implementation of UpdateOnRemove"},{"declaration":"void Blocked(CBaseEntity@ pOther)","documentation":"Calls the base class implementation of Blocked"},{"declaration":"void Use(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f)","documentation":"Calls the base class implementation of Use"},{"declaration":"void Touch(CBaseEntity@ pOther)","documentation":"Calls the base class implementation of Touch"},{"declaration":"void Think()","documentation":"Calls the base class implementation of Think"},{"declaration":"void PostSpawn()","documentation":"Calls the base class implementation of PostSpawn"},{"declaration":"void Spawn()","documentation":"Calls the base class implementation of Spawn"},{"declaration":"void PreSpawn()","documentation":"Calls the base class implementation of PreSpawn"},{"declaration":"void Precache()","documentation":"Calls the base class implementation of Precache"},{"declaration":"bool KeyValue(const string& in szKeyName, const string& in szValue)","documentation":"Calls the base class implementation of KeyValue"},{"declaration":"BaseEntity@ opImplCast()","documentation":"Implicitly casts to base type."}],"properties":[],"className":"BasePlayerAmmo","documentation":"Baseclass for CBasePlayerAmmo.<br/>Allows calling of the base implementation of certain methods.","namespace":""},{"flags":262145,"methods":[{"declaration":"void BurstSupplement()","documentation":"Calls the base class implementation of BurstSupplement"},{"declaration":"bool UseDecrement()","documentation":"Calls the base class implementation of UseDecrement"},{"declaration":"bool ShouldWeaponIdle()","documentation":"Calls the base class implementation of ShouldWeaponIdle"},{"declaration":"void RetireWeapon()","documentation":"Calls the base class implementation of RetireWeapon"},{"declaration":"void WeaponIdle()","documentation":"Calls the base class implementation of WeaponIdle"},{"declaration":"bool ShouldReload()","documentation":"Calls the base class implementation of ShouldReload"},{"declaration":"void FinishReload()","documentation":"Calls the base class implementation of FinishReload"},{"declaration":"void Reload()","documentation":"Calls the base class implementation of Reload"},{"declaration":"void TertiaryAttack()","documentation":"Calls the base class implementation of TertiaryAttack"},{"declaration":"void SecondaryAttack()","documentation":"Calls the base class implementation of SecondaryAttack"},{"declaration":"void PrimaryAttack()","documentation":"Calls the base class implementation of PrimaryAttack"},{"declaration":"bool IsUseable()","documentation":"Calls the base class implementation of IsUseable"},{"declaration":"Vector BulletAccuracy(const Vector& in vecMoving, const Vector& in vecStanding, const Vector& in vecCrouched)","documentation":"Calls the base class implementation of BulletAccuracy"},{"declaration":"void SendWeaponAnim(int iAnim, int skiplocal = 0, int body = 0)","documentation":"Calls the base class implementation of SendWeaponAnim"},{"declaration":"void ResetEmptySound()","documentation":"Calls the base class implementation of ResetEmptySound"},{"declaration":"bool PlayEmptySound()","documentation":"Calls the base class implementation of PlayEmptySound"},{"declaration":"bool AddWeapon()","documentation":"Calls the base class implementation of AddWeapon"},{"declaration":"bool ExtractAmmo(CBasePlayerWeapon@ pWeapon)","documentation":"Calls the base class implementation of ExtractAmmo"},{"declaration":"bool CanHaveDuplicates()","documentation":"Calls the base class implementation of CanHaveDuplicates"},{"declaration":"CBasePlayerItem@ DropItem()","documentation":"Calls the base class implementation of DropItem"},{"declaration":"float GetRespawnTime() const","documentation":"Calls the base class implementation of GetRespawnTime"},{"declaration":"bool UpdateClientData(CBasePlayer@ pPlayer)","documentation":"Calls the base class implementation of UpdateClientData"},{"declaration":"int SecondaryAmmoIndex()","documentation":"Calls the base class implementation of SecondaryAmmoIndex"},{"declaration":"int PrimaryAmmoIndex()","documentation":"Calls the base class implementation of PrimaryAmmoIndex"},{"declaration":"void AttachToPlayer(CBasePlayer@ pPlayer)","documentation":"Calls the base class implementation of AttachToPlayer"},{"declaration":"void Kill()","documentation":"Calls the base class implementation of Kill"},{"declaration":"void Drop()","documentation":"Calls the base class implementation of Drop"},{"declaration":"void InactiveItemPostFrame()","documentation":"Calls the base class implementation of InactiveItemPostFrame"},{"declaration":"void InactiveItemPreFrame()","documentation":"Calls the base class implementation of InactiveItemPreFrame"},{"declaration":"void ItemPostFrame()","documentation":"Calls the base class implementation of ItemPostFrame"},{"declaration":"void ItemPreFrame()","documentation":"Calls the base class implementation of ItemPreFrame"},{"declaration":"void UpdateItemInfo()","documentation":"Calls the base class implementation of UpdateItemInfo"},{"declaration":"void Holster(int skiplocal = 0)","documentation":"Calls the base class implementation of Holster"},{"declaration":"bool CanHolster()","documentation":"Calls the base class implementation of CanHolster"},{"declaration":"bool Deploy()","documentation":"Calls the base class implementation of Deploy"},{"declaration":"bool CanDeploy()","documentation":"Calls the base class implementation of CanDeploy"},{"declaration":"void GetItemInfo(ItemInfo& out info)","documentation":"Calls the base class implementation of GetItemInfo"},{"declaration":"void Materialize()","documentation":"Calls the base class implementation of Materialize"},{"declaration":"bool AddDuplicate(CBasePlayerItem@ pItem)","documentation":"Calls the base class implementation of AddDuplicate"},{"declaration":"bool AddToPlayer(CBasePlayer@ pPlayer)","documentation":"Calls the base class implementation of AddToPlayer"},{"declaration":"BasePlayerItem@ opImplCast()","documentation":"Implicitly casts to base type."},{"declaration":"void EndRevive(float flTimeUntilRevive)","documentation":"Calls the base class implementation of EndRevive"},{"declaration":"void BeginRevive(float flTimeUntilRevive)","documentation":"Calls the base class implementation of BeginRevive"},{"declaration":"bool IsRevivable()","documentation":"Calls the base class implementation of IsRevivable"},{"declaration":"float GetPointsForDamage(float flDamage)","documentation":"Calls the base class implementation of GetPointsForDamage"},{"declaration":"void TraceBleed(float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)","documentation":"Calls the base class implementation of TraceBleed"},{"declaration":"int BloodColor()","documentation":"Calls the base class implementation of BloodColor"},{"declaration":"void Killed(entvars_t@ pevAttacker, int iGib)","documentation":"Calls the base class implementation of Killed"},{"declaration":"bool TakeArmor(float flArmor, int bitsDamageType, float armor_cap = 0)","documentation":"Calls the base class implementation of TakeArmor"},{"declaration":"bool TakeHealth(float flHealth, int bitsDamageType, float health_cap = 0)","documentation":"Calls the base class implementation of TakeHealth"},{"declaration":"int TakeDamage(entvars_t@ pevInflictor, entvars_t@ pevAttacker, float flDamage, int bitsDamageType)","documentation":"Calls the base class implementation of TakeDamage"},{"declaration":"void TraceAttack(entvars_t@ pevAttacker, float flDamage, const Vector& in vecDir, TraceResult& in ptr, int bitsDamageType)","documentation":"Calls the base class implementation of TraceAttack"},{"declaration":"int ObjectCaps()","documentation":"Calls the base class implementation of ObjectCaps"},{"declaration":"void UpdateOnRemove()","documentation":"Calls the base class implementation of UpdateOnRemove"},{"declaration":"void Blocked(CBaseEntity@ pOther)","documentation":"Calls the base class implementation of Blocked"},{"declaration":"void Use(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f)","documentation":"Calls the base class implementation of Use"},{"declaration":"void Touch(CBaseEntity@ pOther)","documentation":"Calls the base class implementation of Touch"},{"declaration":"void Think()","documentation":"Calls the base class implementation of Think"},{"declaration":"void PostSpawn()","documentation":"Calls the base class implementation of PostSpawn"},{"declaration":"void Spawn()","documentation":"Calls the base class implementation of Spawn"},{"declaration":"void PreSpawn()","documentation":"Calls the base class implementation of PreSpawn"},{"declaration":"void Precache()","documentation":"Calls the base class implementation of Precache"},{"declaration":"bool KeyValue(const string& in szKeyName, const string& in szValue)","documentation":"Calls the base class implementation of KeyValue"},{"declaration":"BaseEntity@ opImplCast()","documentation":"Implicitly casts to base type."}],"properties":[],"className":"BasePlayerWeapon","documentation":"Baseclass for CBasePlayerWeapon.<br/>Allows calling of the base implementation of certain methods.","namespace":""},{"flags":262145,"methods":[{"declaration":"BasePlayerWeapon@ opCast()","documentation":"Explicitly casts to sub type."},{"declaration":"bool CanHaveDuplicates()","documentation":"Calls the base class implementation of CanHaveDuplicates"},{"declaration":"CBasePlayerItem@ DropItem()","documentation":"Calls the base class implementation of DropItem"},{"declaration":"float GetRespawnTime() const","documentation":"Calls the base class implementation of GetRespawnTime"},{"declaration":"bool UpdateClientData(CBasePlayer@ pPlayer)","documentation":"Calls the base class implementation of UpdateClientData"},{"declaration":"int SecondaryAmmoIndex()","documentation":"Calls the base class implementation of SecondaryAmmoIndex"},{"declaration":"int PrimaryAmmoIndex()","documentation":"Calls the base class implementation of PrimaryAmmoIndex"},{"declaration":"void AttachToPlayer(CBasePlayer@ pPlayer)","documentation":"Calls the base class implementation of AttachToPlayer"},{"declaration":"void Kill()","documentation":"Calls the base class implementation of Kill"},{"declaration":"void Drop()","documentation":"Calls the base class implementation of Drop"},{"declaration":"void InactiveItemPostFrame()","documentation":"Calls the base class implementation of InactiveItemPostFrame"},{"declaration":"void InactiveItemPreFrame()","documentation":"Calls the base class implementation of InactiveItemPreFrame"},{"declaration":"void ItemPostFrame()","documentation":"Calls the base class implementation of ItemPostFrame"},{"declaration":"void ItemPreFrame()","documentation":"Calls the base class implementation of ItemPreFrame"},{"declaration":"void UpdateItemInfo()","documentation":"Calls the base class implementation of UpdateItemInfo"},{"declaration":"void Holster(int skiplocal = 0)","documentation":"Calls the base class implementation of Holster"},{"declaration":"bool CanHolster()","documentation":"Calls the base class implementation of CanHolster"},{"declaration":"bool Deploy()","documentation":"Calls the base class implementation of Deploy"},{"declaration":"bool CanDeploy()","documentation":"Calls the base class implementation of CanDeploy"},{"declaration":"void GetItemInfo(ItemInfo& out info)","documentation":"Calls the base class implementation of GetItemInfo"},{"declaration":"void Materialize()","documentation":"Calls the base class implementation of Materialize"},{"declaration":"bool AddDuplicate(CBasePlayerItem@ pItem)","documentation":"Calls the base class implementation of AddDuplicate"},{"declaration":"bool AddToPlayer(CBasePlayer@ pPlayer)","documentation":"Calls the base class implementation of AddToPlayer"},{"declaration":"void EndRevive(float flTimeUntilRevive)","documentation":"Calls the base class implementation of EndRevive"},{"declaration":"void BeginRevive(float flTimeUntilRevive)","documentation":"Calls the base class implementation of BeginRevive"},{"declaration":"bool IsRevivable()","documentation":"Calls the base class implementation of IsRevivable"},{"declaration":"float GetPointsForDamage(float flDamage)","documentation":"Calls the base class implementation of GetPointsForDamage"},{"declaration":"void TraceBleed(float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)","documentation":"Calls the base class implementation of TraceBleed"},{"declaration":"int BloodColor()","documentation":"Calls the base class implementation of BloodColor"},{"declaration":"void Killed(entvars_t@ pevAttacker, int iGib)","documentation":"Calls the base class implementation of Killed"},{"declaration":"bool TakeArmor(float flArmor, int bitsDamageType, float armor_cap = 0)","documentation":"Calls the base class implementation of TakeArmor"},{"declaration":"bool TakeHealth(float flHealth, int bitsDamageType, float health_cap = 0)","documentation":"Calls the base class implementation of TakeHealth"},{"declaration":"int TakeDamage(entvars_t@ pevInflictor, entvars_t@ pevAttacker, float flDamage, int bitsDamageType)","documentation":"Calls the base class implementation of TakeDamage"},{"declaration":"void TraceAttack(entvars_t@ pevAttacker, float flDamage, const Vector& in vecDir, TraceResult& in ptr, int bitsDamageType)","documentation":"Calls the base class implementation of TraceAttack"},{"declaration":"int ObjectCaps()","documentation":"Calls the base class implementation of ObjectCaps"},{"declaration":"void UpdateOnRemove()","documentation":"Calls the base class implementation of UpdateOnRemove"},{"declaration":"void Blocked(CBaseEntity@ pOther)","documentation":"Calls the base class implementation of Blocked"},{"declaration":"void Use(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f)","documentation":"Calls the base class implementation of Use"},{"declaration":"void Touch(CBaseEntity@ pOther)","documentation":"Calls the base class implementation of Touch"},{"declaration":"void Think()","documentation":"Calls the base class implementation of Think"},{"declaration":"void PostSpawn()","documentation":"Calls the base class implementation of PostSpawn"},{"declaration":"void Spawn()","documentation":"Calls the base class implementation of Spawn"},{"declaration":"void PreSpawn()","documentation":"Calls the base class implementation of PreSpawn"},{"declaration":"void Precache()","documentation":"Calls the base class implementation of Precache"},{"declaration":"bool KeyValue(const string& in szKeyName, const string& in szValue)","documentation":"Calls the base class implementation of KeyValue"},{"declaration":"BaseEntity@ opImplCast()","documentation":"Implicitly casts to base type."}],"properties":[],"className":"BasePlayerItem","documentation":"Baseclass for CBasePlayerItem.<br/>Allows calling of the base implementation of certain methods.","namespace":""},{"flags":262145,"methods":[{"declaration":"int BulletCount()","documentation":"Calls the base class implementation of BulletCount"},{"declaration":"Vector UpdateTargetPosition(CBaseEntity@ pTargetEntity)","documentation":"Calls the base class implementation of UpdateTargetPosition"},{"declaration":"void Fire(const Vector& in vecBarrelEnd, const Vector& in vecForward, entvars_t@ pevAttacker)","documentation":"Calls the base class implementation of Fire"},{"declaration":"void EndRevive(float flTimeUntilRevive)","documentation":"Calls the base class implementation of EndRevive"},{"declaration":"void BeginRevive(float flTimeUntilRevive)","documentation":"Calls the base class implementation of BeginRevive"},{"declaration":"bool IsRevivable()","documentation":"Calls the base class implementation of IsRevivable"},{"declaration":"float GetPointsForDamage(float flDamage)","documentation":"Calls the base class implementation of GetPointsForDamage"},{"declaration":"void TraceBleed(float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)","documentation":"Calls the base class implementation of TraceBleed"},{"declaration":"int BloodColor()","documentation":"Calls the base class implementation of BloodColor"},{"declaration":"void Killed(entvars_t@ pevAttacker, int iGib)","documentation":"Calls the base class implementation of Killed"},{"declaration":"bool TakeArmor(float flArmor, int bitsDamageType, float armor_cap = 0)","documentation":"Calls the base class implementation of TakeArmor"},{"declaration":"bool TakeHealth(float flHealth, int bitsDamageType, float health_cap = 0)","documentation":"Calls the base class implementation of TakeHealth"},{"declaration":"int TakeDamage(entvars_t@ pevInflictor, entvars_t@ pevAttacker, float flDamage, int bitsDamageType)","documentation":"Calls the base class implementation of TakeDamage"},{"declaration":"void TraceAttack(entvars_t@ pevAttacker, float flDamage, const Vector& in vecDir, TraceResult& in ptr, int bitsDamageType)","documentation":"Calls the base class implementation of TraceAttack"},{"declaration":"int ObjectCaps()","documentation":"Calls the base class implementation of ObjectCaps"},{"declaration":"void UpdateOnRemove()","documentation":"Calls the base class implementation of UpdateOnRemove"},{"declaration":"void Blocked(CBaseEntity@ pOther)","documentation":"Calls the base class implementation of Blocked"},{"declaration":"void Use(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f)","documentation":"Calls the base class implementation of Use"},{"declaration":"void Touch(CBaseEntity@ pOther)","documentation":"Calls the base class implementation of Touch"},{"declaration":"void Think()","documentation":"Calls the base class implementation of Think"},{"declaration":"void PostSpawn()","documentation":"Calls the base class implementation of PostSpawn"},{"declaration":"void Spawn()","documentation":"Calls the base class implementation of Spawn"},{"declaration":"void PreSpawn()","documentation":"Calls the base class implementation of PreSpawn"},{"declaration":"void Precache()","documentation":"Calls the base class implementation of Precache"},{"declaration":"bool KeyValue(const string& in szKeyName, const string& in szValue)","documentation":"Calls the base class implementation of KeyValue"},{"declaration":"BaseEntity@ opImplCast()","documentation":"Implicitly casts to base type."}],"properties":[],"className":"BaseTank","documentation":"Baseclass for CBaseTank.<br/>Allows calling of the base implementation of certain methods.","namespace":""},{"flags":262145,"methods":[{"declaration":"void GibMonster()","documentation":"Calls the base class implementation of GibMonster"},{"declaration":"void CallGibMonster()","documentation":"Calls the base class implementation of CallGibMonster"},{"declaration":"void RunAI()","documentation":"Calls the base class implementation of RunAI"},{"declaration":"Schedule@ ScheduleFromName(const string& in szName)","documentation":"Calls the base class implementation of ScheduleFromName"},{"declaration":"Schedule@ GetSchedule()","documentation":"Calls the base class implementation of GetSchedule"},{"declaration":"Schedule@ GetScheduleOfType(int iType)","documentation":"Calls the base class implementation of GetScheduleOfType"},{"declaration":"void HandleAnimEvent(MonsterEvent@ pEvent)","documentation":"Calls the base class implementation of HandleAnimEvent"},{"declaration":"void RunTask(Task@ pTask)","documentation":"Calls the base class implementation of RunTask"},{"declaration":"void StartTask(Task@ pTask)","documentation":"Calls the base class implementation of StartTask"},{"declaration":"void SetYawSpeed()","documentation":"Calls the base class implementation of SetYawSpeed"},{"declaration":"void CheckAmmo()","documentation":"Calls the base class implementation of CheckAmmo"},{"declaration":"bool CheckMeleeAttack2_Move(float flDot, float flDist)","documentation":"Calls the base class implementation of CheckMeleeAttack2_Move"},{"declaration":"bool CheckMeleeAttack2(float flDot, float flDist)","documentation":"Calls the base class implementation of CheckMeleeAttack2"},{"declaration":"bool CheckMeleeAttack1_Move(float flDot, float flDist)","documentation":"Calls the base class implementation of CheckMeleeAttack1_Move"},{"declaration":"bool CheckMeleeAttack1(float flDot, float flDist)","documentation":"Calls the base class implementation of CheckMeleeAttack1"},{"declaration":"bool CheckRangeAttack2_Move(float flDot, float flDist)","documentation":"Calls the base class implementation of CheckRangeAttack2_Move"},{"declaration":"bool CheckRangeAttack2(float flDot, float flDist)","documentation":"Calls the base class implementation of CheckRangeAttack2"},{"declaration":"bool CheckRangeAttack1_Move(float flDot, float flDist)","documentation":"Calls the base class implementation of CheckRangeAttack1_Move"},{"declaration":"bool CheckRangeAttack1(float flDot, float flDist)","documentation":"Calls the base class implementation of CheckRangeAttack1"},{"declaration":"int ISoundMask()","documentation":"Calls the base class implementation of RunAI"},{"declaration":"void DeathSound()","documentation":"Calls the base class implementation of DeathSound"},{"declaration":"void PainSound()","documentation":"Calls the base class implementation of PainSound"},{"declaration":"void AlertSound()","documentation":"Calls the base class implementation of AlertSound"},{"declaration":"int IgnoreConditions()","documentation":"Calls the base class implementation of IgnoreConditions"},{"declaration":"int Classify()","documentation":"Calls the base class implementation of Classify"},{"declaration":"void SetupFriendly()","documentation":"Calls the base class implementation of SetupFriendly"},{"declaration":"void EndRevive(float flTimeUntilRevive)","documentation":"Calls the base class implementation of EndRevive"},{"declaration":"void BeginRevive(float flTimeUntilRevive)","documentation":"Calls the base class implementation of BeginRevive"},{"declaration":"bool IsRevivable()","documentation":"Calls the base class implementation of IsRevivable"},{"declaration":"float GetPointsForDamage(float flDamage)","documentation":"Calls the base class implementation of GetPointsForDamage"},{"declaration":"void TraceBleed(float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)","documentation":"Calls the base class implementation of TraceBleed"},{"declaration":"int BloodColor()","documentation":"Calls the base class implementation of BloodColor"},{"declaration":"void Killed(entvars_t@ pevAttacker, int iGib)","documentation":"Calls the base class implementation of Killed"},{"declaration":"bool TakeArmor(float flArmor, int bitsDamageType, float armor_cap = 0)","documentation":"Calls the base class implementation of TakeArmor"},{"declaration":"bool TakeHealth(float flHealth, int bitsDamageType, float health_cap = 0)","documentation":"Calls the base class implementation of TakeHealth"},{"declaration":"int TakeDamage(entvars_t@ pevInflictor, entvars_t@ pevAttacker, float flDamage, int bitsDamageType)","documentation":"Calls the base class implementation of TakeDamage"},{"declaration":"void TraceAttack(entvars_t@ pevAttacker, float flDamage, const Vector& in vecDir, TraceResult& in ptr, int bitsDamageType)","documentation":"Calls the base class implementation of TraceAttack"},{"declaration":"int ObjectCaps()","documentation":"Calls the base class implementation of ObjectCaps"},{"declaration":"void UpdateOnRemove()","documentation":"Calls the base class implementation of UpdateOnRemove"},{"declaration":"void Blocked(CBaseEntity@ pOther)","documentation":"Calls the base class implementation of Blocked"},{"declaration":"void Use(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f)","documentation":"Calls the base class implementation of Use"},{"declaration":"void Touch(CBaseEntity@ pOther)","documentation":"Calls the base class implementation of Touch"},{"declaration":"void Think()","documentation":"Calls the base class implementation of Think"},{"declaration":"void PostSpawn()","documentation":"Calls the base class implementation of PostSpawn"},{"declaration":"void Spawn()","documentation":"Calls the base class implementation of Spawn"},{"declaration":"void PreSpawn()","documentation":"Calls the base class implementation of PreSpawn"},{"declaration":"void Precache()","documentation":"Calls the base class implementation of Precache"},{"declaration":"bool KeyValue(const string& in szKeyName, const string& in szValue)","documentation":"Calls the base class implementation of KeyValue"},{"declaration":"BaseEntity@ opImplCast()","documentation":"Implicitly casts to base type."}],"properties":[],"className":"BaseMonster","documentation":"Baseclass for CBaseMonster.<br/>Allows calling of the base implementation of certain methods.","namespace":""},{"flags":262145,"methods":[{"declaration":"BaseItem@ opCast()","documentation":"Explicitly casts to sub type."},{"declaration":"BasePlayerAmmo@ opCast()","documentation":"Explicitly casts to sub type."},{"declaration":"BasePlayerWeapon@ opCast()","documentation":"Explicitly casts to sub type."},{"declaration":"BasePlayerItem@ opCast()","documentation":"Explicitly casts to sub type."},{"declaration":"BaseTank@ opCast()","documentation":"Explicitly casts to sub type."},{"declaration":"BaseMonster@ opCast()","documentation":"Explicitly casts to sub type."},{"declaration":"void EndRevive(float flTimeUntilRevive)","documentation":"Calls the base class implementation of EndRevive"},{"declaration":"void BeginRevive(float flTimeUntilRevive)","documentation":"Calls the base class implementation of BeginRevive"},{"declaration":"bool IsRevivable()","documentation":"Calls the base class implementation of IsRevivable"},{"declaration":"float GetPointsForDamage(float flDamage)","documentation":"Calls the base class implementation of GetPointsForDamage"},{"declaration":"void TraceBleed(float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)","documentation":"Calls the base class implementation of TraceBleed"},{"declaration":"int BloodColor()","documentation":"Calls the base class implementation of BloodColor"},{"declaration":"void Killed(entvars_t@ pevAttacker, int iGib)","documentation":"Calls the base class implementation of Killed"},{"declaration":"bool TakeArmor(float flArmor, int bitsDamageType, float armor_cap = 0)","documentation":"Calls the base class implementation of TakeArmor"},{"declaration":"bool TakeHealth(float flHealth, int bitsDamageType, float health_cap = 0)","documentation":"Calls the base class implementation of TakeHealth"},{"declaration":"int TakeDamage(entvars_t@ pevInflictor, entvars_t@ pevAttacker, float flDamage, int bitsDamageType)","documentation":"Calls the base class implementation of TakeDamage"},{"declaration":"void TraceAttack(entvars_t@ pevAttacker, float flDamage, const Vector& in vecDir, TraceResult& in ptr, int bitsDamageType)","documentation":"Calls the base class implementation of TraceAttack"},{"declaration":"int ObjectCaps()","documentation":"Calls the base class implementation of ObjectCaps"},{"declaration":"void UpdateOnRemove()","documentation":"Calls the base class implementation of UpdateOnRemove"},{"declaration":"void Blocked(CBaseEntity@ pOther)","documentation":"Calls the base class implementation of Blocked"},{"declaration":"void Use(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f)","documentation":"Calls the base class implementation of Use"},{"declaration":"void Touch(CBaseEntity@ pOther)","documentation":"Calls the base class implementation of Touch"},{"declaration":"void Think()","documentation":"Calls the base class implementation of Think"},{"declaration":"void PostSpawn()","documentation":"Calls the base class implementation of PostSpawn"},{"declaration":"void Spawn()","documentation":"Calls the base class implementation of Spawn"},{"declaration":"void PreSpawn()","documentation":"Calls the base class implementation of PreSpawn"},{"declaration":"void Precache()","documentation":"Calls the base class implementation of Precache"},{"declaration":"bool KeyValue(const string& in szKeyName, const string& in szValue)","documentation":"Calls the base class implementation of KeyValue"}],"properties":[],"className":"BaseEntity","documentation":"Baseclass for CBaseEntity.<br/>Allows calling of the base implementation of certain methods.","namespace":""},{"flags":262145,"methods":[{"declaration":"void UnRegisterCustomEntity(const string& in szEntityname)","documentation":"Unregisters a custom entity by the given name"},{"declaration":"void RegisterCustomEntity(const string& in szClassname, const string& in szEntityname)","documentation":"Registers a class called szClassname as a custom entity named szEntityname. The class must inherit from a script entity base class."},{"declaration":"bool IsCustomEntity(const string& in szEntityname) const","documentation":"Returns whether the given entity name is a registered custom entity"}],"properties":[],"className":"CCustomEntityFuncs","documentation":"Custom entity functions.","namespace":""},{"flags":262145,"methods":[{"declaration":"void SetUseFunction(UseFunction@ pFunction)","documentation":"Sets the use function for this handler's owning instance."},{"declaration":"void SetBlockedFunction(BlockedFunction@ pFunction)","documentation":"Sets the blocked function for this handler's owning instance."},{"declaration":"void SetTouchFunction(TouchFunction@ pFunction)","documentation":"Sets the touch function for this handler's owning instance."},{"declaration":"void SetThinkFunction(ThinkFunction@ pFunction)","documentation":"Sets the think function for this handler's owning instance."}],"properties":[],"className":"CustomEntityCallbackHandler","documentation":"Custom entity callback handler. Is used to set callbacks to methods","namespace":""},{"flags":262145,"methods":[{"declaration":"bool LoadFromFile(const string& in szFileName, const Vector& in vecOffset = g_vecZero)","documentation":"Loads entities from a file."}],"properties":[],"className":"CEntityLoader","documentation":"Entity loader.<br/>Loads entity keyvalue data and instances the entities.<br/>File format:<br/>\"Entity\"{\t\"classname\" \"info_player_deathmatch\"\t<additional keyvalues>}...","namespace":""},{"flags":262145,"methods":[{"declaration":"int RegisterWeapon(const string& in szName, const string& in szSpriteDir, const string& in szPrimaryAmmoName = \"\", const string& in szSecondaryAmmoName = \"\")","documentation":"Registers the given entity name as a weapon and returns the id associated with it.<br/>Returns WEAPON_NONE if no id could be assigned to it."},{"declaration":"int RegisterItem(const string& in szName, const string& in szSpriteDir, const string& in szPrimaryAmmoName = \"\", const string& in szSecondaryAmmoName = \"\")","documentation":"Registers the given entity name as an item and returns the id associated with it.<br/>Returns WEAPON_NONE if no id could be assigned to it."},{"declaration":"int GetIdForName(const string& in szName) const","documentation":"Gets the id associated with the given weapon name. Returns WEAPON_NONE if no id is associated with the given name."}],"properties":[],"className":"CItemRegistry","documentation":"Item registry.","namespace":""},{"flags":5890,"methods":[{"declaration":"string szAmmo2() const","documentation":"Gets the secondary ammo name of this weapon."},{"declaration":"string szAmmo1() const","documentation":"Gets the primary ammo name of this weapon."},{"declaration":"string szName() const","documentation":"Gets the name of this weapon."},{"declaration":"void DestructItemInfo()","documentation":"Destructor"},{"declaration":"void ItemInfo(const ItemInfo& in other)","documentation":"Constructor"},{"declaration":"void ItemInfo()","documentation":"Constructor"}],"properties":[{"namespace":"","declaration":"int iMaxClip","documentation":"Item primary ammo max clip contents."},{"namespace":"","declaration":"int iMaxAmmo2","documentation":"Item secondary max ammo. -1 if this weapon does not use secondary ammo."},{"namespace":"","declaration":"int iMaxAmmo1","documentation":"Item primary max ammo. -1 if this weapon does not use primary ammo."},{"namespace":"","declaration":"int iWeight","documentation":"Item weight.<br/>This value used to determine this weapon's importance in autoselection."},{"namespace":"","declaration":"int iFlags","documentation":"Item flags."},{"namespace":"","declaration":"int iPosition","documentation":"Item HUD slot position."},{"namespace":"","declaration":"int iSlot","documentation":"Item HUD slot."},{"namespace":"","declaration":"int iId","documentation":"Item id."}],"className":"ItemInfo","documentation":"Item info object.","namespace":""},{"flags":262145,"methods":[{"declaration":"void PurgeOnRespawn(CBaseMonster@ pHolder)","documentation":"Clears all held inventory that should be dropped on respawning"},{"declaration":"void ClearAll(CBaseMonster@ pHolder)","documentation":"Clears all held inventory"},{"declaration":"bool HasAllInGroup(CBaseMonster@ pHolder, const string& in szGroup)","documentation":"Returns true if is holding all items of a group"},{"declaration":"int HaveNumFromGroup(CBaseMonster@ pHolder, const string& in szGroup)","documentation":"Returns count of how many items someone holds of a group"},{"declaration":"int ExistsInGroup(const string& in szGroup)","documentation":"Counts all the existing items in a group"},{"declaration":"float GetWeight(CBaseMonster@ pHolder)","documentation":"Gets the total weight of all inventory items held by the given holder"},{"declaration":"int Count(CBaseMonster@ pHolder)","documentation":"Counts the number of inventory items held by the given holder"},{"declaration":"bool CheckTokenStringRule(const string& in szRule, const string& in szValue)","documentation":"Returns whether the given value is in the given rule"},{"declaration":"bool IsValidInventoryHolder(CBaseEntity@ pOther)","documentation":"Returns whether the given entity is a valid inventory holder"}],"properties":[],"className":"CInventoryMisc","documentation":"Misc functions for handling inventories across classes","namespace":""},{"flags":262145,"methods":[],"properties":[{"namespace":"","declaration":"InventoryList@ pNext","documentation":"Next item in the list"},{"namespace":"","declaration":"CItemInventory@ pItem","documentation":"Item"}],"className":"InventoryList","documentation":"Structure for a list of item_inventory's stored within CBaseMonster","namespace":""},{"flags":262145,"methods":[{"declaration":"bool CanUseTrigger(CBaseEntity@ pActivator, bool fContinueByDefault = false)","documentation":"Returns whether the owning trigger can be triggered by the given activator."}],"properties":[{"namespace":"","declaration":"string_t m_szTargetOnFail","documentation":"Trigger on failed match"},{"namespace":"","declaration":"string_t m_szDestroyItemGroupOnUse","documentation":"Destroy item(s) in these group(s)"},{"namespace":"","declaration":"string_t m_szDestroyItemNameOnUse","documentation":"Destroy item(s)"},{"namespace":"","declaration":"string_t m_szReturnItemGroupOnUse","documentation":"Return item(s) in these group(s)"},{"namespace":"","declaration":"string_t m_szReturnItemNameOnUse","documentation":"Return item(s)"},{"namespace":"","declaration":"string_t m_szDropItemGroupOnUse","documentation":"Drop item(s) in these group(s)"},{"namespace":"","declaration":"string_t m_szDropItemNameOnUse","documentation":"Drop item(s)"},{"namespace":"","declaration":"int m_iCantHaveItemGroupNum","documentation":"Number of item(s) from the can't have group(s) (0 = all)"},{"namespace":"","declaration":"string_t m_szCantHaveItemGroup","documentation":"Must not have an item in these group(s)"},{"namespace":"","declaration":"string_t m_szCantHaveItemName","documentation":"Must not have these item(s)"},{"namespace":"","declaration":"int m_iRequiresItemGroupNum","documentation":"Number of item(s) from the required group(s) required (0 = all)"},{"namespace":"","declaration":"string_t m_szRequiresItemGroup","documentation":"Require an item from these group(s)"},{"namespace":"","declaration":"string_t m_szRequiresItemName","documentation":"Require these item(s)"},{"namespace":"","declaration":"CBaseEntity@ m_pEntity","documentation":"Owning entity"}],"className":"InventoryRules","documentation":"Inventory rules: Contained by CBaseToggle to hold and<br/>manage inventory rules attached to a triggerable entity","namespace":""},{"flags":262145,"methods":[{"declaration":"int ISoundsInList(int iListType)","documentation":"Returns the number of sounds in the given list. Must be either SOUNDLISTTYPE_FREE or SOUNDLISTTYPE_ACTIVE."},{"declaration":"bool IsEmpty()","documentation":"Returns whether the sound list is empty."},{"declaration":"int ClientSoundIndex(edict_t@ pClient)","documentation":"Gets the index for the given client."},{"declaration":"CSound@ SoundPointerForIndex(int iIndex)","documentation":"Return a pointer for this index in the sound list.<br/>Index must be between 0 and MAX_WORLD_SOUNDS."},{"declaration":"int FreeList()","documentation":"Returns the head of the free list."},{"declaration":"int ActiveList()","documentation":"Returns the head of the active list."},{"declaration":"void InsertSound(int iType, const Vector& in vecOrigin, int iVolume, float flDuration, CBaseEntity@ pOwner)","documentation":"Inserts a sound. iType is one of the bits_SOUND enum."}],"properties":[{"namespace":"","declaration":"const int m_cLastActiveSounds","documentation":"keeps track of the number of active sounds at the last update. (for diagnostic work)"}],"className":"CSoundEnt","documentation":"Sound manager entity. Manages sound events made in the world, like gunfire.<br/>Does not handle the playing of sounds, see CSoundEngine for actual sound playing.","namespace":""},{"flags":262145,"methods":[{"declaration":"bool FIsScent()","documentation":"Returns whether this is a scent"},{"declaration":"bool FIsSound()","documentation":"Returns whether this is a sound"},{"declaration":"void Reset()","documentation":"Resets the sound"},{"declaration":"void Clear()","documentation":"Clears the sound"}],"properties":[{"namespace":"","declaration":"edict_t@ pOwner","documentation":"Sounds now have OWNERS... (For various AI checks)"},{"namespace":"","declaration":"int m_iNextAudible","documentation":"Temporary link that monsters use to build a list of audible sounds"},{"namespace":"","declaration":"int m_iNext","documentation":"Index of next sound in this list ( Active or Free )"},{"namespace":"","declaration":"float m_flExpireTime","documentation":"When the sound should be purged from the list"},{"namespace":"","declaration":"int m_iVolume","documentation":"How loud the sound is"},{"namespace":"","declaration":"int m_iType","documentation":"What type of sound this is"},{"namespace":"","declaration":"Vector m_vecOrigin","documentation":"Sound's location in space"}],"className":"CSound","documentation":"Sound class used by CSoundEnt","namespace":""},{"flags":262145,"methods":[{"declaration":"string GetPlayerAuthId(edict_t@ pEdict)","documentation":"Get player auth id. (WON/Steam id)"},{"declaration":"void Voice_SetClientListening(int iReceiver, int iSender, bool fListen)","documentation":"Voice set client listening"},{"declaration":"void Voice_GetClientListening(int iReceiver, int iSender)","documentation":"Voice get client listening"},{"declaration":"void GetPlayerStats(const edict_t@ pEdict, int& out iPing, int& out iPacketLoss)","documentation":"Get player stats"},{"declaration":"const Cvar@ CVarGetPointer(const string& in szCvar) const","documentation":"Gets a pointer to a cvar"},{"declaration":"bool IsDedicatedServer() const","documentation":"Returns whether this is a dedicated server"},{"declaration":"int GetPlayerUserId(edict_t@ pEdict)","documentation":"Get player user ID. This is a unique id generated when a player connects. It remains valid as long as the player stays connected to the server."},{"declaration":"void StaticDecal(const Vector& in vecOrigin, int iDecalIndex, int iEntityIndex, int iModelIndex)","documentation":"Project a static decal"},{"declaration":"bool IsMapValid(const string& in szMapName) const","documentation":"Returns whether map is valid"},{"declaration":"KeyValueBuffer@ GetPhysicsKeyBuffer(edict_t@ pEdict)","documentation":"Get physics key buffer"},{"declaration":"KeyValueBuffer@ GetInfoKeyBuffer(edict_t@ pEdict)","documentation":"Get info key buffer"},{"declaration":"int NumberOfEntities()","documentation":"Get number of entities"},{"declaration":"void RunPlayerMove(edict_t@ pEdict, const Vector& in vecViewAngles, float flFowardMove, float flSideMove, float flUpMove, uint16 iButtons, uint8 iImpulse, uint8 iMsec)","documentation":"Run player move"},{"declaration":"void SetClientMaxspeed(const edict_t@ pEdict, float flNewMaxSpeed)","documentation":"Set client max speed"},{"declaration":"string GetGameDir()","documentation":"Get game directory"},{"declaration":"void CrosshairAngle(const edict_t@ pEdict, float flPitch, float flYaw)","documentation":"Sets the angles of the given player's crosshairs to the given settings. Set both to 0 to disable. May not have any effect in SC."},{"declaration":"float Time()","documentation":"Get time"},{"declaration":"void SetView(const edict_t@ pEdict, const edict_t@ pViewEntity)","documentation":"Set view"},{"declaration":"void GetAttachment(const edict_t@ pEdict, int, Vector& out vecOrigin, Vector& out vecAngles)","documentation":"get attachment position"},{"declaration":"int Cmd_Argc()","documentation":"Get commands count"},{"declaration":"string Cmd_Argv(int iIndex)","documentation":"Get command argument by index"},{"declaration":"string Cmd_Args()","documentation":"get command arguments"},{"declaration":"void ServerPrint(const string& in szMessage)","documentation":"Server print"},{"declaration":"void ClientPrintf(CBasePlayer@ pPlayer, PRINT_TYPE printType, const string& in szMessage)","documentation":"Client print"},{"declaration":"void GetBonePosition(const edict_t@ pEdict, int iBone, Vector& out vecOrigin, Vector& out vecAngles)","documentation":"Get bone position"},{"declaration":"void AnimationAutomove(const edict_t@ pEdict, float flTime)","documentation":"Animation auto move"},{"declaration":"edict_t@ FindEntityByVars(entvars_t@ pVars)","documentation":"Find entity by variables"},{"declaration":"edict_t@ PEntityOfEntIndex(int iIndex)","documentation":"Get entity by entity index"},{"declaration":"int IndexOfEdict(const edict_t@ pEdict)","documentation":"Get index of edict"},{"declaration":"entvars_t@ GetVarsOfEnt(edict_t@ pEdict)","documentation":"Gets entity variables of entity"},{"declaration":"void CVarSetString(const string& in szCvar, const string& in szValue)","documentation":"Set cvar string value"},{"declaration":"void CVarSetFloat(const string& in szCvar, float flValue)","documentation":"Set cvar float value"},{"declaration":"string CVarGetString(const string& in szCvar)","documentation":"Get cvar string value"},{"declaration":"float CVarGetFloat(const string& in szCvar)","documentation":"Get cvar float value"},{"declaration":"CONTENTS PointContents(const Vector& in vecPoint)","documentation":"Check if point is in contents"},{"declaration":"int DecalIndex(const string& in szName)","documentation":"Get decal index"},{"declaration":"void LightStyle(int iStyle, const string& in szVal)","documentation":"Set a light style"},{"declaration":"void ParticleEffect(const Vector& in vecOrigin, const Vector& in vecDir, float flColor, float flCount)","documentation":"Emit a particle effect"},{"declaration":"void ServerExecute()","documentation":"Executes all pending server commands. Plugins only."},{"declaration":"void ServerCommand(const string& in szCommand)","documentation":"Issues a command to the server. Plugins only."},{"declaration":"void GetAimVector(edict_t@ pEntity, float flSpeed, Vector& out vecReturn)","documentation":"Get aim vector for entity"},{"declaration":"int WalkMove(edict_t@ pEntity, float flYaw, float flDist, int iMove)","documentation":"Make entity walk.<br/>See WALKMOVE enum"},{"declaration":"int DropToFloor(edict_t@ pEntity)","documentation":"Drop entity to floor"},{"declaration":"int EntIsOnFloor(edict_t@ pEntity)","documentation":"Returns whether entity is on the floor"},{"declaration":"void MakeStatic(edict_t@ pEntity)","documentation":"Make entity static. This moves the entity to the client.Its current visual state is copied over, and the entity is removed on the server side.Only valid while the level is loading."},{"declaration":"void AngleVectors(const Vector& in vecIn, Vector& out vecForward, Vector& out vecRight, Vector& out vecUp)","documentation":"Angle vectors"},{"declaration":"void MakeVectors(const Vector& in vec)","documentation":"Make vectors. The results are stored in g_Engine::v_forward, v_right, and v_up."},{"declaration":"edict_t@ EntitiesInPVS(edict_t@ pStartEntity)","documentation":"Find entities in Potentially Visible Set. Edict::vars::chain is used for this list, and is temporary."},{"declaration":"edict_t@ FindClientInPVS(edict_t@ pStartEntity)","documentation":"Find client in Potentially Visible Set"},{"declaration":"int GetEntityIllum(edict_t@ pEntity)","documentation":"Get entity illumination. This is a weighted value between 0 and 255, inclusive."},{"declaration":"void ChangePitch(edict_t@ pEntity)","documentation":"Change pitch. This updates entvars_t::angles[ 0 ] to approach entvars_t::idealpitch, at entvars_t::pitch_speed degrees speed."},{"declaration":"void ChangeYaw(edict_t@ pEntity)","documentation":"Change yaw. This updates entvars_t::angles[ 1 ] to approach entvars_t::ideal_yaw, at entvars_t::yaw_speed degrees speed."},{"declaration":"void MoveToOrigin(edict_t@ pEntity, const Vector& in vecGoal, float flDist, int iMoveType)","documentation":"Move entity to origin"},{"declaration":"void VecToAngles(const Vector& in vec, Vector& out angles)","documentation":"Vector to angles"},{"declaration":"float VecToYaw(const Vector& in vec)","documentation":"Vector to yaw"},{"declaration":"void ChangeLevel(const string& in szLevelName)","documentation":"Changes the current level to the one specified"},{"declaration":"int ModelFrames(int iModelIndex)","documentation":"gets the number of frames in a model"},{"declaration":"int ModelIndex(const string& in szModelName)","documentation":"Gets the model index of a model"}],"properties":[],"className":"CEngineFuncs","documentation":"Engine functions","namespace":""},{"flags":1,"methods":[{"declaration":"void RemoveValue(const string& in szKey)","documentation":"Removes a key value. If this is a physics key buffer, this will set the key to an empty string instead."},{"declaration":"void SetValue(const string& in szKey, const string& in szValue) const","documentation":"Sets a key value."},{"declaration":"string GetValue(const string& in szKey) const","documentation":"Gets a key value"},{"declaration":"edict_t@ GetClient() const","documentation":"Gets the client that this buffer belongs to."}],"properties":[],"className":"KeyValueBuffer","documentation":"Buffer containing keyvalue pairs","namespace":""},{"flags":262145,"methods":[{"declaration":"string GetString()","documentation":"Gets the value of the cvar as a string."},{"declaration":"string GetName()","documentation":"Gets the name of the cvar."}],"properties":[{"namespace":"","declaration":"const float value","documentation":"The value of this cvar as a float."},{"namespace":"","declaration":"const int flags","documentation":"The flags of this cvar."}],"className":"Cvar","documentation":"Cvar structure","namespace":""},{"flags":5890,"methods":[{"declaration":"TraceResult& opAssign(const TraceResult& in tr)","documentation":"Assignment operator"},{"declaration":"void DestructTraceResult()","documentation":"Destructor."},{"declaration":"void TraceResult(const TraceResult& in tr)","documentation":"Constructor."},{"declaration":"void TraceResult()","documentation":"Constructor."}],"properties":[{"namespace":"","declaration":"int iHitgroup","documentation":"Hit group."},{"namespace":"","declaration":"edict_t@ pHit","documentation":"Hit entity"},{"namespace":"","declaration":"Vector vecPlaneNormal","documentation":"Plane normal"},{"namespace":"","declaration":"float flPlaneDist","documentation":"Plane distance."},{"namespace":"","declaration":"Vector vecEndPos","documentation":"End position."},{"namespace":"","declaration":"float flFraction","documentation":"Fraction."},{"namespace":"","declaration":"int fInWater","documentation":"Flag telling whether the trace ended in water"},{"namespace":"","declaration":"int fInOpen","documentation":"Flag telling whether the trace ended in an open area."},{"namespace":"","declaration":"int fStartSolid","documentation":"Flag telling whether the trace started in a solid area."},{"namespace":"","declaration":"int fAllSolid","documentation":"Flag telling whether the trace occured in an all solid area."}],"className":"TraceResult","documentation":"Trace result structure","namespace":""},{"flags":262145,"methods":[{"declaration":"void RemoveDeadBody()","documentation":"Removes the player's dead body, if it exists."},{"declaration":"void SetObserverModeControlEnabled(bool fEnabled)","documentation":"Sets whether this player can control the observer mode."},{"declaration":"bool CanControlObserverMode() const","documentation":"Returns whether this player can control the observer mode."},{"declaration":"bool HasCorpse()","documentation":"Returns whether this player has a corpse."},{"declaration":"CBaseEntity@ FindObserverStartPoint()","documentation":"Find a point to start a player at for observer."},{"declaration":"void SetMode(ObserverMode iMode)","documentation":"Sets the observer mode."},{"declaration":"void HandleButtons()","documentation":"Handles button input."},{"declaration":"void FindNextPlayer(bool fReverse)","documentation":"Find the next player to observe."},{"declaration":"void StopObserver(bool fRespawn)","documentation":"Stops observer mode."},{"declaration":"void StartObserver(const Vector& in vecPosition, const Vector& in vecViewAngle, bool fCreateBody = true)","documentation":"Starts observer mode."},{"declaration":"bool IsObserver() const","documentation":"Returns whether this player is an observer."},{"declaration":"bool CanUseObserver()","documentation":"Returns whether this player can use observer mode."},{"declaration":"void SetObserverTarget(CBaseEntity@ pEntity)","documentation":"Sets the observer target."},{"declaration":"void ResetObserverTarget()","documentation":"Resets the observer target and finds the next suitable candidate."},{"declaration":"CBaseEntity@ GetObserverTarget()","documentation":"Gets the current observer target, if any."}],"properties":[],"className":"Observer","documentation":"Observer mode management class.","namespace":""},{"flags":262145,"methods":[{"declaration":"string options() const","documentation":"Options. Usually a sound name."}],"properties":[{"namespace":"","declaration":"int event","documentation":"Event type.<br/>See MonsterEventType enum"}],"className":"MonsterEvent","documentation":"Monster event type","namespace":""},{"flags":262145,"methods":[],"properties":[{"namespace":"","declaration":"int iType","documentation":"Type(s) of this waypoint."},{"namespace":"","declaration":"float flSavedMoveWait","documentation":"How long to wait on this waypoint."},{"namespace":"","declaration":"CBaseEntity@ pDoor","documentation":"Handle to a door to use."},{"namespace":"","declaration":"Vector vecLadderVelocity","documentation":"Saved ladder velocity."},{"namespace":"","declaration":"Vector vecJumpVelocity","documentation":"Saved jump velocity."},{"namespace":"","declaration":"Vector vecLocation","documentation":"Location of this waypoint."}],"className":"Waypoint","documentation":"Waypoint for monsters to follow.","namespace":""},{"flags":262145,"methods":[{"declaration":"void AddTask(const ScriptTask& in task)","documentation":"Adds a task to the list"},{"declaration":"Schedule@ opImplCast()","documentation":"Cast to Schedule"},{"declaration":"ScriptSchedule@ ScriptSchedule(int iInterruptMask, int iSoundMask, const string& in szName)","documentation":"Constructor"},{"declaration":"string szName() const","documentation":"Gets the name of this schedule."},{"declaration":"Task@ GetTask(int iIndex) const","documentation":"Gets a task in this schedule.<br/>Must be between 0 and cTasks."}],"properties":[{"namespace":"","declaration":"int iSoundMask","documentation":"A more specific mask that indicates which TYPES of sounds will interrupt the schedule in the event that the schedule is broken by COND_HEAR_SOUND."},{"namespace":"","declaration":"int iInterruptMask","documentation":"A bit mask of conditions that can interrupt this schedule."},{"namespace":"","declaration":"int cTasks","documentation":"Number of tasks in this schedule."}],"className":"ScriptSchedule","documentation":"Script schedule class","namespace":""},{"flags":1794,"methods":[{"declaration":"void DestructScriptTask()","documentation":"Destructor"},{"declaration":"void ScriptTask(int iTask, float flData = 0.0f)","documentation":"Constructor"},{"declaration":"void ScriptTask()","documentation":"Constructor"}],"properties":[{"namespace":"","declaration":"float flData","documentation":"Task data"},{"namespace":"","declaration":"int iTask","documentation":"Task to execute.<br/>Can be monster-specific."}],"className":"ScriptTask","documentation":"Script task class","namespace":""},{"flags":262145,"methods":[{"declaration":"string szName() const","documentation":"Gets the name of this schedule."},{"declaration":"Task@ GetTask(int iIndex) const","documentation":"Gets a task in this schedule.<br/>Must be between 0 and cTasks."}],"properties":[{"namespace":"","declaration":"int iSoundMask","documentation":"A more specific mask that indicates which TYPES of sounds will interrupt the schedule in the event that the schedule is broken by COND_HEAR_SOUND."},{"namespace":"","declaration":"int iInterruptMask","documentation":"A bit mask of conditions that can interrupt this schedule."},{"namespace":"","declaration":"int cTasks","documentation":"Number of tasks in this schedule."}],"className":"Schedule","documentation":"Schedule for monsters to follow.","namespace":""},{"flags":262145,"methods":[],"properties":[{"namespace":"","declaration":"float flData","documentation":"Task data"},{"namespace":"","declaration":"int iTask","documentation":"Task to execute.<br/>Can be monster-specific."}],"className":"Task","documentation":"Task for monsters to execute.","namespace":""},{"flags":262145,"methods":[{"declaration":"string GetName(Activity activity) const","documentation":"Gets the name of the given activity"}],"properties":[],"className":"CActivityMap","documentation":"Activity map","namespace":""},{"flags":262145,"methods":[{"declaration":"CustomKeyvalue GetKeyvalue(const string& in szKey) const","documentation":"Gets the keyvalue with the given name. Check if it exists by calling Exists."},{"declaration":"bool HasKeyvalue(const string& in szKey) const","documentation":"Returns whether the keyvalue with the given name exists."},{"declaration":"void InitializeKeyvalueWithDefault(const string& in szKey)","documentation":"Initializes a keyvalue with the default value for its type."},{"declaration":"bool SetKeyvalue(const string& in szKey, int iValue)","documentation":"Sets a custom keyvalue to the given integer value.</br>Returns true if the key existed and was overwritten."},{"declaration":"bool SetKeyvalue(const string& in szKey, float flValue)","documentation":"Sets a custom keyvalue to the given float value.</br>Returns true if the key existed and was overwritten."},{"declaration":"bool SetKeyvalue(const string& in szKey, const Vector& in vecValue)","documentation":"Sets a custom keyvalue to the given vector value.</br>Returns true if the key existed and was overwritten."},{"declaration":"bool SetKeyvalue(const string& in szKey, const string& in szValue)","documentation":"Sets a custom keyvalue to the given string value.</br>Returns true if the key existed and was overwritten."}],"properties":[],"className":"CustomKeyvalues","documentation":"Custom keyvalues. Do not keep handles to instances of these objects.","namespace":""},{"flags":5890,"methods":[{"declaration":"int GetInteger() const","documentation":"Gets the value as an integer."},{"declaration":"float GetFloat() const","documentation":"Gets the value as a float."},{"declaration":"Vector GetVector() const","documentation":"Gets the value as a vector."},{"declaration":"string GetString() const","documentation":"Gets the value as a string."},{"declaration":"Entvartype GetType() const","documentation":"Gets the type of the keyvalue.</br>Returns VAR_INVALID if this value does not exist."},{"declaration":"bool Exists() const","documentation":"Returns whether the value exists."},{"declaration":"void DestructCustomKeyvalue()","documentation":"Destructor"},{"declaration":"void CustomKeyvalue(const CustomKeyvalue& in other)","documentation":"Constructor"},{"declaration":"void CustomKeyvalue()","documentation":"Constructor"}],"properties":[],"className":"CustomKeyvalue","documentation":"Custom keyvalue. Only use this as a local variable, do not store them!","namespace":""},{"flags":2,"methods":[{"declaration":"int GetSerialNumber() const","documentation":"CBaseEntity serial number. Used to determine if the entity is still valid."},{"declaration":"EHandle& opAssign(const EHandle& in other)","documentation":"Makes this handle refer to the same entity as the given handle."},{"declaration":"CBaseEntity@ opAssign(CBaseEntity@ pEntity)","documentation":"Assigns the given entity to this handle."},{"declaration":"CBaseEntity@ opImplCast() const","documentation":"Gets the Entity this handle refers to.<br/>Returns null if invalid."},{"declaration":"CBaseEntity@ GetEntity() const","documentation":"Gets the Entity this handle refers to.<br/>Returns null if invalid."},{"declaration":"bool opImplConv() const","documentation":"Returns whether this handle is valid."},{"declaration":"bool IsValid() const","documentation":"Returns whether this handle is valid."},{"declaration":"void DestructEHandle()","documentation":"Destructor."},{"declaration":"void EHandle(CBaseEntity@ pEntity)","documentation":"Constructs this handle with a reference to the given entity."},{"declaration":"void EHandle(const EHandle& in other)","documentation":"Copy constructs this handle."},{"declaration":"void EHandle()","documentation":"Default constructs this handle."}],"properties":[],"className":"EHandle","documentation":"Safe way to point to CBaseEntities who may die between frames.","namespace":""},{"flags":262145,"methods":[{"declaration":"void LimitVelocity()","documentation":"Limits the velocity of the gib"},{"declaration":"void Spawn(const string& in szModelName)","documentation":"Spawns the gib with the given model. Note: this sets several of CGib's variables. Set variables after calling this."},{"declaration":"void ClearUserData()","documentation":"Clears the user data on this entity. WARNING: clears all data.<br/>Only map scripts can use this."},{"declaration":"dictionaryValue& GetUserData(const string& in szKey)","documentation":"Gets the user data stored under the specified key on this entity.<br/>Do not keep references to this data, the object might be removed from this entity.<br/>Only map scripts can use this."},{"declaration":"dictionary@ GetUserData()","documentation":"Gets the user data on this entity. Do not keep references to this data, the object might be removed from this entity.<br/>Only map scripts can use this."},{"declaration":"void EndRevive(float flTimeUntilRevive)","documentation":"Called when this entity should be revived. flTimeUntilRevive is the time until the revival should start."},{"declaration":"void BeginRevive(float flTimeUntilRevive)","documentation":"Prepares this entity for revival. flTimeUntilRevive is the time until the revive action completes."},{"declaration":"bool IsRevivable()","documentation":"Returns whether this entity is revivable at this time."},{"declaration":"void OnDestroy()","documentation":"Entity destructor."},{"declaration":"void OnCreate()","documentation":"Entity constructor."},{"declaration":"void GetDamagePoints(entvars_t@ pevAttacker, entvars_t@ pevInflictor, float flDamage)","documentation":"Adds damage points to the inflicting entity."},{"declaration":"float GetPointsForDamage(float flDamage)","documentation":"Returns the points received for damage done."},{"declaration":"bool IsFacing(entvars_t@ pevTest, float flDotProduct = VIEW_FIELD_ULTRA_NARROW)","documentation":"Returns whether this entity is facing the given entity, within the given view field."},{"declaration":"bool FVisible(const Vector& in vecOrigin)","documentation":"Returns whether this entity is visible from the given origin."},{"declaration":"bool FVisible(CBaseEntity@ pEntity, bool fIgnoreGlass)","documentation":"Returns whether this entity is visible to the given entity."},{"declaration":"int Illumination()","documentation":"Returns this entity's illumination."},{"declaration":"Vector BodyTarget(const Vector& in posSrc)","documentation":"Returns this entity's body target for shooting."},{"declaration":"Vector EarPosition()","documentation":"Returns this entity's ear position."},{"declaration":"Vector EyePosition()","documentation":"Returns this entity's eye position."},{"declaration":"Vector Center()","documentation":"Returns this entity's center."},{"declaration":"bool FBecomeProne()","documentation":"Makes this entity become prone."},{"declaration":"CBaseEntity@ Respawn()","documentation":"Respawns this entity."},{"declaration":"void UpdateOnRemove()","documentation":"Updates this entity when removed."},{"declaration":"void Blocked(CBaseEntity@ pOther)","documentation":"Triggers this entity's blocked function."},{"declaration":"void Use(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f)","documentation":"Trigger's this entity's use function."},{"declaration":"void Touch(CBaseEntity@ pOther)","documentation":"Triggers this entity's touch function."},{"declaration":"void Think()","documentation":"Makes this entity think. Do not call directly."},{"declaration":"CBaseEntity@ GetNextTarget()","documentation":"Gets the next target to trigger."},{"declaration":"bool CriticalRemove()","documentation":"Removes this entity in critical situations."},{"declaration":"bool IsMachine()","documentation":"Returns whether this is a machine."},{"declaration":"bool IsPointEnt()","documentation":"Returns whether this is a point entity."},{"declaration":"bool IsNetClient()","documentation":"Returns whether this is a net client."},{"declaration":"bool IsPlayer()","documentation":"Returns whether this entity is a player."},{"declaration":"bool IsMonster()","documentation":"Returns whether this entity is a monster."},{"declaration":"bool IsInWorld()","documentation":"Returns whether this entity is in the world."},{"declaration":"bool ReflectGauss()","documentation":"Returns whether this entity reflects gauss shots."},{"declaration":"bool IsBSPModel()","documentation":"Returns whether this entity is a BSP model."},{"declaration":"bool IsAlive()","documentation":"Returns whether this entity is alive."},{"declaration":"bool IsSneaking()","documentation":"Returns whether this entity is sneaking."},{"declaration":"bool OnControls(entvars_t@ pev)","documentation":"Reacts to controls set on the pev."},{"declaration":"void StopSneaking()","documentation":"Stops sneaking."},{"declaration":"void StartSneaking()","documentation":"Starts sneaking."},{"declaration":"void SetToggleState(int state)","documentation":"Sets this entity's toggle state."},{"declaration":"int DamageDecal(int bitsDamageType)","documentation":"Returns the damage decal<br/>See decal_e."},{"declaration":"void OverrideReset()","documentation":"Resets this entity."},{"declaration":"bool IsMoving()","documentation":"Returns whether this entity is moving."},{"declaration":"float GetDelay()","documentation":"Gets this entity's trigger delay."},{"declaration":"bool RemovePlayerItem(CBasePlayerItem@ pItem)","documentation":"Removes the given player item to this entity."},{"declaration":"AddPlayerItemResult AddPlayerItem(CBasePlayerItem@ pItem)","documentation":"Adds the given player item to this entity."},{"declaration":"void AddPointsToTeam(int score, const bool bAllowNegativeScore)","documentation":"Adds points to this entity's team."},{"declaration":"void AddPoints(int score, const bool bAllowNegativeScore)","documentation":"Adds points to this entity."},{"declaration":"int GetToggleState()","documentation":"Gets the toggle state.<br/>See the TOGGLE_STATE enum."},{"declaration":"bool SetupModel()","documentation":"Sets up the model."},{"declaration":"int entindex()","documentation":"Returns this entity's index."},{"declaration":"edict_t@ edict()","documentation":"Returns this entity's edict."},{"declaration":"bool IsLockedByMaster()","documentation":"Returns whether this entity is locked by its master."},{"declaration":"bool IsDormant()","documentation":"Returns whether this entity is dormant."},{"declaration":"void MakeDormant()","documentation":"Makes this entity dormant."},{"declaration":"bool Intersects(CBaseEntity@ pOther)","documentation":"Returns whether this entity intersects with the given entity."},{"declaration":"void SUB_UseTargets(CBaseEntity@ pActivator, USE_TYPE useType, float flValue)","documentation":"Calls use on targets."},{"declaration":"void FireBullets(uint cShots, Vector vecSrc, Vector vecDirShooting, Vector vecSpread,float flDistance, Bullet iBulletType, int iTracerFreq = 4, int iDamage = 0, entvars_t@ pevAttacker = null, FireBulletsDrawMode fDraw = FBDM_DRAW)","documentation":"Fires bullets. Must call CMath::MakeAimVectors with an angle vector first."},{"declaration":"bool ShouldToggle(USE_TYPE useType, const bool currentState)","documentation":"Returns whether this entity should toggle."},{"declaration":"void SUB_CallUseToggle()","documentation":"Think function. Calls use toggle on this entity."},{"declaration":"void SUB_FadeOut()","documentation":"Think function. Fades this entity."},{"declaration":"void SUB_StartFadeOut()","documentation":"Think function. Starts fading this entity."},{"declaration":"void SUB_DoNothing()","documentation":"Think function. Explicitly does nothing."},{"declaration":"void SUB_Remove()","documentation":"Think function. Delay-removes this entity."},{"declaration":"bool BlockedByEntity(CBaseEntity@ pOther, float flDamage)","documentation":"Returns true if you should be blocked by the entity, false otherwise. Also deals blocking damage to the entity, if applicable."},{"declaration":"CustomKeyvalues@ GetCustomKeyvalues()","documentation":"Gets this entity's custom keyvalues."},{"declaration":"CBaseMonster@ MyMonsterPointer()","documentation":"Returns this entity as its monster entity, if it is a monster."},{"declaration":"bool IsTriggered(CBaseEntity@ pActivator)","documentation":"Returns whether this entity is triggered by the given entity."},{"declaration":"int BloodColor()","documentation":"Returns the blood color. See the BLOOD_COLOR enum."},{"declaration":"void Killed(entvars_t@pevAtttacker, int iGibbed)","documentation":"Tells this entity it's been killed. See the GIB enum for possible values."},{"declaration":"bool TakeArmor(float flArmor, int bitsDamageType, int armor_cap = 0)","documentation":"Takes armor from this entity. Note: flArmor is added to entity armor. Use negative values to subtract.If armor_cap is non-zero, won't add more than armor_cap. Returns 1 if it took damage, 0 otherwise."},{"declaration":"bool TakeHealth(float flHealth, int bitsDamageType, int health_cap = 0)","documentation":"Takes health from this entity. Note: flHealth is added to entity health. Use negative values to subtract.If health_cap is non-zero, won't add more than health_cap. Returns true if it took damage, false otherwise."},{"declaration":"int TakeDamage(entvars_t@ pevInflictor, entvars_t@ pevAttacker, float flDamage, int bitsDamageType)","documentation":"Causes this entity to take damage. Returns 1 if it took damage, 0 otherwise."},{"declaration":"int Classify()","documentation":"Gets this entity's classification."},{"declaration":"int IRelationshipByClass(CLASS iClass)","documentation":"Gets the relationship between this entity and the given entity classification. See the RELATIONSHIP enum."},{"declaration":"int IRelationship(CBaseEntity@ other)","documentation":"Gets the relationship between this entity and the given entity. See the RELATIONSHIP enum."},{"declaration":"void ClearClassification()","documentation":"Clears this entity's classification override."},{"declaration":"void SetClassificationFromEntity(CBaseEntity@ pEntity)","documentation":"Sets this entity's classification override to the classification override set on the given entity. Can override the entity's player ally setting."},{"declaration":"void SetClassification(int cl)","documentation":"Sets this entity's classification override. Can override the entity's player ally setting."},{"declaration":"int GetClassification(int cl)","documentation":"Gets this entity's classification. Returns the given value if none is set. See the CLASSIFICATION enum."},{"declaration":"void SetObjectCollisionBox()","documentation":"Sets up the object collision box."},{"declaration":"int ObjectCaps()","documentation":"Gets this entity's objects caps. See the FCAP enum."},{"declaration":"void Precache()","documentation":"Precaches the entity. Do not call directly."},{"declaration":"bool opEquals(CBaseEntity@ pOther)","documentation":"Compares 2 entities for equality."},{"declaration":"void SetPlayerAllyDirect(bool fState)","documentation":"Sets this entity's player ally status.</br>Use this only if you need the setting to be exactly what you give it (e.g. when copying from another monster)"},{"declaration":"void SetPlayerAlly(bool fState)","documentation":"Sets this entity's player ally status."},{"declaration":"bool IsPlayerAlly() const","documentation":"Returns whether this entity is allied to players."},{"declaration":"int FindMonstersInWorld(array<CBaseEntity@>@ pArray, int flagMask)","documentation":"Finds monsters in the world"},{"declaration":"string SOUNDREPLACEMENT_Find(const string& in szFilename)","documentation":"Find sound replacement for the given file."},{"declaration":"bool FVisibleFromPos(const Vector& in vecTarget, const Vector& in vecStart)","documentation":"Returns whether this entity is visible from the given position."},{"declaration":"string GetTargetname() const","documentation":"Returns this entity's target name."},{"declaration":"string GetClassname() const","documentation":"Returns this entity's class name."},{"declaration":"string TeamID()","documentation":"Returns this entity's team ID."},{"declaration":"bool HasTarget(const string& in szTarget)","documentation":"Returns whether this entity has the given target."},{"declaration":"int GiveAmmo(int iAmount, const string& in szName, int iMax, const bool fFromWeapon = true)","documentation":"Gives ammo to this entity."},{"declaration":"void TraceBleed(float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)","documentation":"Traces entity bleed event."},{"declaration":"void TraceAttack(entvars_t@ pevAttacker, float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)","documentation":"Traces an attack by the given entity to this entity."},{"declaration":"bool KeyValue(const string& in szKeyName, const string& in szValue)","documentation":"Sets keyvalue data on this entity"},{"declaration":"void SetOrigin(const Vector& in vecOrigin)","documentation":"Sets this entity's (absolute) origin"},{"declaration":"const Vector& GetOrigin() const","documentation":"Gets the entity's (absolute) origin."},{"declaration":"CBaseEntity@ opImplCast()","documentation":"Implicitly casts to base type."}],"properties":[{"namespace":"","declaration":"float m_lifeTime","documentation":"Lifetime of this gib, in seconds"},{"namespace":"","declaration":"int m_material","documentation":"Gib material type. One of the Materials enum values should be used here."},{"namespace":"","declaration":"int m_cBloodDecals","documentation":"Maximum number of blood decals this gib can spray."},{"namespace":"","declaration":"int m_bloodColor","documentation":"The color of the blood that is sprayed onto walls when the gib touches it."},{"namespace":"","declaration":"Vector m_vecOriginalRenderColor","documentation":"Original render color."},{"namespace":"","declaration":"float m_flOriginalRenderAmount","documentation":"Original render amount."},{"namespace":"","declaration":"int m_iOriginalRenderFX","documentation":"Original render FX."},{"namespace":"","declaration":"int m_iOriginalRenderMode","documentation":"Original render model."},{"namespace":"","declaration":"string_t classnameInFilterType","documentation":"Class name in filter type."},{"namespace":"","declaration":"string_t targetnameInFilterType","documentation":"Target name in filter type."},{"namespace":"","declaration":"string_t classnameOutFilterType","documentation":"Class name out filter type."},{"namespace":"","declaration":"string_t targetnameOutFilterType","documentation":"Target name out filter type."},{"namespace":"","declaration":"Vector m_vecLastOrigin","documentation":"Last origin vector"},{"namespace":"","declaration":"bool m_fCustomModel","documentation":"Whether a custom model is used."},{"namespace":"","declaration":"bool m_fCanFadeStart","documentation":"Whether fading can start."},{"namespace":"","declaration":"float m_flMaximumFadeWaitB","documentation":"Maximum fade wait time B."},{"namespace":"","declaration":"float m_flMaximumFadeWait","documentation":"Maximum fade wait time."},{"namespace":"","declaration":"int m_iClassSelection","documentation":"The overridden classification."},{"namespace":"","declaration":"bool m_fOverrideClass","documentation":"Whether this entity overrides the classification."},{"namespace":"","declaration":"entvars_t@ pev","documentation":"Entity variables"}],"className":"CGib","documentation":"Gib class","namespace":""},{"flags":262145,"methods":[{"declaration":"bool DoorChangeDirection()","documentation":"If the door is moving, changes the movement direction. Returns true if the door was moving."},{"declaration":"void DoorGoDown()","documentation":"Makes the door go down."},{"declaration":"void DoorGoUp()","documentation":"Makes the door go up."},{"declaration":"void DoorTouch(CBaseEntity@ pOther)","documentation":"Door touch function."},{"declaration":"InventoryRules@ get_m_pInventoryRules() const","documentation":"The inventory rules."},{"declaration":"bool IsToggleLockedByMaster()","documentation":"Returns whether this entity is locked by its master.<br/>Separate from IsLockedByMaster due to limitations."},{"declaration":"void AngularMove(Vector vecDestAngle, float flSpeed)","documentation":"Performs angular movement."},{"declaration":"void LinearMove(Vector vecDest, float flSpeed)","documentation":"Performs linear movement."},{"declaration":"int GetSequenceActivityName(int iSequence)","documentation":"Sets the sequence box."},{"declaration":"void SetSequenceBox()","documentation":"Sets the sequence box."},{"declaration":"int GetAttachmentCount()","documentation":"Gets the number of attachments that the current model has."},{"declaration":"bool ExtractBbox(int iSequence, Vector& out mins, Vector& out maxs)","documentation":"Extracts the bounding box of the current model."},{"declaration":"int GetBodygroup(int iGroup)","documentation":"Gets the value of the given body group."},{"declaration":"void SetBodygroup(int iGroup, int iValue)","documentation":"Sets the given body group to the given value."},{"declaration":"void GetAttachment(int iAttachment, Vector& out origin, Vector& out angles)","documentation":"Gets the attachment position."},{"declaration":"int FindTransition(int iEndingSequence, int iGoalSequence)","documentation":"Find the transition between 2 sequences."},{"declaration":"int FindTransition(int iEndingSequence, int iGoalSequence, int& out iDir)","documentation":"Find the transition between 2 sequences."},{"declaration":"void GetAutomovement(Vector& out origin, Vector& out angles, float flInterval = 0.1f)","documentation":"Gets automatic movement."},{"declaration":"void GetBonePosition(int iBone, Vector& out origin, Vector& out angles)","documentation":"Gets the position of the given bone."},{"declaration":"float SetBlending(int iBlender, float flValue)","documentation":"Sets the given blending controller to the given value."},{"declaration":"void InitBoneControllers()","documentation":"Initializes bone controllers."},{"declaration":"float SetBoneController(int iController, float flValue)","documentation":"Sets the specified bone controller to the given value."},{"declaration":"void DispatchAnimEvents(float flFutureInterval = 0.1f)","documentation":"Handle events that have happend since last time called up until X seconds into the future."},{"declaration":"void ResetGaitSequenceInfo()","documentation":"Resets gait sequence info."},{"declaration":"void ResetSequenceInfo()","documentation":"Resets sequence info."},{"declaration":"int LookupSequence(const string& in szLabel)","documentation":"Returns the index of the given sequence, or -1 if no such sequence exists."},{"declaration":"int LookupActivityHeaviest(int iActivity)","documentation":"Returns the index of the given activity that has the heaviest weight, or -1 if no such activity exists."},{"declaration":"int LookupActivity(int iActivity)","documentation":"Returns the index of the given activity, or -1 if no such activity exists."},{"declaration":"int GetSequenceFlags()","documentation":"Get sequence flags."},{"declaration":"float StudioFrameAdvance(float flInterval = 0.0f)","documentation":"Accumulate animation frame time from last time called until now."},{"declaration":"void DelayThink()","documentation":"Think function. Used internally."},{"declaration":"void SUB_UseTargets(CBaseEntity@ pActivator, USE_TYPE useType, float flValue)","documentation":"Causes this entity to trigger its targets with an optional delay."},{"declaration":"void ClearUserData()","documentation":"Clears the user data on this entity. WARNING: clears all data.<br/>Only map scripts can use this."},{"declaration":"dictionaryValue& GetUserData(const string& in szKey)","documentation":"Gets the user data stored under the specified key on this entity.<br/>Do not keep references to this data, the object might be removed from this entity.<br/>Only map scripts can use this."},{"declaration":"dictionary@ GetUserData()","documentation":"Gets the user data on this entity. Do not keep references to this data, the object might be removed from this entity.<br/>Only map scripts can use this."},{"declaration":"void EndRevive(float flTimeUntilRevive)","documentation":"Called when this entity should be revived. flTimeUntilRevive is the time until the revival should start."},{"declaration":"void BeginRevive(float flTimeUntilRevive)","documentation":"Prepares this entity for revival. flTimeUntilRevive is the time until the revive action completes."},{"declaration":"bool IsRevivable()","documentation":"Returns whether this entity is revivable at this time."},{"declaration":"void OnDestroy()","documentation":"Entity destructor."},{"declaration":"void OnCreate()","documentation":"Entity constructor."},{"declaration":"void GetDamagePoints(entvars_t@ pevAttacker, entvars_t@ pevInflictor, float flDamage)","documentation":"Adds damage points to the inflicting entity."},{"declaration":"float GetPointsForDamage(float flDamage)","documentation":"Returns the points received for damage done."},{"declaration":"bool IsFacing(entvars_t@ pevTest, float flDotProduct = VIEW_FIELD_ULTRA_NARROW)","documentation":"Returns whether this entity is facing the given entity, within the given view field."},{"declaration":"bool FVisible(const Vector& in vecOrigin)","documentation":"Returns whether this entity is visible from the given origin."},{"declaration":"bool FVisible(CBaseEntity@ pEntity, bool fIgnoreGlass)","documentation":"Returns whether this entity is visible to the given entity."},{"declaration":"int Illumination()","documentation":"Returns this entity's illumination."},{"declaration":"Vector BodyTarget(const Vector& in posSrc)","documentation":"Returns this entity's body target for shooting."},{"declaration":"Vector EarPosition()","documentation":"Returns this entity's ear position."},{"declaration":"Vector EyePosition()","documentation":"Returns this entity's eye position."},{"declaration":"Vector Center()","documentation":"Returns this entity's center."},{"declaration":"bool FBecomeProne()","documentation":"Makes this entity become prone."},{"declaration":"CBaseEntity@ Respawn()","documentation":"Respawns this entity."},{"declaration":"void UpdateOnRemove()","documentation":"Updates this entity when removed."},{"declaration":"void Blocked(CBaseEntity@ pOther)","documentation":"Triggers this entity's blocked function."},{"declaration":"void Use(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f)","documentation":"Trigger's this entity's use function."},{"declaration":"void Touch(CBaseEntity@ pOther)","documentation":"Triggers this entity's touch function."},{"declaration":"void Think()","documentation":"Makes this entity think. Do not call directly."},{"declaration":"CBaseEntity@ GetNextTarget()","documentation":"Gets the next target to trigger."},{"declaration":"bool CriticalRemove()","documentation":"Removes this entity in critical situations."},{"declaration":"bool IsMachine()","documentation":"Returns whether this is a machine."},{"declaration":"bool IsPointEnt()","documentation":"Returns whether this is a point entity."},{"declaration":"bool IsNetClient()","documentation":"Returns whether this is a net client."},{"declaration":"bool IsPlayer()","documentation":"Returns whether this entity is a player."},{"declaration":"bool IsMonster()","documentation":"Returns whether this entity is a monster."},{"declaration":"bool IsInWorld()","documentation":"Returns whether this entity is in the world."},{"declaration":"bool ReflectGauss()","documentation":"Returns whether this entity reflects gauss shots."},{"declaration":"bool IsBSPModel()","documentation":"Returns whether this entity is a BSP model."},{"declaration":"bool IsAlive()","documentation":"Returns whether this entity is alive."},{"declaration":"bool IsSneaking()","documentation":"Returns whether this entity is sneaking."},{"declaration":"bool OnControls(entvars_t@ pev)","documentation":"Reacts to controls set on the pev."},{"declaration":"void StopSneaking()","documentation":"Stops sneaking."},{"declaration":"void StartSneaking()","documentation":"Starts sneaking."},{"declaration":"void SetToggleState(int state)","documentation":"Sets this entity's toggle state."},{"declaration":"int DamageDecal(int bitsDamageType)","documentation":"Returns the damage decal<br/>See decal_e."},{"declaration":"void OverrideReset()","documentation":"Resets this entity."},{"declaration":"bool IsMoving()","documentation":"Returns whether this entity is moving."},{"declaration":"float GetDelay()","documentation":"Gets this entity's trigger delay."},{"declaration":"bool RemovePlayerItem(CBasePlayerItem@ pItem)","documentation":"Removes the given player item to this entity."},{"declaration":"AddPlayerItemResult AddPlayerItem(CBasePlayerItem@ pItem)","documentation":"Adds the given player item to this entity."},{"declaration":"void AddPointsToTeam(int score, const bool bAllowNegativeScore)","documentation":"Adds points to this entity's team."},{"declaration":"void AddPoints(int score, const bool bAllowNegativeScore)","documentation":"Adds points to this entity."},{"declaration":"int GetToggleState()","documentation":"Gets the toggle state.<br/>See the TOGGLE_STATE enum."},{"declaration":"bool SetupModel()","documentation":"Sets up the model."},{"declaration":"int entindex()","documentation":"Returns this entity's index."},{"declaration":"edict_t@ edict()","documentation":"Returns this entity's edict."},{"declaration":"bool IsLockedByMaster()","documentation":"Returns whether this entity is locked by its master."},{"declaration":"bool IsDormant()","documentation":"Returns whether this entity is dormant."},{"declaration":"void MakeDormant()","documentation":"Makes this entity dormant."},{"declaration":"bool Intersects(CBaseEntity@ pOther)","documentation":"Returns whether this entity intersects with the given entity."},{"declaration":"void FireBullets(uint cShots, Vector vecSrc, Vector vecDirShooting, Vector vecSpread,float flDistance, Bullet iBulletType, int iTracerFreq = 4, int iDamage = 0, entvars_t@ pevAttacker = null, FireBulletsDrawMode fDraw = FBDM_DRAW)","documentation":"Fires bullets. Must call CMath::MakeAimVectors with an angle vector first."},{"declaration":"bool ShouldToggle(USE_TYPE useType, const bool currentState)","documentation":"Returns whether this entity should toggle."},{"declaration":"void SUB_CallUseToggle()","documentation":"Think function. Calls use toggle on this entity."},{"declaration":"void SUB_FadeOut()","documentation":"Think function. Fades this entity."},{"declaration":"void SUB_StartFadeOut()","documentation":"Think function. Starts fading this entity."},{"declaration":"void SUB_DoNothing()","documentation":"Think function. Explicitly does nothing."},{"declaration":"void SUB_Remove()","documentation":"Think function. Delay-removes this entity."},{"declaration":"bool BlockedByEntity(CBaseEntity@ pOther, float flDamage)","documentation":"Returns true if you should be blocked by the entity, false otherwise. Also deals blocking damage to the entity, if applicable."},{"declaration":"CustomKeyvalues@ GetCustomKeyvalues()","documentation":"Gets this entity's custom keyvalues."},{"declaration":"CBaseMonster@ MyMonsterPointer()","documentation":"Returns this entity as its monster entity, if it is a monster."},{"declaration":"bool IsTriggered(CBaseEntity@ pActivator)","documentation":"Returns whether this entity is triggered by the given entity."},{"declaration":"int BloodColor()","documentation":"Returns the blood color. See the BLOOD_COLOR enum."},{"declaration":"void Killed(entvars_t@pevAtttacker, int iGibbed)","documentation":"Tells this entity it's been killed. See the GIB enum for possible values."},{"declaration":"bool TakeArmor(float flArmor, int bitsDamageType, int armor_cap = 0)","documentation":"Takes armor from this entity. Note: flArmor is added to entity armor. Use negative values to subtract.If armor_cap is non-zero, won't add more than armor_cap. Returns 1 if it took damage, 0 otherwise."},{"declaration":"bool TakeHealth(float flHealth, int bitsDamageType, int health_cap = 0)","documentation":"Takes health from this entity. Note: flHealth is added to entity health. Use negative values to subtract.If health_cap is non-zero, won't add more than health_cap. Returns true if it took damage, false otherwise."},{"declaration":"int TakeDamage(entvars_t@ pevInflictor, entvars_t@ pevAttacker, float flDamage, int bitsDamageType)","documentation":"Causes this entity to take damage. Returns 1 if it took damage, 0 otherwise."},{"declaration":"int Classify()","documentation":"Gets this entity's classification."},{"declaration":"int IRelationshipByClass(CLASS iClass)","documentation":"Gets the relationship between this entity and the given entity classification. See the RELATIONSHIP enum."},{"declaration":"int IRelationship(CBaseEntity@ other)","documentation":"Gets the relationship between this entity and the given entity. See the RELATIONSHIP enum."},{"declaration":"void ClearClassification()","documentation":"Clears this entity's classification override."},{"declaration":"void SetClassificationFromEntity(CBaseEntity@ pEntity)","documentation":"Sets this entity's classification override to the classification override set on the given entity. Can override the entity's player ally setting."},{"declaration":"void SetClassification(int cl)","documentation":"Sets this entity's classification override. Can override the entity's player ally setting."},{"declaration":"int GetClassification(int cl)","documentation":"Gets this entity's classification. Returns the given value if none is set. See the CLASSIFICATION enum."},{"declaration":"void SetObjectCollisionBox()","documentation":"Sets up the object collision box."},{"declaration":"int ObjectCaps()","documentation":"Gets this entity's objects caps. See the FCAP enum."},{"declaration":"void Precache()","documentation":"Precaches the entity. Do not call directly."},{"declaration":"bool opEquals(CBaseEntity@ pOther)","documentation":"Compares 2 entities for equality."},{"declaration":"void SetPlayerAllyDirect(bool fState)","documentation":"Sets this entity's player ally status.</br>Use this only if you need the setting to be exactly what you give it (e.g. when copying from another monster)"},{"declaration":"void SetPlayerAlly(bool fState)","documentation":"Sets this entity's player ally status."},{"declaration":"bool IsPlayerAlly() const","documentation":"Returns whether this entity is allied to players."},{"declaration":"int FindMonstersInWorld(array<CBaseEntity@>@ pArray, int flagMask)","documentation":"Finds monsters in the world"},{"declaration":"string SOUNDREPLACEMENT_Find(const string& in szFilename)","documentation":"Find sound replacement for the given file."},{"declaration":"bool FVisibleFromPos(const Vector& in vecTarget, const Vector& in vecStart)","documentation":"Returns whether this entity is visible from the given position."},{"declaration":"string GetTargetname() const","documentation":"Returns this entity's target name."},{"declaration":"string GetClassname() const","documentation":"Returns this entity's class name."},{"declaration":"string TeamID()","documentation":"Returns this entity's team ID."},{"declaration":"bool HasTarget(const string& in szTarget)","documentation":"Returns whether this entity has the given target."},{"declaration":"int GiveAmmo(int iAmount, const string& in szName, int iMax, const bool fFromWeapon = true)","documentation":"Gives ammo to this entity."},{"declaration":"void TraceBleed(float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)","documentation":"Traces entity bleed event."},{"declaration":"void TraceAttack(entvars_t@ pevAttacker, float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)","documentation":"Traces an attack by the given entity to this entity."},{"declaration":"bool KeyValue(const string& in szKeyName, const string& in szValue)","documentation":"Sets keyvalue data on this entity"},{"declaration":"void SetOrigin(const Vector& in vecOrigin)","documentation":"Sets this entity's (absolute) origin"},{"declaration":"const Vector& GetOrigin() const","documentation":"Gets the entity's (absolute) origin."},{"declaration":"CBaseEntity@ opImplCast()","documentation":"Implicitly casts to base type."},{"declaration":"CBaseDelay@ opImplCast()","documentation":"Implicitly casts to base type."},{"declaration":"CBaseAnimating@ opImplCast()","documentation":"Implicitly casts to base type."},{"declaration":"CBaseToggle@ opImplCast()","documentation":"Implicitly casts to base type."}],"properties":[{"namespace":"","declaration":"string_t m_sMaster","documentation":"This entity's master, if any."},{"namespace":"","declaration":"int m_bitsDamageInflict","documentation":"DMG_ damage type that the door or trigger does."},{"namespace":"","declaration":"Vector m_vecFinalAngle","documentation":"Final angle."},{"namespace":"","declaration":"Vector m_vecFinalDest","documentation":"Final destination."},{"namespace":"","declaration":"Vector m_vecAngle2","documentation":"Open angle."},{"namespace":"","declaration":"Vector m_vecAngle1","documentation":"Closed angle."},{"namespace":"","declaration":"Vector m_vecPosition2","documentation":"Open position."},{"namespace":"","declaration":"Vector m_vecPosition1","documentation":"Closed position."},{"namespace":"","declaration":"EHandle m_hActivator","documentation":"Handle to the activator."},{"namespace":"","declaration":"float m_flHeight","documentation":"Height."},{"namespace":"","declaration":"int m_cTriggersLeft","documentation":"Trigger_counter only: # of activations remaining."},{"namespace":"","declaration":"float m_flTLength","documentation":"For plats."},{"namespace":"","declaration":"float m_flTWidth","documentation":"For plats."},{"namespace":"","declaration":"float m_flLip","documentation":"How much to stick out of a wall. Will recede further into walls if negative."},{"namespace":"","declaration":"float m_flWait","documentation":"How long to wait before resetting."},{"namespace":"","declaration":"float m_flMoveDistance","documentation":"How far a door should slide or rotate."},{"namespace":"","declaration":"TOGGLE_STATE m_toggle_state","documentation":"Current toggle state."},{"namespace":"","declaration":"bool m_fSequenceLoops","documentation":"True if the sequence loops."},{"namespace":"","declaration":"bool m_fSequenceFinished","documentation":"Flag set when StudioAdvanceFrame moves across a frame boundry."},{"namespace":"","declaration":"float m_flLastGaitEventCheck","documentation":"Last time the event list was checked."},{"namespace":"","declaration":"float m_flLastEventCheck","documentation":"Last time the event list was checked."},{"namespace":"","declaration":"float m_flGroundSpeed","documentation":"Computed linear movement rate for current sequence."},{"namespace":"","declaration":"float m_flFrameRate","documentation":"Computed FPS for current sequence."},{"namespace":"","declaration":"string_t m_iszKillTarget","documentation":"The name of the kill target, if any."},{"namespace":"","declaration":"float m_flDelay","documentation":"Delay before fire."},{"namespace":"","declaration":"Vector m_vecOriginalRenderColor","documentation":"Original render color."},{"namespace":"","declaration":"float m_flOriginalRenderAmount","documentation":"Original render amount."},{"namespace":"","declaration":"int m_iOriginalRenderFX","documentation":"Original render FX."},{"namespace":"","declaration":"int m_iOriginalRenderMode","documentation":"Original render model."},{"namespace":"","declaration":"string_t classnameInFilterType","documentation":"Class name in filter type."},{"namespace":"","declaration":"string_t targetnameInFilterType","documentation":"Target name in filter type."},{"namespace":"","declaration":"string_t classnameOutFilterType","documentation":"Class name out filter type."},{"namespace":"","declaration":"string_t targetnameOutFilterType","documentation":"Target name out filter type."},{"namespace":"","declaration":"Vector m_vecLastOrigin","documentation":"Last origin vector"},{"namespace":"","declaration":"bool m_fCustomModel","documentation":"Whether a custom model is used."},{"namespace":"","declaration":"bool m_fCanFadeStart","documentation":"Whether fading can start."},{"namespace":"","declaration":"float m_flMaximumFadeWaitB","documentation":"Maximum fade wait time B."},{"namespace":"","declaration":"float m_flMaximumFadeWait","documentation":"Maximum fade wait time."},{"namespace":"","declaration":"int m_iClassSelection","documentation":"The overridden classification."},{"namespace":"","declaration":"bool m_fOverrideClass","documentation":"Whether this entity overrides the classification."},{"namespace":"","declaration":"entvars_t@ pev","documentation":"Entity variables"}],"className":"CBaseDoor","documentation":"Door entity base class","namespace":""},{"flags":262145,"methods":[{"declaration":"ButtonCode ButtonResponseToTouch()","documentation":"Gets the button response to a touch event."},{"declaration":"void ButtonUse(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue)","documentation":"Button Use function."},{"declaration":"void ButtonBackHome()","documentation":"Button has returned to start state.  Quiesce it."},{"declaration":"void ButtonReturn()","documentation":"Starts the button moving \"out/down\""},{"declaration":"void TriggerAndWait()","documentation":"Button has reached the \"in/up\" position.  Activate its \"targets\", and pause before \"popping out\"."},{"declaration":"void ButtonSpark()","documentation":"Makes the button start sparking. The button will spark randomly after this."},{"declaration":"void ButtonTouch(CBaseEntity@ pOther)","documentation":"Button Touch function."},{"declaration":"void ButtonActivate()","documentation":"Activates the button."},{"declaration":"InventoryRules@ get_m_pInventoryRules() const","documentation":"The inventory rules."},{"declaration":"bool IsToggleLockedByMaster()","documentation":"Returns whether this entity is locked by its master.<br/>Separate from IsLockedByMaster due to limitations."},{"declaration":"void AngularMove(Vector vecDestAngle, float flSpeed)","documentation":"Performs angular movement."},{"declaration":"void LinearMove(Vector vecDest, float flSpeed)","documentation":"Performs linear movement."},{"declaration":"int GetSequenceActivityName(int iSequence)","documentation":"Sets the sequence box."},{"declaration":"void SetSequenceBox()","documentation":"Sets the sequence box."},{"declaration":"int GetAttachmentCount()","documentation":"Gets the number of attachments that the current model has."},{"declaration":"bool ExtractBbox(int iSequence, Vector& out mins, Vector& out maxs)","documentation":"Extracts the bounding box of the current model."},{"declaration":"int GetBodygroup(int iGroup)","documentation":"Gets the value of the given body group."},{"declaration":"void SetBodygroup(int iGroup, int iValue)","documentation":"Sets the given body group to the given value."},{"declaration":"void GetAttachment(int iAttachment, Vector& out origin, Vector& out angles)","documentation":"Gets the attachment position."},{"declaration":"int FindTransition(int iEndingSequence, int iGoalSequence)","documentation":"Find the transition between 2 sequences."},{"declaration":"int FindTransition(int iEndingSequence, int iGoalSequence, int& out iDir)","documentation":"Find the transition between 2 sequences."},{"declaration":"void GetAutomovement(Vector& out origin, Vector& out angles, float flInterval = 0.1f)","documentation":"Gets automatic movement."},{"declaration":"void GetBonePosition(int iBone, Vector& out origin, Vector& out angles)","documentation":"Gets the position of the given bone."},{"declaration":"float SetBlending(int iBlender, float flValue)","documentation":"Sets the given blending controller to the given value."},{"declaration":"void InitBoneControllers()","documentation":"Initializes bone controllers."},{"declaration":"float SetBoneController(int iController, float flValue)","documentation":"Sets the specified bone controller to the given value."},{"declaration":"void DispatchAnimEvents(float flFutureInterval = 0.1f)","documentation":"Handle events that have happend since last time called up until X seconds into the future."},{"declaration":"void ResetGaitSequenceInfo()","documentation":"Resets gait sequence info."},{"declaration":"void ResetSequenceInfo()","documentation":"Resets sequence info."},{"declaration":"int LookupSequence(const string& in szLabel)","documentation":"Returns the index of the given sequence, or -1 if no such sequence exists."},{"declaration":"int LookupActivityHeaviest(int iActivity)","documentation":"Returns the index of the given activity that has the heaviest weight, or -1 if no such activity exists."},{"declaration":"int LookupActivity(int iActivity)","documentation":"Returns the index of the given activity, or -1 if no such activity exists."},{"declaration":"int GetSequenceFlags()","documentation":"Get sequence flags."},{"declaration":"float StudioFrameAdvance(float flInterval = 0.0f)","documentation":"Accumulate animation frame time from last time called until now."},{"declaration":"void DelayThink()","documentation":"Think function. Used internally."},{"declaration":"void SUB_UseTargets(CBaseEntity@ pActivator, USE_TYPE useType, float flValue)","documentation":"Causes this entity to trigger its targets with an optional delay."},{"declaration":"void ClearUserData()","documentation":"Clears the user data on this entity. WARNING: clears all data.<br/>Only map scripts can use this."},{"declaration":"dictionaryValue& GetUserData(const string& in szKey)","documentation":"Gets the user data stored under the specified key on this entity.<br/>Do not keep references to this data, the object might be removed from this entity.<br/>Only map scripts can use this."},{"declaration":"dictionary@ GetUserData()","documentation":"Gets the user data on this entity. Do not keep references to this data, the object might be removed from this entity.<br/>Only map scripts can use this."},{"declaration":"void EndRevive(float flTimeUntilRevive)","documentation":"Called when this entity should be revived. flTimeUntilRevive is the time until the revival should start."},{"declaration":"void BeginRevive(float flTimeUntilRevive)","documentation":"Prepares this entity for revival. flTimeUntilRevive is the time until the revive action completes."},{"declaration":"bool IsRevivable()","documentation":"Returns whether this entity is revivable at this time."},{"declaration":"void OnDestroy()","documentation":"Entity destructor."},{"declaration":"void OnCreate()","documentation":"Entity constructor."},{"declaration":"void GetDamagePoints(entvars_t@ pevAttacker, entvars_t@ pevInflictor, float flDamage)","documentation":"Adds damage points to the inflicting entity."},{"declaration":"float GetPointsForDamage(float flDamage)","documentation":"Returns the points received for damage done."},{"declaration":"bool IsFacing(entvars_t@ pevTest, float flDotProduct = VIEW_FIELD_ULTRA_NARROW)","documentation":"Returns whether this entity is facing the given entity, within the given view field."},{"declaration":"bool FVisible(const Vector& in vecOrigin)","documentation":"Returns whether this entity is visible from the given origin."},{"declaration":"bool FVisible(CBaseEntity@ pEntity, bool fIgnoreGlass)","documentation":"Returns whether this entity is visible to the given entity."},{"declaration":"int Illumination()","documentation":"Returns this entity's illumination."},{"declaration":"Vector BodyTarget(const Vector& in posSrc)","documentation":"Returns this entity's body target for shooting."},{"declaration":"Vector EarPosition()","documentation":"Returns this entity's ear position."},{"declaration":"Vector EyePosition()","documentation":"Returns this entity's eye position."},{"declaration":"Vector Center()","documentation":"Returns this entity's center."},{"declaration":"bool FBecomeProne()","documentation":"Makes this entity become prone."},{"declaration":"CBaseEntity@ Respawn()","documentation":"Respawns this entity."},{"declaration":"void UpdateOnRemove()","documentation":"Updates this entity when removed."},{"declaration":"void Blocked(CBaseEntity@ pOther)","documentation":"Triggers this entity's blocked function."},{"declaration":"void Use(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f)","documentation":"Trigger's this entity's use function."},{"declaration":"void Touch(CBaseEntity@ pOther)","documentation":"Triggers this entity's touch function."},{"declaration":"void Think()","documentation":"Makes this entity think. Do not call directly."},{"declaration":"CBaseEntity@ GetNextTarget()","documentation":"Gets the next target to trigger."},{"declaration":"bool CriticalRemove()","documentation":"Removes this entity in critical situations."},{"declaration":"bool IsMachine()","documentation":"Returns whether this is a machine."},{"declaration":"bool IsPointEnt()","documentation":"Returns whether this is a point entity."},{"declaration":"bool IsNetClient()","documentation":"Returns whether this is a net client."},{"declaration":"bool IsPlayer()","documentation":"Returns whether this entity is a player."},{"declaration":"bool IsMonster()","documentation":"Returns whether this entity is a monster."},{"declaration":"bool IsInWorld()","documentation":"Returns whether this entity is in the world."},{"declaration":"bool ReflectGauss()","documentation":"Returns whether this entity reflects gauss shots."},{"declaration":"bool IsBSPModel()","documentation":"Returns whether this entity is a BSP model."},{"declaration":"bool IsAlive()","documentation":"Returns whether this entity is alive."},{"declaration":"bool IsSneaking()","documentation":"Returns whether this entity is sneaking."},{"declaration":"bool OnControls(entvars_t@ pev)","documentation":"Reacts to controls set on the pev."},{"declaration":"void StopSneaking()","documentation":"Stops sneaking."},{"declaration":"void StartSneaking()","documentation":"Starts sneaking."},{"declaration":"void SetToggleState(int state)","documentation":"Sets this entity's toggle state."},{"declaration":"int DamageDecal(int bitsDamageType)","documentation":"Returns the damage decal<br/>See decal_e."},{"declaration":"void OverrideReset()","documentation":"Resets this entity."},{"declaration":"bool IsMoving()","documentation":"Returns whether this entity is moving."},{"declaration":"float GetDelay()","documentation":"Gets this entity's trigger delay."},{"declaration":"bool RemovePlayerItem(CBasePlayerItem@ pItem)","documentation":"Removes the given player item to this entity."},{"declaration":"AddPlayerItemResult AddPlayerItem(CBasePlayerItem@ pItem)","documentation":"Adds the given player item to this entity."},{"declaration":"void AddPointsToTeam(int score, const bool bAllowNegativeScore)","documentation":"Adds points to this entity's team."},{"declaration":"void AddPoints(int score, const bool bAllowNegativeScore)","documentation":"Adds points to this entity."},{"declaration":"int GetToggleState()","documentation":"Gets the toggle state.<br/>See the TOGGLE_STATE enum."},{"declaration":"bool SetupModel()","documentation":"Sets up the model."},{"declaration":"int entindex()","documentation":"Returns this entity's index."},{"declaration":"edict_t@ edict()","documentation":"Returns this entity's edict."},{"declaration":"bool IsLockedByMaster()","documentation":"Returns whether this entity is locked by its master."},{"declaration":"bool IsDormant()","documentation":"Returns whether this entity is dormant."},{"declaration":"void MakeDormant()","documentation":"Makes this entity dormant."},{"declaration":"bool Intersects(CBaseEntity@ pOther)","documentation":"Returns whether this entity intersects with the given entity."},{"declaration":"void FireBullets(uint cShots, Vector vecSrc, Vector vecDirShooting, Vector vecSpread,float flDistance, Bullet iBulletType, int iTracerFreq = 4, int iDamage = 0, entvars_t@ pevAttacker = null, FireBulletsDrawMode fDraw = FBDM_DRAW)","documentation":"Fires bullets. Must call CMath::MakeAimVectors with an angle vector first."},{"declaration":"bool ShouldToggle(USE_TYPE useType, const bool currentState)","documentation":"Returns whether this entity should toggle."},{"declaration":"void SUB_CallUseToggle()","documentation":"Think function. Calls use toggle on this entity."},{"declaration":"void SUB_FadeOut()","documentation":"Think function. Fades this entity."},{"declaration":"void SUB_StartFadeOut()","documentation":"Think function. Starts fading this entity."},{"declaration":"void SUB_DoNothing()","documentation":"Think function. Explicitly does nothing."},{"declaration":"void SUB_Remove()","documentation":"Think function. Delay-removes this entity."},{"declaration":"bool BlockedByEntity(CBaseEntity@ pOther, float flDamage)","documentation":"Returns true if you should be blocked by the entity, false otherwise. Also deals blocking damage to the entity, if applicable."},{"declaration":"CustomKeyvalues@ GetCustomKeyvalues()","documentation":"Gets this entity's custom keyvalues."},{"declaration":"CBaseMonster@ MyMonsterPointer()","documentation":"Returns this entity as its monster entity, if it is a monster."},{"declaration":"bool IsTriggered(CBaseEntity@ pActivator)","documentation":"Returns whether this entity is triggered by the given entity."},{"declaration":"int BloodColor()","documentation":"Returns the blood color. See the BLOOD_COLOR enum."},{"declaration":"void Killed(entvars_t@pevAtttacker, int iGibbed)","documentation":"Tells this entity it's been killed. See the GIB enum for possible values."},{"declaration":"bool TakeArmor(float flArmor, int bitsDamageType, int armor_cap = 0)","documentation":"Takes armor from this entity. Note: flArmor is added to entity armor. Use negative values to subtract.If armor_cap is non-zero, won't add more than armor_cap. Returns 1 if it took damage, 0 otherwise."},{"declaration":"bool TakeHealth(float flHealth, int bitsDamageType, int health_cap = 0)","documentation":"Takes health from this entity. Note: flHealth is added to entity health. Use negative values to subtract.If health_cap is non-zero, won't add more than health_cap. Returns true if it took damage, false otherwise."},{"declaration":"int TakeDamage(entvars_t@ pevInflictor, entvars_t@ pevAttacker, float flDamage, int bitsDamageType)","documentation":"Causes this entity to take damage. Returns 1 if it took damage, 0 otherwise."},{"declaration":"int Classify()","documentation":"Gets this entity's classification."},{"declaration":"int IRelationshipByClass(CLASS iClass)","documentation":"Gets the relationship between this entity and the given entity classification. See the RELATIONSHIP enum."},{"declaration":"int IRelationship(CBaseEntity@ other)","documentation":"Gets the relationship between this entity and the given entity. See the RELATIONSHIP enum."},{"declaration":"void ClearClassification()","documentation":"Clears this entity's classification override."},{"declaration":"void SetClassificationFromEntity(CBaseEntity@ pEntity)","documentation":"Sets this entity's classification override to the classification override set on the given entity. Can override the entity's player ally setting."},{"declaration":"void SetClassification(int cl)","documentation":"Sets this entity's classification override. Can override the entity's player ally setting."},{"declaration":"int GetClassification(int cl)","documentation":"Gets this entity's classification. Returns the given value if none is set. See the CLASSIFICATION enum."},{"declaration":"void SetObjectCollisionBox()","documentation":"Sets up the object collision box."},{"declaration":"int ObjectCaps()","documentation":"Gets this entity's objects caps. See the FCAP enum."},{"declaration":"void Precache()","documentation":"Precaches the entity. Do not call directly."},{"declaration":"bool opEquals(CBaseEntity@ pOther)","documentation":"Compares 2 entities for equality."},{"declaration":"void SetPlayerAllyDirect(bool fState)","documentation":"Sets this entity's player ally status.</br>Use this only if you need the setting to be exactly what you give it (e.g. when copying from another monster)"},{"declaration":"void SetPlayerAlly(bool fState)","documentation":"Sets this entity's player ally status."},{"declaration":"bool IsPlayerAlly() const","documentation":"Returns whether this entity is allied to players."},{"declaration":"int FindMonstersInWorld(array<CBaseEntity@>@ pArray, int flagMask)","documentation":"Finds monsters in the world"},{"declaration":"string SOUNDREPLACEMENT_Find(const string& in szFilename)","documentation":"Find sound replacement for the given file."},{"declaration":"bool FVisibleFromPos(const Vector& in vecTarget, const Vector& in vecStart)","documentation":"Returns whether this entity is visible from the given position."},{"declaration":"string GetTargetname() const","documentation":"Returns this entity's target name."},{"declaration":"string GetClassname() const","documentation":"Returns this entity's class name."},{"declaration":"string TeamID()","documentation":"Returns this entity's team ID."},{"declaration":"bool HasTarget(const string& in szTarget)","documentation":"Returns whether this entity has the given target."},{"declaration":"int GiveAmmo(int iAmount, const string& in szName, int iMax, const bool fFromWeapon = true)","documentation":"Gives ammo to this entity."},{"declaration":"void TraceBleed(float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)","documentation":"Traces entity bleed event."},{"declaration":"void TraceAttack(entvars_t@ pevAttacker, float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)","documentation":"Traces an attack by the given entity to this entity."},{"declaration":"bool KeyValue(const string& in szKeyName, const string& in szValue)","documentation":"Sets keyvalue data on this entity"},{"declaration":"void SetOrigin(const Vector& in vecOrigin)","documentation":"Sets this entity's (absolute) origin"},{"declaration":"const Vector& GetOrigin() const","documentation":"Gets the entity's (absolute) origin."},{"declaration":"CBaseEntity@ opImplCast()","documentation":"Implicitly casts to base type."},{"declaration":"CBaseDelay@ opImplCast()","documentation":"Implicitly casts to base type."},{"declaration":"CBaseAnimating@ opImplCast()","documentation":"Implicitly casts to base type."},{"declaration":"CBaseToggle@ opImplCast()","documentation":"Implicitly casts to base type."}],"properties":[{"namespace":"","declaration":"bool m_fRotating","documentation":"a rotating button?  default is a sliding button."},{"namespace":"","declaration":"bool m_fStayPushed","documentation":"button stays pushed in until touched again?"},{"namespace":"","declaration":"string_t m_sMaster","documentation":"This entity's master, if any."},{"namespace":"","declaration":"int m_bitsDamageInflict","documentation":"DMG_ damage type that the door or trigger does."},{"namespace":"","declaration":"Vector m_vecFinalAngle","documentation":"Final angle."},{"namespace":"","declaration":"Vector m_vecFinalDest","documentation":"Final destination."},{"namespace":"","declaration":"Vector m_vecAngle2","documentation":"Open angle."},{"namespace":"","declaration":"Vector m_vecAngle1","documentation":"Closed angle."},{"namespace":"","declaration":"Vector m_vecPosition2","documentation":"Open position."},{"namespace":"","declaration":"Vector m_vecPosition1","documentation":"Closed position."},{"namespace":"","declaration":"EHandle m_hActivator","documentation":"Handle to the activator."},{"namespace":"","declaration":"float m_flHeight","documentation":"Height."},{"namespace":"","declaration":"int m_cTriggersLeft","documentation":"Trigger_counter only: # of activations remaining."},{"namespace":"","declaration":"float m_flTLength","documentation":"For plats."},{"namespace":"","declaration":"float m_flTWidth","documentation":"For plats."},{"namespace":"","declaration":"float m_flLip","documentation":"How much to stick out of a wall. Will recede further into walls if negative."},{"namespace":"","declaration":"float m_flWait","documentation":"How long to wait before resetting."},{"namespace":"","declaration":"float m_flMoveDistance","documentation":"How far a door should slide or rotate."},{"namespace":"","declaration":"TOGGLE_STATE m_toggle_state","documentation":"Current toggle state."},{"namespace":"","declaration":"bool m_fSequenceLoops","documentation":"True if the sequence loops."},{"namespace":"","declaration":"bool m_fSequenceFinished","documentation":"Flag set when StudioAdvanceFrame moves across a frame boundry."},{"namespace":"","declaration":"float m_flLastGaitEventCheck","documentation":"Last time the event list was checked."},{"namespace":"","declaration":"float m_flLastEventCheck","documentation":"Last time the event list was checked."},{"namespace":"","declaration":"float m_flGroundSpeed","documentation":"Computed linear movement rate for current sequence."},{"namespace":"","declaration":"float m_flFrameRate","documentation":"Computed FPS for current sequence."},{"namespace":"","declaration":"string_t m_iszKillTarget","documentation":"The name of the kill target, if any."},{"namespace":"","declaration":"float m_flDelay","documentation":"Delay before fire."},{"namespace":"","declaration":"Vector m_vecOriginalRenderColor","documentation":"Original render color."},{"namespace":"","declaration":"float m_flOriginalRenderAmount","documentation":"Original render amount."},{"namespace":"","declaration":"int m_iOriginalRenderFX","documentation":"Original render FX."},{"namespace":"","declaration":"int m_iOriginalRenderMode","documentation":"Original render model."},{"namespace":"","declaration":"string_t classnameInFilterType","documentation":"Class name in filter type."},{"namespace":"","declaration":"string_t targetnameInFilterType","documentation":"Target name in filter type."},{"namespace":"","declaration":"string_t classnameOutFilterType","documentation":"Class name out filter type."},{"namespace":"","declaration":"string_t targetnameOutFilterType","documentation":"Target name out filter type."},{"namespace":"","declaration":"Vector m_vecLastOrigin","documentation":"Last origin vector"},{"namespace":"","declaration":"bool m_fCustomModel","documentation":"Whether a custom model is used."},{"namespace":"","declaration":"bool m_fCanFadeStart","documentation":"Whether fading can start."},{"namespace":"","declaration":"float m_flMaximumFadeWaitB","documentation":"Maximum fade wait time B."},{"namespace":"","declaration":"float m_flMaximumFadeWait","documentation":"Maximum fade wait time."},{"namespace":"","declaration":"int m_iClassSelection","documentation":"The overridden classification."},{"namespace":"","declaration":"bool m_fOverrideClass","documentation":"Whether this entity overrides the classification."},{"namespace":"","declaration":"entvars_t@ pev","documentation":"Entity variables"}],"className":"CBaseButton","documentation":"Button entity base class","namespace":""},{"flags":262145,"methods":[],"properties":[],"className":"CPathCondition","documentation":"Path condition entity","namespace":""},{"flags":262145,"methods":[{"declaration":"const CBasePlayer@ GetController()","documentation":"Gets the current player controlling this tank, if any."},{"declaration":"void Look(int iDistance)","documentation":"Looks around itself in a box that is iDistance * 2 in width and height for possible targets and stores the list in m_pLink.<br/>The target stores the next target in the list in its m_pLink, and so on."},{"declaration":"void MonsterStopControl()","documentation":"If a monster is controlling this tank, makes the monster stop controlling the tank."},{"declaration":"void StopControl()","documentation":"If a player is controlling this tank, makes the player stop controlling the tank."},{"declaration":"bool StartControl(CBasePlayer@ pController)","documentation":"Makes the given player start controlling this tank."},{"declaration":"Vector AdjustAnglesForBarrel(const Vector& in vecInAngles, float flDistance)","documentation":"Adjusts the given angles to point at the target."},{"declaration":"int BulletCount()","documentation":"Gets the bullet count at this time."},{"declaration":"Vector BarrelPosition()","documentation":"Returns the barrel position."},{"declaration":"void TankTrace(const Vector& in vecStart, const Vector& in vecForward, const Vector& in vecSpread, TraceResult& out tr)","documentation":"Performs a traceline using a random spread based on the given spread amount."},{"declaration":"void MonsterStartup(CBaseMonster@ pMonster)","documentation":"Makes the given monster begin controlling this tank, if no other monster had control before."},{"declaration":"CBaseEntity@ FindTarget()","documentation":"Finds a target to attack, if any."},{"declaration":"bool InRange(float flRange)","documentation":"Returns whether the given range is within the minimum and maximum range of this tank."},{"declaration":"bool CanFire() const","documentation":"Returns whether this tank is able to fire."},{"declaration":"void TankDeactivate()","documentation":"Deactivates the tank. Active tanks are AI controlled."},{"declaration":"void TankActivate()","documentation":"Activates the tank. Active tanks are AI controlled."},{"declaration":"bool IsActive() const","documentation":"Returns whether the tank is active. Active tanks are AI controlled."},{"declaration":"void StopRotSound()","documentation":"Stop playing the rotating sound."},{"declaration":"void StartRotSound()","documentation":"Start playing the rotating sound, if defined."},{"declaration":"Vector UpdateTargetPosition(CBaseEntity@ pTargetEntity)","documentation":"Gets the updated position of the given target. Target must be valid."},{"declaration":"void Fire()","documentation":"Fires the tank. Uses this tank's settings to fire, does not determine if it is targeting anything."},{"declaration":"void Fire(const Vector& in vecBarrelEnd, const Vector& in vecForward, entvars_t@ pevAttacker)","documentation":"Fires the tank. Barrel end position, aiming direction and attacker entvars_t must be given."},{"declaration":"bool PointAt(const Vector& in vecDestination)","documentation":"Points the tank at the target location."},{"declaration":"void TrackTarget()","documentation":"Updates the tank's angles to match either its controlling player, or its current target.Accounts for rotation speed. Will fire at the target if it's automated."},{"declaration":"void ClearUserData()","documentation":"Clears the user data on this entity. WARNING: clears all data.<br/>Only map scripts can use this."},{"declaration":"dictionaryValue& GetUserData(const string& in szKey)","documentation":"Gets the user data stored under the specified key on this entity.<br/>Do not keep references to this data, the object might be removed from this entity.<br/>Only map scripts can use this."},{"declaration":"dictionary@ GetUserData()","documentation":"Gets the user data on this entity. Do not keep references to this data, the object might be removed from this entity.<br/>Only map scripts can use this."},{"declaration":"void EndRevive(float flTimeUntilRevive)","documentation":"Called when this entity should be revived. flTimeUntilRevive is the time until the revival should start."},{"declaration":"void BeginRevive(float flTimeUntilRevive)","documentation":"Prepares this entity for revival. flTimeUntilRevive is the time until the revive action completes."},{"declaration":"bool IsRevivable()","documentation":"Returns whether this entity is revivable at this time."},{"declaration":"void OnDestroy()","documentation":"Entity destructor."},{"declaration":"void OnCreate()","documentation":"Entity constructor."},{"declaration":"void GetDamagePoints(entvars_t@ pevAttacker, entvars_t@ pevInflictor, float flDamage)","documentation":"Adds damage points to the inflicting entity."},{"declaration":"float GetPointsForDamage(float flDamage)","documentation":"Returns the points received for damage done."},{"declaration":"bool IsFacing(entvars_t@ pevTest, float flDotProduct = VIEW_FIELD_ULTRA_NARROW)","documentation":"Returns whether this entity is facing the given entity, within the given view field."},{"declaration":"bool FVisible(const Vector& in vecOrigin)","documentation":"Returns whether this entity is visible from the given origin."},{"declaration":"bool FVisible(CBaseEntity@ pEntity, bool fIgnoreGlass)","documentation":"Returns whether this entity is visible to the given entity."},{"declaration":"int Illumination()","documentation":"Returns this entity's illumination."},{"declaration":"Vector BodyTarget(const Vector& in posSrc)","documentation":"Returns this entity's body target for shooting."},{"declaration":"Vector EarPosition()","documentation":"Returns this entity's ear position."},{"declaration":"Vector EyePosition()","documentation":"Returns this entity's eye position."},{"declaration":"Vector Center()","documentation":"Returns this entity's center."},{"declaration":"bool FBecomeProne()","documentation":"Makes this entity become prone."},{"declaration":"CBaseEntity@ Respawn()","documentation":"Respawns this entity."},{"declaration":"void UpdateOnRemove()","documentation":"Updates this entity when removed."},{"declaration":"void Blocked(CBaseEntity@ pOther)","documentation":"Triggers this entity's blocked function."},{"declaration":"void Use(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f)","documentation":"Trigger's this entity's use function."},{"declaration":"void Touch(CBaseEntity@ pOther)","documentation":"Triggers this entity's touch function."},{"declaration":"void Think()","documentation":"Makes this entity think. Do not call directly."},{"declaration":"CBaseEntity@ GetNextTarget()","documentation":"Gets the next target to trigger."},{"declaration":"bool CriticalRemove()","documentation":"Removes this entity in critical situations."},{"declaration":"bool IsMachine()","documentation":"Returns whether this is a machine."},{"declaration":"bool IsPointEnt()","documentation":"Returns whether this is a point entity."},{"declaration":"bool IsNetClient()","documentation":"Returns whether this is a net client."},{"declaration":"bool IsPlayer()","documentation":"Returns whether this entity is a player."},{"declaration":"bool IsMonster()","documentation":"Returns whether this entity is a monster."},{"declaration":"bool IsInWorld()","documentation":"Returns whether this entity is in the world."},{"declaration":"bool ReflectGauss()","documentation":"Returns whether this entity reflects gauss shots."},{"declaration":"bool IsBSPModel()","documentation":"Returns whether this entity is a BSP model."},{"declaration":"bool IsAlive()","documentation":"Returns whether this entity is alive."},{"declaration":"bool IsSneaking()","documentation":"Returns whether this entity is sneaking."},{"declaration":"bool OnControls(entvars_t@ pev)","documentation":"Reacts to controls set on the pev."},{"declaration":"void StopSneaking()","documentation":"Stops sneaking."},{"declaration":"void StartSneaking()","documentation":"Starts sneaking."},{"declaration":"void SetToggleState(int state)","documentation":"Sets this entity's toggle state."},{"declaration":"int DamageDecal(int bitsDamageType)","documentation":"Returns the damage decal<br/>See decal_e."},{"declaration":"void OverrideReset()","documentation":"Resets this entity."},{"declaration":"bool IsMoving()","documentation":"Returns whether this entity is moving."},{"declaration":"float GetDelay()","documentation":"Gets this entity's trigger delay."},{"declaration":"bool RemovePlayerItem(CBasePlayerItem@ pItem)","documentation":"Removes the given player item to this entity."},{"declaration":"AddPlayerItemResult AddPlayerItem(CBasePlayerItem@ pItem)","documentation":"Adds the given player item to this entity."},{"declaration":"void AddPointsToTeam(int score, const bool bAllowNegativeScore)","documentation":"Adds points to this entity's team."},{"declaration":"void AddPoints(int score, const bool bAllowNegativeScore)","documentation":"Adds points to this entity."},{"declaration":"int GetToggleState()","documentation":"Gets the toggle state.<br/>See the TOGGLE_STATE enum."},{"declaration":"bool SetupModel()","documentation":"Sets up the model."},{"declaration":"int entindex()","documentation":"Returns this entity's index."},{"declaration":"edict_t@ edict()","documentation":"Returns this entity's edict."},{"declaration":"bool IsLockedByMaster()","documentation":"Returns whether this entity is locked by its master."},{"declaration":"bool IsDormant()","documentation":"Returns whether this entity is dormant."},{"declaration":"void MakeDormant()","documentation":"Makes this entity dormant."},{"declaration":"bool Intersects(CBaseEntity@ pOther)","documentation":"Returns whether this entity intersects with the given entity."},{"declaration":"void SUB_UseTargets(CBaseEntity@ pActivator, USE_TYPE useType, float flValue)","documentation":"Calls use on targets."},{"declaration":"void FireBullets(uint cShots, Vector vecSrc, Vector vecDirShooting, Vector vecSpread,float flDistance, Bullet iBulletType, int iTracerFreq = 4, int iDamage = 0, entvars_t@ pevAttacker = null, FireBulletsDrawMode fDraw = FBDM_DRAW)","documentation":"Fires bullets. Must call CMath::MakeAimVectors with an angle vector first."},{"declaration":"bool ShouldToggle(USE_TYPE useType, const bool currentState)","documentation":"Returns whether this entity should toggle."},{"declaration":"void SUB_CallUseToggle()","documentation":"Think function. Calls use toggle on this entity."},{"declaration":"void SUB_FadeOut()","documentation":"Think function. Fades this entity."},{"declaration":"void SUB_StartFadeOut()","documentation":"Think function. Starts fading this entity."},{"declaration":"void SUB_DoNothing()","documentation":"Think function. Explicitly does nothing."},{"declaration":"void SUB_Remove()","documentation":"Think function. Delay-removes this entity."},{"declaration":"bool BlockedByEntity(CBaseEntity@ pOther, float flDamage)","documentation":"Returns true if you should be blocked by the entity, false otherwise. Also deals blocking damage to the entity, if applicable."},{"declaration":"CustomKeyvalues@ GetCustomKeyvalues()","documentation":"Gets this entity's custom keyvalues."},{"declaration":"CBaseMonster@ MyMonsterPointer()","documentation":"Returns this entity as its monster entity, if it is a monster."},{"declaration":"bool IsTriggered(CBaseEntity@ pActivator)","documentation":"Returns whether this entity is triggered by the given entity."},{"declaration":"int BloodColor()","documentation":"Returns the blood color. See the BLOOD_COLOR enum."},{"declaration":"void Killed(entvars_t@pevAtttacker, int iGibbed)","documentation":"Tells this entity it's been killed. See the GIB enum for possible values."},{"declaration":"bool TakeArmor(float flArmor, int bitsDamageType, int armor_cap = 0)","documentation":"Takes armor from this entity. Note: flArmor is added to entity armor. Use negative values to subtract.If armor_cap is non-zero, won't add more than armor_cap. Returns 1 if it took damage, 0 otherwise."},{"declaration":"bool TakeHealth(float flHealth, int bitsDamageType, int health_cap = 0)","documentation":"Takes health from this entity. Note: flHealth is added to entity health. Use negative values to subtract.If health_cap is non-zero, won't add more than health_cap. Returns true if it took damage, false otherwise."},{"declaration":"int TakeDamage(entvars_t@ pevInflictor, entvars_t@ pevAttacker, float flDamage, int bitsDamageType)","documentation":"Causes this entity to take damage. Returns 1 if it took damage, 0 otherwise."},{"declaration":"int Classify()","documentation":"Gets this entity's classification."},{"declaration":"int IRelationshipByClass(CLASS iClass)","documentation":"Gets the relationship between this entity and the given entity classification. See the RELATIONSHIP enum."},{"declaration":"int IRelationship(CBaseEntity@ other)","documentation":"Gets the relationship between this entity and the given entity. See the RELATIONSHIP enum."},{"declaration":"void ClearClassification()","documentation":"Clears this entity's classification override."},{"declaration":"void SetClassificationFromEntity(CBaseEntity@ pEntity)","documentation":"Sets this entity's classification override to the classification override set on the given entity. Can override the entity's player ally setting."},{"declaration":"void SetClassification(int cl)","documentation":"Sets this entity's classification override. Can override the entity's player ally setting."},{"declaration":"int GetClassification(int cl)","documentation":"Gets this entity's classification. Returns the given value if none is set. See the CLASSIFICATION enum."},{"declaration":"void SetObjectCollisionBox()","documentation":"Sets up the object collision box."},{"declaration":"int ObjectCaps()","documentation":"Gets this entity's objects caps. See the FCAP enum."},{"declaration":"void Precache()","documentation":"Precaches the entity. Do not call directly."},{"declaration":"bool opEquals(CBaseEntity@ pOther)","documentation":"Compares 2 entities for equality."},{"declaration":"void SetPlayerAllyDirect(bool fState)","documentation":"Sets this entity's player ally status.</br>Use this only if you need the setting to be exactly what you give it (e.g. when copying from another monster)"},{"declaration":"void SetPlayerAlly(bool fState)","documentation":"Sets this entity's player ally status."},{"declaration":"bool IsPlayerAlly() const","documentation":"Returns whether this entity is allied to players."},{"declaration":"int FindMonstersInWorld(array<CBaseEntity@>@ pArray, int flagMask)","documentation":"Finds monsters in the world"},{"declaration":"string SOUNDREPLACEMENT_Find(const string& in szFilename)","documentation":"Find sound replacement for the given file."},{"declaration":"bool FVisibleFromPos(const Vector& in vecTarget, const Vector& in vecStart)","documentation":"Returns whether this entity is visible from the given position."},{"declaration":"string GetTargetname() const","documentation":"Returns this entity's target name."},{"declaration":"string GetClassname() const","documentation":"Returns this entity's class name."},{"declaration":"string TeamID()","documentation":"Returns this entity's team ID."},{"declaration":"bool HasTarget(const string& in szTarget)","documentation":"Returns whether this entity has the given target."},{"declaration":"int GiveAmmo(int iAmount, const string& in szName, int iMax, const bool fFromWeapon = true)","documentation":"Gives ammo to this entity."},{"declaration":"void TraceBleed(float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)","documentation":"Traces entity bleed event."},{"declaration":"void TraceAttack(entvars_t@ pevAttacker, float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)","documentation":"Traces an attack by the given entity to this entity."},{"declaration":"bool KeyValue(const string& in szKeyName, const string& in szValue)","documentation":"Sets keyvalue data on this entity"},{"declaration":"void SetOrigin(const Vector& in vecOrigin)","documentation":"Sets this entity's (absolute) origin"},{"declaration":"const Vector& GetOrigin() const","documentation":"Gets the entity's (absolute) origin."},{"declaration":"CBaseEntity@ opImplCast()","documentation":"Implicitly casts to base type."}],"properties":[{"namespace":"","declaration":"string_t m_iszMaster","documentation":"Master entity (game_team_master or multisource)"},{"namespace":"","declaration":"int m_spread","documentation":"firing spread"},{"namespace":"","declaration":"Vector m_sightOrigin","documentation":"Last sight of target"},{"namespace":"","declaration":"int m_iBulletDamage","documentation":"0 means use Bullet type's default damage"},{"namespace":"","declaration":"TANKBULLET m_bulletType","documentation":"Bullet type"},{"namespace":"","declaration":"float m_spriteScale","documentation":"Scale of any sprites we shoot"},{"namespace":"","declaration":"Vector m_barrelPos","documentation":"Length of the freakin barrel"},{"namespace":"","declaration":"float m_maxRange","documentation":"Max range to aim/track"},{"namespace":"","declaration":"float m_minRange","documentation":"Minimum range to aim/track"},{"namespace":"","declaration":"float m_persist","documentation":"Persistence of firing (how long do I shoot when I can't see)"},{"namespace":"","declaration":"float m_lastSightTime","documentation":"Last time I saw target"},{"namespace":"","declaration":"float m_fireRate","documentation":"How many rounds/second"},{"namespace":"","declaration":"float m_fireLast","documentation":"Last time I fired"},{"namespace":"","declaration":"float m_pitchTolerance","documentation":"Tolerance angle"},{"namespace":"","declaration":"float m_pitchRange","documentation":"Range of pitch motion as above"},{"namespace":"","declaration":"float m_pitchRate","documentation":"Max turn rate on pitch"},{"namespace":"","declaration":"float m_pitchCenter","documentation":"\"Center\" pitch"},{"namespace":"","declaration":"float m_yawTolerance","documentation":"Tolerance angle"},{"namespace":"","declaration":"float m_yawRange","documentation":"Range of turning motion (one-sided: 30 is +/- 30 degress from center)<br/>Zero is full rotation"},{"namespace":"","declaration":"float m_yawRate","documentation":"Max turn rate to track targets"},{"namespace":"","declaration":"float m_yawCenter","documentation":"\"Center\" yaw"},{"namespace":"","declaration":"float m_flNextAttack","documentation":"Next attack time"},{"namespace":"","declaration":"Vector m_vecControllerUsePos","documentation":"Start origin of the player that is currently controlling this tank.<br/>Used to determine when a player has moved too far to continue controlling this tank."},{"namespace":"","declaration":"Vector m_StartAngles","documentation":"Angles that the tank starts with"},{"namespace":"","declaration":"Vector m_vecOriginalRenderColor","documentation":"Original render color."},{"namespace":"","declaration":"float m_flOriginalRenderAmount","documentation":"Original render amount."},{"namespace":"","declaration":"int m_iOriginalRenderFX","documentation":"Original render FX."},{"namespace":"","declaration":"int m_iOriginalRenderMode","documentation":"Original render model."},{"namespace":"","declaration":"string_t classnameInFilterType","documentation":"Class name in filter type."},{"namespace":"","declaration":"string_t targetnameInFilterType","documentation":"Target name in filter type."},{"namespace":"","declaration":"string_t classnameOutFilterType","documentation":"Class name out filter type."},{"namespace":"","declaration":"string_t targetnameOutFilterType","documentation":"Target name out filter type."},{"namespace":"","declaration":"Vector m_vecLastOrigin","documentation":"Last origin vector"},{"namespace":"","declaration":"bool m_fCustomModel","documentation":"Whether a custom model is used."},{"namespace":"","declaration":"bool m_fCanFadeStart","documentation":"Whether fading can start."},{"namespace":"","declaration":"float m_flMaximumFadeWaitB","documentation":"Maximum fade wait time B."},{"namespace":"","declaration":"float m_flMaximumFadeWait","documentation":"Maximum fade wait time."},{"namespace":"","declaration":"int m_iClassSelection","documentation":"The overridden classification."},{"namespace":"","declaration":"bool m_fOverrideClass","documentation":"Whether this entity overrides the classification."},{"namespace":"","declaration":"entvars_t@ pev","documentation":"Entity variables"}],"className":"CBaseTank","documentation":"Tank base class","namespace":""},{"flags":262145,"methods":[{"declaration":"void FireAtPoint(TraceResult& in tr)","documentation":"Fires the laser at a point defined by where the TraceResult hit.<br/>Also causes beam damage as if CBeam::BeamDamage were used, and sparks at both ends, if the approprite spawn flags have been set."},{"declaration":"bool IsOn()","documentation":"Returns whether the laser is on"},{"declaration":"void TurnOff()","documentation":"Turns the laser off"},{"declaration":"void TurnOn()","documentation":"Turns the laser on"},{"declaration":"void XenTeleport(const Vector& in vecSrc, int iRadius = 256)","documentation":"Creates a Xen teleport effect at the given location, with zaps occuring within the given radius."},{"declaration":"void XenTeleportZap(const Vector& in vecSrc, const Vector& in vecDest)","documentation":"Creates a Xen teleport zap effect between the given points."},{"declaration":"void BeamDamageInstant(TraceResult& in tr, float flDamage)","documentation":"Causes the given amount of damage to be done to the entity hit by the given traceresult, as if the damage occured one second ago."},{"declaration":"void LiveForTime(float flTime)","documentation":"Sets this beam to live for the given amount of time, after which it is removed."},{"declaration":"void HoseInit(const Vector& in vecStart, const Vector& in vecDirection)","documentation":"Initializes this beam to be a beam going from a point in a given direction (BEAM_HOSE)."},{"declaration":"void EntsInit(CBaseEntity@ pEntStart, CBaseEntity@ pEntEnd)","documentation":"Initializes this beam to be a beam between 2 given entities (BEAM_ENTS)."},{"declaration":"void EntsInit(int startIndex, int endIndex)","documentation":"Initializes this beam to be a beam between 2 given entities (BEAM_ENTS)."},{"declaration":"void PointEntInit(const Vector& in vecStart, CBaseEntity@ pEntEnd)","documentation":"Initializes this beam to be a beam between a point and an entity (BEAM_ENTPOINT)."},{"declaration":"void PointEntInit(const Vector& in vecStart, int endIndex)","documentation":"Initializes this beam to be a beam between a point and an entity (BEAM_ENTPOINT)."},{"declaration":"void PointsInit(const Vector& in vecStart, const Vector& in vecEnd)","documentation":"Initializes this beam to be a beam between 2 given points (BEAM_POINTS)."},{"declaration":"void BeamInit(const string& in szSpriteName, int iWidth)","documentation":"Initializes this beam with default values and sets the given sprite as the sprite used, with the given width."},{"declaration":"void BeamDamage(TraceResult& in tr)","documentation":"Damages the entity hit by the given trace line with the amount set in this entity's pev->dmg variable.<br/>Also applies decals to BSP models if the appropriate spawnflag is set."},{"declaration":"void DoSparks(const Vector& in vecStart, const Vector& in vecEnd)","documentation":"Creates sparks at the given start and end points, if appropriate spawn flags are set."},{"declaration":"void RelinkBeam()","documentation":"Call after you change start/end positions."},{"declaration":"int GetScrollRate()","documentation":"Gets the beam's scroll rate."},{"declaration":"int GetFrame()","documentation":"Gets the beam's frame number."},{"declaration":"int GetBrightness()","documentation":"Gets the beam's brightness."},{"declaration":"void GetColor(int& out r, int& out g, int& out b)","documentation":"Gets the beam's color."},{"declaration":"int GetNoise()","documentation":"Gets the beam's noise."},{"declaration":"int GetWidth()","documentation":"Gets the beam's width."},{"declaration":"int GetTexture()","documentation":"Gets the beam's texture (sprite) index."},{"declaration":"const Vector& GetEndPos()","documentation":"Gets the beam's ending position."},{"declaration":"const Vector& GetStartPos()","documentation":"Gets the beam's starting position."},{"declaration":"void SetScrollRate(int speed)","documentation":"Sets the scroll rate of the beam."},{"declaration":"void SetFrame(float frame)","documentation":"Sets the frame number of the beam."},{"declaration":"void SetBrightness(int brightness)","documentation":"Sets the brightness of the beam. Value is between 0-255."},{"declaration":"void SetColor(int r, int g, int b)","documentation":"Sets the color of the beam."},{"declaration":"void SetNoise(int iAmplitude)","documentation":"Sets the noise (amplitude) of the beam."},{"declaration":"void SetWidth(int iWidth)","documentation":"Sets the width of the beam."},{"declaration":"void SetTexture(int spriteIndex)","documentation":"Sets the sprite to use. The index is the one returned from CGame::PrecacheModel."},{"declaration":"void SetEndAttachment(int attachment)","documentation":"Sets the end attachment of the beam. Attachment is a point on the entity's model. Must be a beam of type BEAM_ENTS or BEAM_ENTPOINT. Set to 0 to disable."},{"declaration":"void SetStartAttachment(int attachment)","documentation":"Sets the start attachment of the beam. Attachment is a point on the entity's model. Must be a beam of type BEAM_ENTS. Set to 0 to disable."},{"declaration":"void SetEndEntity(CBaseEntity@ pEntity)","documentation":"Sets the ending entity of the beam. Must be a beam of type BEAM_ENTS or BEAM_ENTPOINT."},{"declaration":"void SetEndEntity(int entityIndex)","documentation":"Sets the ending entity of the beam. Must be a beam of type BEAM_ENTS or BEAM_ENTPOINT."},{"declaration":"void SetStartEntity(CBaseEntity@ pEntity)","documentation":"Sets the starting entity of the beam. Must be a beam of type BEAM_ENTS."},{"declaration":"void SetStartEntity(int entityIndex)","documentation":"Sets the starting entity of the beam. Must be a beam of type BEAM_ENTS."},{"declaration":"void SetEndPos(const Vector& in vecPos)","documentation":"Sets the ending position of the beam. Must be a beam of type BEAM_POINTS or BEAM_HOSE."},{"declaration":"void SetStartPos(const Vector& in vecPos)","documentation":"Sets the starting position of the beam. Must be a beam of type BEAM_POINTS, BEAM_ENTPOINT or BEAM_HOSE."},{"declaration":"void SetFlags(int flags)","documentation":"Sets the flags of the beam. Must be a combination of BeamFlags values, or 0."},{"declaration":"void SetType(BeamType type)","documentation":"Sets the type of the beam."},{"declaration":"void ClearUserData()","documentation":"Clears the user data on this entity. WARNING: clears all data.<br/>Only map scripts can use this."},{"declaration":"dictionaryValue& GetUserData(const string& in szKey)","documentation":"Gets the user data stored under the specified key on this entity.<br/>Do not keep references to this data, the object might be removed from this entity.<br/>Only map scripts can use this."},{"declaration":"dictionary@ GetUserData()","documentation":"Gets the user data on this entity. Do not keep references to this data, the object might be removed from this entity.<br/>Only map scripts can use this."},{"declaration":"void EndRevive(float flTimeUntilRevive)","documentation":"Called when this entity should be revived. flTimeUntilRevive is the time until the revival should start."},{"declaration":"void BeginRevive(float flTimeUntilRevive)","documentation":"Prepares this entity for revival. flTimeUntilRevive is the time until the revive action completes."},{"declaration":"bool IsRevivable()","documentation":"Returns whether this entity is revivable at this time."},{"declaration":"void OnDestroy()","documentation":"Entity destructor."},{"declaration":"void OnCreate()","documentation":"Entity constructor."},{"declaration":"void GetDamagePoints(entvars_t@ pevAttacker, entvars_t@ pevInflictor, float flDamage)","documentation":"Adds damage points to the inflicting entity."},{"declaration":"float GetPointsForDamage(float flDamage)","documentation":"Returns the points received for damage done."},{"declaration":"bool IsFacing(entvars_t@ pevTest, float flDotProduct = VIEW_FIELD_ULTRA_NARROW)","documentation":"Returns whether this entity is facing the given entity, within the given view field."},{"declaration":"bool FVisible(const Vector& in vecOrigin)","documentation":"Returns whether this entity is visible from the given origin."},{"declaration":"bool FVisible(CBaseEntity@ pEntity, bool fIgnoreGlass)","documentation":"Returns whether this entity is visible to the given entity."},{"declaration":"int Illumination()","documentation":"Returns this entity's illumination."},{"declaration":"Vector BodyTarget(const Vector& in posSrc)","documentation":"Returns this entity's body target for shooting."},{"declaration":"Vector EarPosition()","documentation":"Returns this entity's ear position."},{"declaration":"Vector EyePosition()","documentation":"Returns this entity's eye position."},{"declaration":"Vector Center()","documentation":"Returns this entity's center."},{"declaration":"bool FBecomeProne()","documentation":"Makes this entity become prone."},{"declaration":"CBaseEntity@ Respawn()","documentation":"Respawns this entity."},{"declaration":"void UpdateOnRemove()","documentation":"Updates this entity when removed."},{"declaration":"void Blocked(CBaseEntity@ pOther)","documentation":"Triggers this entity's blocked function."},{"declaration":"void Use(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f)","documentation":"Trigger's this entity's use function."},{"declaration":"void Touch(CBaseEntity@ pOther)","documentation":"Triggers this entity's touch function."},{"declaration":"void Think()","documentation":"Makes this entity think. Do not call directly."},{"declaration":"CBaseEntity@ GetNextTarget()","documentation":"Gets the next target to trigger."},{"declaration":"bool CriticalRemove()","documentation":"Removes this entity in critical situations."},{"declaration":"bool IsMachine()","documentation":"Returns whether this is a machine."},{"declaration":"bool IsPointEnt()","documentation":"Returns whether this is a point entity."},{"declaration":"bool IsNetClient()","documentation":"Returns whether this is a net client."},{"declaration":"bool IsPlayer()","documentation":"Returns whether this entity is a player."},{"declaration":"bool IsMonster()","documentation":"Returns whether this entity is a monster."},{"declaration":"bool IsInWorld()","documentation":"Returns whether this entity is in the world."},{"declaration":"bool ReflectGauss()","documentation":"Returns whether this entity reflects gauss shots."},{"declaration":"bool IsBSPModel()","documentation":"Returns whether this entity is a BSP model."},{"declaration":"bool IsAlive()","documentation":"Returns whether this entity is alive."},{"declaration":"bool IsSneaking()","documentation":"Returns whether this entity is sneaking."},{"declaration":"bool OnControls(entvars_t@ pev)","documentation":"Reacts to controls set on the pev."},{"declaration":"void StopSneaking()","documentation":"Stops sneaking."},{"declaration":"void StartSneaking()","documentation":"Starts sneaking."},{"declaration":"void SetToggleState(int state)","documentation":"Sets this entity's toggle state."},{"declaration":"int DamageDecal(int bitsDamageType)","documentation":"Returns the damage decal<br/>See decal_e."},{"declaration":"void OverrideReset()","documentation":"Resets this entity."},{"declaration":"bool IsMoving()","documentation":"Returns whether this entity is moving."},{"declaration":"float GetDelay()","documentation":"Gets this entity's trigger delay."},{"declaration":"bool RemovePlayerItem(CBasePlayerItem@ pItem)","documentation":"Removes the given player item to this entity."},{"declaration":"AddPlayerItemResult AddPlayerItem(CBasePlayerItem@ pItem)","documentation":"Adds the given player item to this entity."},{"declaration":"void AddPointsToTeam(int score, const bool bAllowNegativeScore)","documentation":"Adds points to this entity's team."},{"declaration":"void AddPoints(int score, const bool bAllowNegativeScore)","documentation":"Adds points to this entity."},{"declaration":"int GetToggleState()","documentation":"Gets the toggle state.<br/>See the TOGGLE_STATE enum."},{"declaration":"bool SetupModel()","documentation":"Sets up the model."},{"declaration":"int entindex()","documentation":"Returns this entity's index."},{"declaration":"edict_t@ edict()","documentation":"Returns this entity's edict."},{"declaration":"bool IsLockedByMaster()","documentation":"Returns whether this entity is locked by its master."},{"declaration":"bool IsDormant()","documentation":"Returns whether this entity is dormant."},{"declaration":"void MakeDormant()","documentation":"Makes this entity dormant."},{"declaration":"bool Intersects(CBaseEntity@ pOther)","documentation":"Returns whether this entity intersects with the given entity."},{"declaration":"void SUB_UseTargets(CBaseEntity@ pActivator, USE_TYPE useType, float flValue)","documentation":"Calls use on targets."},{"declaration":"void FireBullets(uint cShots, Vector vecSrc, Vector vecDirShooting, Vector vecSpread,float flDistance, Bullet iBulletType, int iTracerFreq = 4, int iDamage = 0, entvars_t@ pevAttacker = null, FireBulletsDrawMode fDraw = FBDM_DRAW)","documentation":"Fires bullets. Must call CMath::MakeAimVectors with an angle vector first."},{"declaration":"bool ShouldToggle(USE_TYPE useType, const bool currentState)","documentation":"Returns whether this entity should toggle."},{"declaration":"void SUB_CallUseToggle()","documentation":"Think function. Calls use toggle on this entity."},{"declaration":"void SUB_FadeOut()","documentation":"Think function. Fades this entity."},{"declaration":"void SUB_StartFadeOut()","documentation":"Think function. Starts fading this entity."},{"declaration":"void SUB_DoNothing()","documentation":"Think function. Explicitly does nothing."},{"declaration":"void SUB_Remove()","documentation":"Think function. Delay-removes this entity."},{"declaration":"bool BlockedByEntity(CBaseEntity@ pOther, float flDamage)","documentation":"Returns true if you should be blocked by the entity, false otherwise. Also deals blocking damage to the entity, if applicable."},{"declaration":"CustomKeyvalues@ GetCustomKeyvalues()","documentation":"Gets this entity's custom keyvalues."},{"declaration":"CBaseMonster@ MyMonsterPointer()","documentation":"Returns this entity as its monster entity, if it is a monster."},{"declaration":"bool IsTriggered(CBaseEntity@ pActivator)","documentation":"Returns whether this entity is triggered by the given entity."},{"declaration":"int BloodColor()","documentation":"Returns the blood color. See the BLOOD_COLOR enum."},{"declaration":"void Killed(entvars_t@pevAtttacker, int iGibbed)","documentation":"Tells this entity it's been killed. See the GIB enum for possible values."},{"declaration":"bool TakeArmor(float flArmor, int bitsDamageType, int armor_cap = 0)","documentation":"Takes armor from this entity. Note: flArmor is added to entity armor. Use negative values to subtract.If armor_cap is non-zero, won't add more than armor_cap. Returns 1 if it took damage, 0 otherwise."},{"declaration":"bool TakeHealth(float flHealth, int bitsDamageType, int health_cap = 0)","documentation":"Takes health from this entity. Note: flHealth is added to entity health. Use negative values to subtract.If health_cap is non-zero, won't add more than health_cap. Returns true if it took damage, false otherwise."},{"declaration":"int TakeDamage(entvars_t@ pevInflictor, entvars_t@ pevAttacker, float flDamage, int bitsDamageType)","documentation":"Causes this entity to take damage. Returns 1 if it took damage, 0 otherwise."},{"declaration":"int Classify()","documentation":"Gets this entity's classification."},{"declaration":"int IRelationshipByClass(CLASS iClass)","documentation":"Gets the relationship between this entity and the given entity classification. See the RELATIONSHIP enum."},{"declaration":"int IRelationship(CBaseEntity@ other)","documentation":"Gets the relationship between this entity and the given entity. See the RELATIONSHIP enum."},{"declaration":"void ClearClassification()","documentation":"Clears this entity's classification override."},{"declaration":"void SetClassificationFromEntity(CBaseEntity@ pEntity)","documentation":"Sets this entity's classification override to the classification override set on the given entity. Can override the entity's player ally setting."},{"declaration":"void SetClassification(int cl)","documentation":"Sets this entity's classification override. Can override the entity's player ally setting."},{"declaration":"int GetClassification(int cl)","documentation":"Gets this entity's classification. Returns the given value if none is set. See the CLASSIFICATION enum."},{"declaration":"void SetObjectCollisionBox()","documentation":"Sets up the object collision box."},{"declaration":"int ObjectCaps()","documentation":"Gets this entity's objects caps. See the FCAP enum."},{"declaration":"void Precache()","documentation":"Precaches the entity. Do not call directly."},{"declaration":"bool opEquals(CBaseEntity@ pOther)","documentation":"Compares 2 entities for equality."},{"declaration":"void SetPlayerAllyDirect(bool fState)","documentation":"Sets this entity's player ally status.</br>Use this only if you need the setting to be exactly what you give it (e.g. when copying from another monster)"},{"declaration":"void SetPlayerAlly(bool fState)","documentation":"Sets this entity's player ally status."},{"declaration":"bool IsPlayerAlly() const","documentation":"Returns whether this entity is allied to players."},{"declaration":"int FindMonstersInWorld(array<CBaseEntity@>@ pArray, int flagMask)","documentation":"Finds monsters in the world"},{"declaration":"string SOUNDREPLACEMENT_Find(const string& in szFilename)","documentation":"Find sound replacement for the given file."},{"declaration":"bool FVisibleFromPos(const Vector& in vecTarget, const Vector& in vecStart)","documentation":"Returns whether this entity is visible from the given position."},{"declaration":"string GetTargetname() const","documentation":"Returns this entity's target name."},{"declaration":"string GetClassname() const","documentation":"Returns this entity's class name."},{"declaration":"string TeamID()","documentation":"Returns this entity's team ID."},{"declaration":"bool HasTarget(const string& in szTarget)","documentation":"Returns whether this entity has the given target."},{"declaration":"int GiveAmmo(int iAmount, const string& in szName, int iMax, const bool fFromWeapon = true)","documentation":"Gives ammo to this entity."},{"declaration":"void TraceBleed(float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)","documentation":"Traces entity bleed event."},{"declaration":"void TraceAttack(entvars_t@ pevAttacker, float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)","documentation":"Traces an attack by the given entity to this entity."},{"declaration":"bool KeyValue(const string& in szKeyName, const string& in szValue)","documentation":"Sets keyvalue data on this entity"},{"declaration":"void SetOrigin(const Vector& in vecOrigin)","documentation":"Sets this entity's (absolute) origin"},{"declaration":"const Vector& GetOrigin() const","documentation":"Gets the entity's (absolute) origin."},{"declaration":"CBaseEntity@ opImplCast()","documentation":"Implicitly casts to base type."},{"declaration":"CBeam@ opImplCast()","documentation":"Implicitly casts to base type."}],"properties":[{"namespace":"","declaration":"Vector m_vecOriginalRenderColor","documentation":"Original render color."},{"namespace":"","declaration":"float m_flOriginalRenderAmount","documentation":"Original render amount."},{"namespace":"","declaration":"int m_iOriginalRenderFX","documentation":"Original render FX."},{"namespace":"","declaration":"int m_iOriginalRenderMode","documentation":"Original render model."},{"namespace":"","declaration":"string_t classnameInFilterType","documentation":"Class name in filter type."},{"namespace":"","declaration":"string_t targetnameInFilterType","documentation":"Target name in filter type."},{"namespace":"","declaration":"string_t classnameOutFilterType","documentation":"Class name out filter type."},{"namespace":"","declaration":"string_t targetnameOutFilterType","documentation":"Target name out filter type."},{"namespace":"","declaration":"Vector m_vecLastOrigin","documentation":"Last origin vector"},{"namespace":"","declaration":"bool m_fCustomModel","documentation":"Whether a custom model is used."},{"namespace":"","declaration":"bool m_fCanFadeStart","documentation":"Whether fading can start."},{"namespace":"","declaration":"float m_flMaximumFadeWaitB","documentation":"Maximum fade wait time B."},{"namespace":"","declaration":"float m_flMaximumFadeWait","documentation":"Maximum fade wait time."},{"namespace":"","declaration":"int m_iClassSelection","documentation":"The overridden classification."},{"namespace":"","declaration":"bool m_fOverrideClass","documentation":"Whether this entity overrides the classification."},{"namespace":"","declaration":"entvars_t@ pev","documentation":"Entity variables"}],"className":"CLaser","documentation":"Laser class","namespace":""},{"flags":262145,"methods":[{"declaration":"CLaser@ opCast()","documentation":"Explicitly casts to sub type."},{"declaration":"void XenTeleport(const Vector& in vecSrc, int iRadius = 256)","documentation":"Creates a Xen teleport effect at the given location, with zaps occuring within the given radius."},{"declaration":"void XenTeleportZap(const Vector& in vecSrc, const Vector& in vecDest)","documentation":"Creates a Xen teleport zap effect between the given points."},{"declaration":"void BeamDamageInstant(TraceResult& in tr, float flDamage)","documentation":"Causes the given amount of damage to be done to the entity hit by the given traceresult, as if the damage occured one second ago."},{"declaration":"void LiveForTime(float flTime)","documentation":"Sets this beam to live for the given amount of time, after which it is removed."},{"declaration":"void HoseInit(const Vector& in vecStart, const Vector& in vecDirection)","documentation":"Initializes this beam to be a beam going from a point in a given direction (BEAM_HOSE)."},{"declaration":"void EntsInit(CBaseEntity@ pEntStart, CBaseEntity@ pEntEnd)","documentation":"Initializes this beam to be a beam between 2 given entities (BEAM_ENTS)."},{"declaration":"void EntsInit(int startIndex, int endIndex)","documentation":"Initializes this beam to be a beam between 2 given entities (BEAM_ENTS)."},{"declaration":"void PointEntInit(const Vector& in vecStart, CBaseEntity@ pEntEnd)","documentation":"Initializes this beam to be a beam between a point and an entity (BEAM_ENTPOINT)."},{"declaration":"void PointEntInit(const Vector& in vecStart, int endIndex)","documentation":"Initializes this beam to be a beam between a point and an entity (BEAM_ENTPOINT)."},{"declaration":"void PointsInit(const Vector& in vecStart, const Vector& in vecEnd)","documentation":"Initializes this beam to be a beam between 2 given points (BEAM_POINTS)."},{"declaration":"void BeamInit(const string& in szSpriteName, int iWidth)","documentation":"Initializes this beam with default values and sets the given sprite as the sprite used, with the given width."},{"declaration":"void BeamDamage(TraceResult& in tr)","documentation":"Damages the entity hit by the given trace line with the amount set in this entity's pev->dmg variable.<br/>Also applies decals to BSP models if the appropriate spawnflag is set."},{"declaration":"void DoSparks(const Vector& in vecStart, const Vector& in vecEnd)","documentation":"Creates sparks at the given start and end points, if appropriate spawn flags are set."},{"declaration":"void RelinkBeam()","documentation":"Call after you change start/end positions."},{"declaration":"int GetScrollRate()","documentation":"Gets the beam's scroll rate."},{"declaration":"int GetFrame()","documentation":"Gets the beam's frame number."},{"declaration":"int GetBrightness()","documentation":"Gets the beam's brightness."},{"declaration":"void GetColor(int& out r, int& out g, int& out b)","documentation":"Gets the beam's color."},{"declaration":"int GetNoise()","documentation":"Gets the beam's noise."},{"declaration":"int GetWidth()","documentation":"Gets the beam's width."},{"declaration":"int GetTexture()","documentation":"Gets the beam's texture (sprite) index."},{"declaration":"const Vector& GetEndPos()","documentation":"Gets the beam's ending position."},{"declaration":"const Vector& GetStartPos()","documentation":"Gets the beam's starting position."},{"declaration":"void SetScrollRate(int speed)","documentation":"Sets the scroll rate of the beam."},{"declaration":"void SetFrame(float frame)","documentation":"Sets the frame number of the beam."},{"declaration":"void SetBrightness(int brightness)","documentation":"Sets the brightness of the beam. Value is between 0-255."},{"declaration":"void SetColor(int r, int g, int b)","documentation":"Sets the color of the beam."},{"declaration":"void SetNoise(int iAmplitude)","documentation":"Sets the noise (amplitude) of the beam."},{"declaration":"void SetWidth(int iWidth)","documentation":"Sets the width of the beam."},{"declaration":"void SetTexture(int spriteIndex)","documentation":"Sets the sprite to use. The index is the one returned from CGame::PrecacheModel."},{"declaration":"void SetEndAttachment(int attachment)","documentation":"Sets the end attachment of the beam. Attachment is a point on the entity's model. Must be a beam of type BEAM_ENTS or BEAM_ENTPOINT. Set to 0 to disable."},{"declaration":"void SetStartAttachment(int attachment)","documentation":"Sets the start attachment of the beam. Attachment is a point on the entity's model. Must be a beam of type BEAM_ENTS. Set to 0 to disable."},{"declaration":"void SetEndEntity(CBaseEntity@ pEntity)","documentation":"Sets the ending entity of the beam. Must be a beam of type BEAM_ENTS or BEAM_ENTPOINT."},{"declaration":"void SetEndEntity(int entityIndex)","documentation":"Sets the ending entity of the beam. Must be a beam of type BEAM_ENTS or BEAM_ENTPOINT."},{"declaration":"void SetStartEntity(CBaseEntity@ pEntity)","documentation":"Sets the starting entity of the beam. Must be a beam of type BEAM_ENTS."},{"declaration":"void SetStartEntity(int entityIndex)","documentation":"Sets the starting entity of the beam. Must be a beam of type BEAM_ENTS."},{"declaration":"void SetEndPos(const Vector& in vecPos)","documentation":"Sets the ending position of the beam. Must be a beam of type BEAM_POINTS or BEAM_HOSE."},{"declaration":"void SetStartPos(const Vector& in vecPos)","documentation":"Sets the starting position of the beam. Must be a beam of type BEAM_POINTS, BEAM_ENTPOINT or BEAM_HOSE."},{"declaration":"void SetFlags(int flags)","documentation":"Sets the flags of the beam. Must be a combination of BeamFlags values, or 0."},{"declaration":"void SetType(BeamType type)","documentation":"Sets the type of the beam."},{"declaration":"void ClearUserData()","documentation":"Clears the user data on this entity. WARNING: clears all data.<br/>Only map scripts can use this."},{"declaration":"dictionaryValue& GetUserData(const string& in szKey)","documentation":"Gets the user data stored under the specified key on this entity.<br/>Do not keep references to this data, the object might be removed from this entity.<br/>Only map scripts can use this."},{"declaration":"dictionary@ GetUserData()","documentation":"Gets the user data on this entity. Do not keep references to this data, the object might be removed from this entity.<br/>Only map scripts can use this."},{"declaration":"void EndRevive(float flTimeUntilRevive)","documentation":"Called when this entity should be revived. flTimeUntilRevive is the time until the revival should start."},{"declaration":"void BeginRevive(float flTimeUntilRevive)","documentation":"Prepares this entity for revival. flTimeUntilRevive is the time until the revive action completes."},{"declaration":"bool IsRevivable()","documentation":"Returns whether this entity is revivable at this time."},{"declaration":"void OnDestroy()","documentation":"Entity destructor."},{"declaration":"void OnCreate()","documentation":"Entity constructor."},{"declaration":"void GetDamagePoints(entvars_t@ pevAttacker, entvars_t@ pevInflictor, float flDamage)","documentation":"Adds damage points to the inflicting entity."},{"declaration":"float GetPointsForDamage(float flDamage)","documentation":"Returns the points received for damage done."},{"declaration":"bool IsFacing(entvars_t@ pevTest, float flDotProduct = VIEW_FIELD_ULTRA_NARROW)","documentation":"Returns whether this entity is facing the given entity, within the given view field."},{"declaration":"bool FVisible(const Vector& in vecOrigin)","documentation":"Returns whether this entity is visible from the given origin."},{"declaration":"bool FVisible(CBaseEntity@ pEntity, bool fIgnoreGlass)","documentation":"Returns whether this entity is visible to the given entity."},{"declaration":"int Illumination()","documentation":"Returns this entity's illumination."},{"declaration":"Vector BodyTarget(const Vector& in posSrc)","documentation":"Returns this entity's body target for shooting."},{"declaration":"Vector EarPosition()","documentation":"Returns this entity's ear position."},{"declaration":"Vector EyePosition()","documentation":"Returns this entity's eye position."},{"declaration":"Vector Center()","documentation":"Returns this entity's center."},{"declaration":"bool FBecomeProne()","documentation":"Makes this entity become prone."},{"declaration":"CBaseEntity@ Respawn()","documentation":"Respawns this entity."},{"declaration":"void UpdateOnRemove()","documentation":"Updates this entity when removed."},{"declaration":"void Blocked(CBaseEntity@ pOther)","documentation":"Triggers this entity's blocked function."},{"declaration":"void Use(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f)","documentation":"Trigger's this entity's use function."},{"declaration":"void Touch(CBaseEntity@ pOther)","documentation":"Triggers this entity's touch function."},{"declaration":"void Think()","documentation":"Makes this entity think. Do not call directly."},{"declaration":"CBaseEntity@ GetNextTarget()","documentation":"Gets the next target to trigger."},{"declaration":"bool CriticalRemove()","documentation":"Removes this entity in critical situations."},{"declaration":"bool IsMachine()","documentation":"Returns whether this is a machine."},{"declaration":"bool IsPointEnt()","documentation":"Returns whether this is a point entity."},{"declaration":"bool IsNetClient()","documentation":"Returns whether this is a net client."},{"declaration":"bool IsPlayer()","documentation":"Returns whether this entity is a player."},{"declaration":"bool IsMonster()","documentation":"Returns whether this entity is a monster."},{"declaration":"bool IsInWorld()","documentation":"Returns whether this entity is in the world."},{"declaration":"bool ReflectGauss()","documentation":"Returns whether this entity reflects gauss shots."},{"declaration":"bool IsBSPModel()","documentation":"Returns whether this entity is a BSP model."},{"declaration":"bool IsAlive()","documentation":"Returns whether this entity is alive."},{"declaration":"bool IsSneaking()","documentation":"Returns whether this entity is sneaking."},{"declaration":"bool OnControls(entvars_t@ pev)","documentation":"Reacts to controls set on the pev."},{"declaration":"void StopSneaking()","documentation":"Stops sneaking."},{"declaration":"void StartSneaking()","documentation":"Starts sneaking."},{"declaration":"void SetToggleState(int state)","documentation":"Sets this entity's toggle state."},{"declaration":"int DamageDecal(int bitsDamageType)","documentation":"Returns the damage decal<br/>See decal_e."},{"declaration":"void OverrideReset()","documentation":"Resets this entity."},{"declaration":"bool IsMoving()","documentation":"Returns whether this entity is moving."},{"declaration":"float GetDelay()","documentation":"Gets this entity's trigger delay."},{"declaration":"bool RemovePlayerItem(CBasePlayerItem@ pItem)","documentation":"Removes the given player item to this entity."},{"declaration":"AddPlayerItemResult AddPlayerItem(CBasePlayerItem@ pItem)","documentation":"Adds the given player item to this entity."},{"declaration":"void AddPointsToTeam(int score, const bool bAllowNegativeScore)","documentation":"Adds points to this entity's team."},{"declaration":"void AddPoints(int score, const bool bAllowNegativeScore)","documentation":"Adds points to this entity."},{"declaration":"int GetToggleState()","documentation":"Gets the toggle state.<br/>See the TOGGLE_STATE enum."},{"declaration":"bool SetupModel()","documentation":"Sets up the model."},{"declaration":"int entindex()","documentation":"Returns this entity's index."},{"declaration":"edict_t@ edict()","documentation":"Returns this entity's edict."},{"declaration":"bool IsLockedByMaster()","documentation":"Returns whether this entity is locked by its master."},{"declaration":"bool IsDormant()","documentation":"Returns whether this entity is dormant."},{"declaration":"void MakeDormant()","documentation":"Makes this entity dormant."},{"declaration":"bool Intersects(CBaseEntity@ pOther)","documentation":"Returns whether this entity intersects with the given entity."},{"declaration":"void SUB_UseTargets(CBaseEntity@ pActivator, USE_TYPE useType, float flValue)","documentation":"Calls use on targets."},{"declaration":"void FireBullets(uint cShots, Vector vecSrc, Vector vecDirShooting, Vector vecSpread,float flDistance, Bullet iBulletType, int iTracerFreq = 4, int iDamage = 0, entvars_t@ pevAttacker = null, FireBulletsDrawMode fDraw = FBDM_DRAW)","documentation":"Fires bullets. Must call CMath::MakeAimVectors with an angle vector first."},{"declaration":"bool ShouldToggle(USE_TYPE useType, const bool currentState)","documentation":"Returns whether this entity should toggle."},{"declaration":"void SUB_CallUseToggle()","documentation":"Think function. Calls use toggle on this entity."},{"declaration":"void SUB_FadeOut()","documentation":"Think function. Fades this entity."},{"declaration":"void SUB_StartFadeOut()","documentation":"Think function. Starts fading this entity."},{"declaration":"void SUB_DoNothing()","documentation":"Think function. Explicitly does nothing."},{"declaration":"void SUB_Remove()","documentation":"Think function. Delay-removes this entity."},{"declaration":"bool BlockedByEntity(CBaseEntity@ pOther, float flDamage)","documentation":"Returns true if you should be blocked by the entity, false otherwise. Also deals blocking damage to the entity, if applicable."},{"declaration":"CustomKeyvalues@ GetCustomKeyvalues()","documentation":"Gets this entity's custom keyvalues."},{"declaration":"CBaseMonster@ MyMonsterPointer()","documentation":"Returns this entity as its monster entity, if it is a monster."},{"declaration":"bool IsTriggered(CBaseEntity@ pActivator)","documentation":"Returns whether this entity is triggered by the given entity."},{"declaration":"int BloodColor()","documentation":"Returns the blood color. See the BLOOD_COLOR enum."},{"declaration":"void Killed(entvars_t@pevAtttacker, int iGibbed)","documentation":"Tells this entity it's been killed. See the GIB enum for possible values."},{"declaration":"bool TakeArmor(float flArmor, int bitsDamageType, int armor_cap = 0)","documentation":"Takes armor from this entity. Note: flArmor is added to entity armor. Use negative values to subtract.If armor_cap is non-zero, won't add more than armor_cap. Returns 1 if it took damage, 0 otherwise."},{"declaration":"bool TakeHealth(float flHealth, int bitsDamageType, int health_cap = 0)","documentation":"Takes health from this entity. Note: flHealth is added to entity health. Use negative values to subtract.If health_cap is non-zero, won't add more than health_cap. Returns true if it took damage, false otherwise."},{"declaration":"int TakeDamage(entvars_t@ pevInflictor, entvars_t@ pevAttacker, float flDamage, int bitsDamageType)","documentation":"Causes this entity to take damage. Returns 1 if it took damage, 0 otherwise."},{"declaration":"int Classify()","documentation":"Gets this entity's classification."},{"declaration":"int IRelationshipByClass(CLASS iClass)","documentation":"Gets the relationship between this entity and the given entity classification. See the RELATIONSHIP enum."},{"declaration":"int IRelationship(CBaseEntity@ other)","documentation":"Gets the relationship between this entity and the given entity. See the RELATIONSHIP enum."},{"declaration":"void ClearClassification()","documentation":"Clears this entity's classification override."},{"declaration":"void SetClassificationFromEntity(CBaseEntity@ pEntity)","documentation":"Sets this entity's classification override to the classification override set on the given entity. Can override the entity's player ally setting."},{"declaration":"void SetClassification(int cl)","documentation":"Sets this entity's classification override. Can override the entity's player ally setting."},{"declaration":"int GetClassification(int cl)","documentation":"Gets this entity's classification. Returns the given value if none is set. See the CLASSIFICATION enum."},{"declaration":"void SetObjectCollisionBox()","documentation":"Sets up the object collision box."},{"declaration":"int ObjectCaps()","documentation":"Gets this entity's objects caps. See the FCAP enum."},{"declaration":"void Precache()","documentation":"Precaches the entity. Do not call directly."},{"declaration":"bool opEquals(CBaseEntity@ pOther)","documentation":"Compares 2 entities for equality."},{"declaration":"void SetPlayerAllyDirect(bool fState)","documentation":"Sets this entity's player ally status.</br>Use this only if you need the setting to be exactly what you give it (e.g. when copying from another monster)"},{"declaration":"void SetPlayerAlly(bool fState)","documentation":"Sets this entity's player ally status."},{"declaration":"bool IsPlayerAlly() const","documentation":"Returns whether this entity is allied to players."},{"declaration":"int FindMonstersInWorld(array<CBaseEntity@>@ pArray, int flagMask)","documentation":"Finds monsters in the world"},{"declaration":"string SOUNDREPLACEMENT_Find(const string& in szFilename)","documentation":"Find sound replacement for the given file."},{"declaration":"bool FVisibleFromPos(const Vector& in vecTarget, const Vector& in vecStart)","documentation":"Returns whether this entity is visible from the given position."},{"declaration":"string GetTargetname() const","documentation":"Returns this entity's target name."},{"declaration":"string GetClassname() const","documentation":"Returns this entity's class name."},{"declaration":"string TeamID()","documentation":"Returns this entity's team ID."},{"declaration":"bool HasTarget(const string& in szTarget)","documentation":"Returns whether this entity has the given target."},{"declaration":"int GiveAmmo(int iAmount, const string& in szName, int iMax, const bool fFromWeapon = true)","documentation":"Gives ammo to this entity."},{"declaration":"void TraceBleed(float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)","documentation":"Traces entity bleed event."},{"declaration":"void TraceAttack(entvars_t@ pevAttacker, float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)","documentation":"Traces an attack by the given entity to this entity."},{"declaration":"bool KeyValue(const string& in szKeyName, const string& in szValue)","documentation":"Sets keyvalue data on this entity"},{"declaration":"void SetOrigin(const Vector& in vecOrigin)","documentation":"Sets this entity's (absolute) origin"},{"declaration":"const Vector& GetOrigin() const","documentation":"Gets the entity's (absolute) origin."},{"declaration":"CBaseEntity@ opImplCast()","documentation":"Implicitly casts to base type."}],"properties":[{"namespace":"","declaration":"Vector m_vecOriginalRenderColor","documentation":"Original render color."},{"namespace":"","declaration":"float m_flOriginalRenderAmount","documentation":"Original render amount."},{"namespace":"","declaration":"int m_iOriginalRenderFX","documentation":"Original render FX."},{"namespace":"","declaration":"int m_iOriginalRenderMode","documentation":"Original render model."},{"namespace":"","declaration":"string_t classnameInFilterType","documentation":"Class name in filter type."},{"namespace":"","declaration":"string_t targetnameInFilterType","documentation":"Target name in filter type."},{"namespace":"","declaration":"string_t classnameOutFilterType","documentation":"Class name out filter type."},{"namespace":"","declaration":"string_t targetnameOutFilterType","documentation":"Target name out filter type."},{"namespace":"","declaration":"Vector m_vecLastOrigin","documentation":"Last origin vector"},{"namespace":"","declaration":"bool m_fCustomModel","documentation":"Whether a custom model is used."},{"namespace":"","declaration":"bool m_fCanFadeStart","documentation":"Whether fading can start."},{"namespace":"","declaration":"float m_flMaximumFadeWaitB","documentation":"Maximum fade wait time B."},{"namespace":"","declaration":"float m_flMaximumFadeWait","documentation":"Maximum fade wait time."},{"namespace":"","declaration":"int m_iClassSelection","documentation":"The overridden classification."},{"namespace":"","declaration":"bool m_fOverrideClass","documentation":"Whether this entity overrides the classification."},{"namespace":"","declaration":"entvars_t@ pev","documentation":"Entity variables"}],"className":"CBeam","documentation":"Beam class","namespace":""},{"flags":262145,"methods":[{"declaration":"CPathTrack@ GetPrevious()","documentation":""},{"declaration":"CPathTrack@ GetNext()","documentation":""},{"declaration":"CPathTrack@ Nearest(Vector vecOrigin)","documentation":""},{"declaration":"CPathTrack@ LookAhead(Vector& in vecOrigin, Vector& out vecResultOrigin, float flDist, const bool bMove)","documentation":""},{"declaration":"void Project(CPathTrack@ pStart, CPathTrack@ pEnd, Vector& out vecOrigin, float flDist)","documentation":""},{"declaration":"CPathTrack@ ValidPath(CPathTrack@ pPath, const bool testFlag)","documentation":"Returns pPath if enabled, null otherwise."},{"declaration":"void Link()","documentation":"Links the tracks together"},{"declaration":"void SetPrevious(CPathTrack@ pPrevious)","documentation":"Sets the previous track in this path"},{"declaration":"void ClearUserData()","documentation":"Clears the user data on this entity. WARNING: clears all data.<br/>Only map scripts can use this."},{"declaration":"dictionaryValue& GetUserData(const string& in szKey)","documentation":"Gets the user data stored under the specified key on this entity.<br/>Do not keep references to this data, the object might be removed from this entity.<br/>Only map scripts can use this."},{"declaration":"dictionary@ GetUserData()","documentation":"Gets the user data on this entity. Do not keep references to this data, the object might be removed from this entity.<br/>Only map scripts can use this."},{"declaration":"void EndRevive(float flTimeUntilRevive)","documentation":"Called when this entity should be revived. flTimeUntilRevive is the time until the revival should start."},{"declaration":"void BeginRevive(float flTimeUntilRevive)","documentation":"Prepares this entity for revival. flTimeUntilRevive is the time until the revive action completes."},{"declaration":"bool IsRevivable()","documentation":"Returns whether this entity is revivable at this time."},{"declaration":"void OnDestroy()","documentation":"Entity destructor."},{"declaration":"void OnCreate()","documentation":"Entity constructor."},{"declaration":"void GetDamagePoints(entvars_t@ pevAttacker, entvars_t@ pevInflictor, float flDamage)","documentation":"Adds damage points to the inflicting entity."},{"declaration":"float GetPointsForDamage(float flDamage)","documentation":"Returns the points received for damage done."},{"declaration":"bool IsFacing(entvars_t@ pevTest, float flDotProduct = VIEW_FIELD_ULTRA_NARROW)","documentation":"Returns whether this entity is facing the given entity, within the given view field."},{"declaration":"bool FVisible(const Vector& in vecOrigin)","documentation":"Returns whether this entity is visible from the given origin."},{"declaration":"bool FVisible(CBaseEntity@ pEntity, bool fIgnoreGlass)","documentation":"Returns whether this entity is visible to the given entity."},{"declaration":"int Illumination()","documentation":"Returns this entity's illumination."},{"declaration":"Vector BodyTarget(const Vector& in posSrc)","documentation":"Returns this entity's body target for shooting."},{"declaration":"Vector EarPosition()","documentation":"Returns this entity's ear position."},{"declaration":"Vector EyePosition()","documentation":"Returns this entity's eye position."},{"declaration":"Vector Center()","documentation":"Returns this entity's center."},{"declaration":"bool FBecomeProne()","documentation":"Makes this entity become prone."},{"declaration":"CBaseEntity@ Respawn()","documentation":"Respawns this entity."},{"declaration":"void UpdateOnRemove()","documentation":"Updates this entity when removed."},{"declaration":"void Blocked(CBaseEntity@ pOther)","documentation":"Triggers this entity's blocked function."},{"declaration":"void Use(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f)","documentation":"Trigger's this entity's use function."},{"declaration":"void Touch(CBaseEntity@ pOther)","documentation":"Triggers this entity's touch function."},{"declaration":"void Think()","documentation":"Makes this entity think. Do not call directly."},{"declaration":"CBaseEntity@ GetNextTarget()","documentation":"Gets the next target to trigger."},{"declaration":"bool CriticalRemove()","documentation":"Removes this entity in critical situations."},{"declaration":"bool IsMachine()","documentation":"Returns whether this is a machine."},{"declaration":"bool IsPointEnt()","documentation":"Returns whether this is a point entity."},{"declaration":"bool IsNetClient()","documentation":"Returns whether this is a net client."},{"declaration":"bool IsPlayer()","documentation":"Returns whether this entity is a player."},{"declaration":"bool IsMonster()","documentation":"Returns whether this entity is a monster."},{"declaration":"bool IsInWorld()","documentation":"Returns whether this entity is in the world."},{"declaration":"bool ReflectGauss()","documentation":"Returns whether this entity reflects gauss shots."},{"declaration":"bool IsBSPModel()","documentation":"Returns whether this entity is a BSP model."},{"declaration":"bool IsAlive()","documentation":"Returns whether this entity is alive."},{"declaration":"bool IsSneaking()","documentation":"Returns whether this entity is sneaking."},{"declaration":"bool OnControls(entvars_t@ pev)","documentation":"Reacts to controls set on the pev."},{"declaration":"void StopSneaking()","documentation":"Stops sneaking."},{"declaration":"void StartSneaking()","documentation":"Starts sneaking."},{"declaration":"void SetToggleState(int state)","documentation":"Sets this entity's toggle state."},{"declaration":"int DamageDecal(int bitsDamageType)","documentation":"Returns the damage decal<br/>See decal_e."},{"declaration":"void OverrideReset()","documentation":"Resets this entity."},{"declaration":"bool IsMoving()","documentation":"Returns whether this entity is moving."},{"declaration":"float GetDelay()","documentation":"Gets this entity's trigger delay."},{"declaration":"bool RemovePlayerItem(CBasePlayerItem@ pItem)","documentation":"Removes the given player item to this entity."},{"declaration":"AddPlayerItemResult AddPlayerItem(CBasePlayerItem@ pItem)","documentation":"Adds the given player item to this entity."},{"declaration":"void AddPointsToTeam(int score, const bool bAllowNegativeScore)","documentation":"Adds points to this entity's team."},{"declaration":"void AddPoints(int score, const bool bAllowNegativeScore)","documentation":"Adds points to this entity."},{"declaration":"int GetToggleState()","documentation":"Gets the toggle state.<br/>See the TOGGLE_STATE enum."},{"declaration":"bool SetupModel()","documentation":"Sets up the model."},{"declaration":"int entindex()","documentation":"Returns this entity's index."},{"declaration":"edict_t@ edict()","documentation":"Returns this entity's edict."},{"declaration":"bool IsLockedByMaster()","documentation":"Returns whether this entity is locked by its master."},{"declaration":"bool IsDormant()","documentation":"Returns whether this entity is dormant."},{"declaration":"void MakeDormant()","documentation":"Makes this entity dormant."},{"declaration":"bool Intersects(CBaseEntity@ pOther)","documentation":"Returns whether this entity intersects with the given entity."},{"declaration":"void SUB_UseTargets(CBaseEntity@ pActivator, USE_TYPE useType, float flValue)","documentation":"Calls use on targets."},{"declaration":"void FireBullets(uint cShots, Vector vecSrc, Vector vecDirShooting, Vector vecSpread,float flDistance, Bullet iBulletType, int iTracerFreq = 4, int iDamage = 0, entvars_t@ pevAttacker = null, FireBulletsDrawMode fDraw = FBDM_DRAW)","documentation":"Fires bullets. Must call CMath::MakeAimVectors with an angle vector first."},{"declaration":"bool ShouldToggle(USE_TYPE useType, const bool currentState)","documentation":"Returns whether this entity should toggle."},{"declaration":"void SUB_CallUseToggle()","documentation":"Think function. Calls use toggle on this entity."},{"declaration":"void SUB_FadeOut()","documentation":"Think function. Fades this entity."},{"declaration":"void SUB_StartFadeOut()","documentation":"Think function. Starts fading this entity."},{"declaration":"void SUB_DoNothing()","documentation":"Think function. Explicitly does nothing."},{"declaration":"void SUB_Remove()","documentation":"Think function. Delay-removes this entity."},{"declaration":"bool BlockedByEntity(CBaseEntity@ pOther, float flDamage)","documentation":"Returns true if you should be blocked by the entity, false otherwise. Also deals blocking damage to the entity, if applicable."},{"declaration":"CustomKeyvalues@ GetCustomKeyvalues()","documentation":"Gets this entity's custom keyvalues."},{"declaration":"CBaseMonster@ MyMonsterPointer()","documentation":"Returns this entity as its monster entity, if it is a monster."},{"declaration":"bool IsTriggered(CBaseEntity@ pActivator)","documentation":"Returns whether this entity is triggered by the given entity."},{"declaration":"int BloodColor()","documentation":"Returns the blood color. See the BLOOD_COLOR enum."},{"declaration":"void Killed(entvars_t@pevAtttacker, int iGibbed)","documentation":"Tells this entity it's been killed. See the GIB enum for possible values."},{"declaration":"bool TakeArmor(float flArmor, int bitsDamageType, int armor_cap = 0)","documentation":"Takes armor from this entity. Note: flArmor is added to entity armor. Use negative values to subtract.If armor_cap is non-zero, won't add more than armor_cap. Returns 1 if it took damage, 0 otherwise."},{"declaration":"bool TakeHealth(float flHealth, int bitsDamageType, int health_cap = 0)","documentation":"Takes health from this entity. Note: flHealth is added to entity health. Use negative values to subtract.If health_cap is non-zero, won't add more than health_cap. Returns true if it took damage, false otherwise."},{"declaration":"int TakeDamage(entvars_t@ pevInflictor, entvars_t@ pevAttacker, float flDamage, int bitsDamageType)","documentation":"Causes this entity to take damage. Returns 1 if it took damage, 0 otherwise."},{"declaration":"int Classify()","documentation":"Gets this entity's classification."},{"declaration":"int IRelationshipByClass(CLASS iClass)","documentation":"Gets the relationship between this entity and the given entity classification. See the RELATIONSHIP enum."},{"declaration":"int IRelationship(CBaseEntity@ other)","documentation":"Gets the relationship between this entity and the given entity. See the RELATIONSHIP enum."},{"declaration":"void ClearClassification()","documentation":"Clears this entity's classification override."},{"declaration":"void SetClassificationFromEntity(CBaseEntity@ pEntity)","documentation":"Sets this entity's classification override to the classification override set on the given entity. Can override the entity's player ally setting."},{"declaration":"void SetClassification(int cl)","documentation":"Sets this entity's classification override. Can override the entity's player ally setting."},{"declaration":"int GetClassification(int cl)","documentation":"Gets this entity's classification. Returns the given value if none is set. See the CLASSIFICATION enum."},{"declaration":"void SetObjectCollisionBox()","documentation":"Sets up the object collision box."},{"declaration":"int ObjectCaps()","documentation":"Gets this entity's objects caps. See the FCAP enum."},{"declaration":"void Precache()","documentation":"Precaches the entity. Do not call directly."},{"declaration":"bool opEquals(CBaseEntity@ pOther)","documentation":"Compares 2 entities for equality."},{"declaration":"void SetPlayerAllyDirect(bool fState)","documentation":"Sets this entity's player ally status.</br>Use this only if you need the setting to be exactly what you give it (e.g. when copying from another monster)"},{"declaration":"void SetPlayerAlly(bool fState)","documentation":"Sets this entity's player ally status."},{"declaration":"bool IsPlayerAlly() const","documentation":"Returns whether this entity is allied to players."},{"declaration":"int FindMonstersInWorld(array<CBaseEntity@>@ pArray, int flagMask)","documentation":"Finds monsters in the world"},{"declaration":"string SOUNDREPLACEMENT_Find(const string& in szFilename)","documentation":"Find sound replacement for the given file."},{"declaration":"bool FVisibleFromPos(const Vector& in vecTarget, const Vector& in vecStart)","documentation":"Returns whether this entity is visible from the given position."},{"declaration":"string GetTargetname() const","documentation":"Returns this entity's target name."},{"declaration":"string GetClassname() const","documentation":"Returns this entity's class name."},{"declaration":"string TeamID()","documentation":"Returns this entity's team ID."},{"declaration":"bool HasTarget(const string& in szTarget)","documentation":"Returns whether this entity has the given target."},{"declaration":"int GiveAmmo(int iAmount, const string& in szName, int iMax, const bool fFromWeapon = true)","documentation":"Gives ammo to this entity."},{"declaration":"void TraceBleed(float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)","documentation":"Traces entity bleed event."},{"declaration":"void TraceAttack(entvars_t@ pevAttacker, float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)","documentation":"Traces an attack by the given entity to this entity."},{"declaration":"bool KeyValue(const string& in szKeyName, const string& in szValue)","documentation":"Sets keyvalue data on this entity"},{"declaration":"void SetOrigin(const Vector& in vecOrigin)","documentation":"Sets this entity's (absolute) origin"},{"declaration":"const Vector& GetOrigin() const","documentation":"Gets the entity's (absolute) origin."},{"declaration":"CBaseEntity@ opImplCast()","documentation":"Implicitly casts to base type."}],"properties":[{"namespace":"","declaration":"CPathTrack@ m_paltpath","documentation":""},{"namespace":"","declaration":"CPathTrack@ m_pprevious","documentation":""},{"namespace":"","declaration":"CPathTrack@ m_pnext","documentation":""},{"namespace":"","declaration":"string_t m_altName","documentation":""},{"namespace":"","declaration":"float m_length","documentation":""},{"namespace":"","declaration":"Vector m_vecOriginalRenderColor","documentation":"Original render color."},{"namespace":"","declaration":"float m_flOriginalRenderAmount","documentation":"Original render amount."},{"namespace":"","declaration":"int m_iOriginalRenderFX","documentation":"Original render FX."},{"namespace":"","declaration":"int m_iOriginalRenderMode","documentation":"Original render model."},{"namespace":"","declaration":"string_t classnameInFilterType","documentation":"Class name in filter type."},{"namespace":"","declaration":"string_t targetnameInFilterType","documentation":"Target name in filter type."},{"namespace":"","declaration":"string_t classnameOutFilterType","documentation":"Class name out filter type."},{"namespace":"","declaration":"string_t targetnameOutFilterType","documentation":"Target name out filter type."},{"namespace":"","declaration":"Vector m_vecLastOrigin","documentation":"Last origin vector"},{"namespace":"","declaration":"bool m_fCustomModel","documentation":"Whether a custom model is used."},{"namespace":"","declaration":"bool m_fCanFadeStart","documentation":"Whether fading can start."},{"namespace":"","declaration":"float m_flMaximumFadeWaitB","documentation":"Maximum fade wait time B."},{"namespace":"","declaration":"float m_flMaximumFadeWait","documentation":"Maximum fade wait time."},{"namespace":"","declaration":"int m_iClassSelection","documentation":"The overridden classification."},{"namespace":"","declaration":"bool m_fOverrideClass","documentation":"Whether this entity overrides the classification."},{"namespace":"","declaration":"entvars_t@ pev","documentation":"Entity variables"}],"className":"CPathTrack","documentation":"Path track class","namespace":""},{"flags":262145,"methods":[{"declaration":"void AnimateAndDie(float flFramerate)","documentation":"Makes this sprite play until time pev->dmgtime has been passed, then removes itself."},{"declaration":"void SetBrightness(int brightness)","documentation":"Sets the brightness (render amount)."},{"declaration":"void SetColor(int r, int g, int b)","documentation":"Sets the color."},{"declaration":"void SetScale(float flScale)","documentation":"Sets the current scale."},{"declaration":"void SetTexture(int iSpriteIndex)","documentation":"Sets the texture used by this sprite. Is a model index returned by g_Game.PrecacheModel."},{"declaration":"void SetTransparency(int renderMode, int r, int g, int b, int renderAmount, int renderFx)","documentation":"Sets the transparency of this sprite."},{"declaration":"float Frames() const","documentation":"Gets the number of frames in this sprite."},{"declaration":"void TurnOn()","documentation":"Turns on this sprite."},{"declaration":"void TurnOff()","documentation":"Turns off this sprite."},{"declaration":"void SetAttachment(edict_t@ pEntity, int iAttachment)","documentation":"Makes this sprite follow the given entity."},{"declaration":"void SpriteInit(const string& in szSpriteName, const Vector& in vecOrigin)","documentation":"Initializes this sprite."},{"declaration":"void Expand(float flScaleSpeed, float flFadeSpeed)","documentation":"Causes this sprite to scale up and fade at the given rates.<br/>This sprite will be removed once faded."},{"declaration":"void Animate(float flFrames)","documentation":"Advances this sprite's frame by the given amount of frames."},{"declaration":"void ClearUserData()","documentation":"Clears the user data on this entity. WARNING: clears all data.<br/>Only map scripts can use this."},{"declaration":"dictionaryValue& GetUserData(const string& in szKey)","documentation":"Gets the user data stored under the specified key on this entity.<br/>Do not keep references to this data, the object might be removed from this entity.<br/>Only map scripts can use this."},{"declaration":"dictionary@ GetUserData()","documentation":"Gets the user data on this entity. Do not keep references to this data, the object might be removed from this entity.<br/>Only map scripts can use this."},{"declaration":"void EndRevive(float flTimeUntilRevive)","documentation":"Called when this entity should be revived. flTimeUntilRevive is the time until the revival should start."},{"declaration":"void BeginRevive(float flTimeUntilRevive)","documentation":"Prepares this entity for revival. flTimeUntilRevive is the time until the revive action completes."},{"declaration":"bool IsRevivable()","documentation":"Returns whether this entity is revivable at this time."},{"declaration":"void OnDestroy()","documentation":"Entity destructor."},{"declaration":"void OnCreate()","documentation":"Entity constructor."},{"declaration":"void GetDamagePoints(entvars_t@ pevAttacker, entvars_t@ pevInflictor, float flDamage)","documentation":"Adds damage points to the inflicting entity."},{"declaration":"float GetPointsForDamage(float flDamage)","documentation":"Returns the points received for damage done."},{"declaration":"bool IsFacing(entvars_t@ pevTest, float flDotProduct = VIEW_FIELD_ULTRA_NARROW)","documentation":"Returns whether this entity is facing the given entity, within the given view field."},{"declaration":"bool FVisible(const Vector& in vecOrigin)","documentation":"Returns whether this entity is visible from the given origin."},{"declaration":"bool FVisible(CBaseEntity@ pEntity, bool fIgnoreGlass)","documentation":"Returns whether this entity is visible to the given entity."},{"declaration":"int Illumination()","documentation":"Returns this entity's illumination."},{"declaration":"Vector BodyTarget(const Vector& in posSrc)","documentation":"Returns this entity's body target for shooting."},{"declaration":"Vector EarPosition()","documentation":"Returns this entity's ear position."},{"declaration":"Vector EyePosition()","documentation":"Returns this entity's eye position."},{"declaration":"Vector Center()","documentation":"Returns this entity's center."},{"declaration":"bool FBecomeProne()","documentation":"Makes this entity become prone."},{"declaration":"CBaseEntity@ Respawn()","documentation":"Respawns this entity."},{"declaration":"void UpdateOnRemove()","documentation":"Updates this entity when removed."},{"declaration":"void Blocked(CBaseEntity@ pOther)","documentation":"Triggers this entity's blocked function."},{"declaration":"void Use(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f)","documentation":"Trigger's this entity's use function."},{"declaration":"void Touch(CBaseEntity@ pOther)","documentation":"Triggers this entity's touch function."},{"declaration":"void Think()","documentation":"Makes this entity think. Do not call directly."},{"declaration":"CBaseEntity@ GetNextTarget()","documentation":"Gets the next target to trigger."},{"declaration":"bool CriticalRemove()","documentation":"Removes this entity in critical situations."},{"declaration":"bool IsMachine()","documentation":"Returns whether this is a machine."},{"declaration":"bool IsPointEnt()","documentation":"Returns whether this is a point entity."},{"declaration":"bool IsNetClient()","documentation":"Returns whether this is a net client."},{"declaration":"bool IsPlayer()","documentation":"Returns whether this entity is a player."},{"declaration":"bool IsMonster()","documentation":"Returns whether this entity is a monster."},{"declaration":"bool IsInWorld()","documentation":"Returns whether this entity is in the world."},{"declaration":"bool ReflectGauss()","documentation":"Returns whether this entity reflects gauss shots."},{"declaration":"bool IsBSPModel()","documentation":"Returns whether this entity is a BSP model."},{"declaration":"bool IsAlive()","documentation":"Returns whether this entity is alive."},{"declaration":"bool IsSneaking()","documentation":"Returns whether this entity is sneaking."},{"declaration":"bool OnControls(entvars_t@ pev)","documentation":"Reacts to controls set on the pev."},{"declaration":"void StopSneaking()","documentation":"Stops sneaking."},{"declaration":"void StartSneaking()","documentation":"Starts sneaking."},{"declaration":"void SetToggleState(int state)","documentation":"Sets this entity's toggle state."},{"declaration":"int DamageDecal(int bitsDamageType)","documentation":"Returns the damage decal<br/>See decal_e."},{"declaration":"void OverrideReset()","documentation":"Resets this entity."},{"declaration":"bool IsMoving()","documentation":"Returns whether this entity is moving."},{"declaration":"float GetDelay()","documentation":"Gets this entity's trigger delay."},{"declaration":"bool RemovePlayerItem(CBasePlayerItem@ pItem)","documentation":"Removes the given player item to this entity."},{"declaration":"AddPlayerItemResult AddPlayerItem(CBasePlayerItem@ pItem)","documentation":"Adds the given player item to this entity."},{"declaration":"void AddPointsToTeam(int score, const bool bAllowNegativeScore)","documentation":"Adds points to this entity's team."},{"declaration":"void AddPoints(int score, const bool bAllowNegativeScore)","documentation":"Adds points to this entity."},{"declaration":"int GetToggleState()","documentation":"Gets the toggle state.<br/>See the TOGGLE_STATE enum."},{"declaration":"bool SetupModel()","documentation":"Sets up the model."},{"declaration":"int entindex()","documentation":"Returns this entity's index."},{"declaration":"edict_t@ edict()","documentation":"Returns this entity's edict."},{"declaration":"bool IsLockedByMaster()","documentation":"Returns whether this entity is locked by its master."},{"declaration":"bool IsDormant()","documentation":"Returns whether this entity is dormant."},{"declaration":"void MakeDormant()","documentation":"Makes this entity dormant."},{"declaration":"bool Intersects(CBaseEntity@ pOther)","documentation":"Returns whether this entity intersects with the given entity."},{"declaration":"void SUB_UseTargets(CBaseEntity@ pActivator, USE_TYPE useType, float flValue)","documentation":"Calls use on targets."},{"declaration":"void FireBullets(uint cShots, Vector vecSrc, Vector vecDirShooting, Vector vecSpread,float flDistance, Bullet iBulletType, int iTracerFreq = 4, int iDamage = 0, entvars_t@ pevAttacker = null, FireBulletsDrawMode fDraw = FBDM_DRAW)","documentation":"Fires bullets. Must call CMath::MakeAimVectors with an angle vector first."},{"declaration":"bool ShouldToggle(USE_TYPE useType, const bool currentState)","documentation":"Returns whether this entity should toggle."},{"declaration":"void SUB_CallUseToggle()","documentation":"Think function. Calls use toggle on this entity."},{"declaration":"void SUB_FadeOut()","documentation":"Think function. Fades this entity."},{"declaration":"void SUB_StartFadeOut()","documentation":"Think function. Starts fading this entity."},{"declaration":"void SUB_DoNothing()","documentation":"Think function. Explicitly does nothing."},{"declaration":"void SUB_Remove()","documentation":"Think function. Delay-removes this entity."},{"declaration":"bool BlockedByEntity(CBaseEntity@ pOther, float flDamage)","documentation":"Returns true if you should be blocked by the entity, false otherwise. Also deals blocking damage to the entity, if applicable."},{"declaration":"CustomKeyvalues@ GetCustomKeyvalues()","documentation":"Gets this entity's custom keyvalues."},{"declaration":"CBaseMonster@ MyMonsterPointer()","documentation":"Returns this entity as its monster entity, if it is a monster."},{"declaration":"bool IsTriggered(CBaseEntity@ pActivator)","documentation":"Returns whether this entity is triggered by the given entity."},{"declaration":"int BloodColor()","documentation":"Returns the blood color. See the BLOOD_COLOR enum."},{"declaration":"void Killed(entvars_t@pevAtttacker, int iGibbed)","documentation":"Tells this entity it's been killed. See the GIB enum for possible values."},{"declaration":"bool TakeArmor(float flArmor, int bitsDamageType, int armor_cap = 0)","documentation":"Takes armor from this entity. Note: flArmor is added to entity armor. Use negative values to subtract.If armor_cap is non-zero, won't add more than armor_cap. Returns 1 if it took damage, 0 otherwise."},{"declaration":"bool TakeHealth(float flHealth, int bitsDamageType, int health_cap = 0)","documentation":"Takes health from this entity. Note: flHealth is added to entity health. Use negative values to subtract.If health_cap is non-zero, won't add more than health_cap. Returns true if it took damage, false otherwise."},{"declaration":"int TakeDamage(entvars_t@ pevInflictor, entvars_t@ pevAttacker, float flDamage, int bitsDamageType)","documentation":"Causes this entity to take damage. Returns 1 if it took damage, 0 otherwise."},{"declaration":"int Classify()","documentation":"Gets this entity's classification."},{"declaration":"int IRelationshipByClass(CLASS iClass)","documentation":"Gets the relationship between this entity and the given entity classification. See the RELATIONSHIP enum."},{"declaration":"int IRelationship(CBaseEntity@ other)","documentation":"Gets the relationship between this entity and the given entity. See the RELATIONSHIP enum."},{"declaration":"void ClearClassification()","documentation":"Clears this entity's classification override."},{"declaration":"void SetClassificationFromEntity(CBaseEntity@ pEntity)","documentation":"Sets this entity's classification override to the classification override set on the given entity. Can override the entity's player ally setting."},{"declaration":"void SetClassification(int cl)","documentation":"Sets this entity's classification override. Can override the entity's player ally setting."},{"declaration":"int GetClassification(int cl)","documentation":"Gets this entity's classification. Returns the given value if none is set. See the CLASSIFICATION enum."},{"declaration":"void SetObjectCollisionBox()","documentation":"Sets up the object collision box."},{"declaration":"int ObjectCaps()","documentation":"Gets this entity's objects caps. See the FCAP enum."},{"declaration":"void Precache()","documentation":"Precaches the entity. Do not call directly."},{"declaration":"bool opEquals(CBaseEntity@ pOther)","documentation":"Compares 2 entities for equality."},{"declaration":"void SetPlayerAllyDirect(bool fState)","documentation":"Sets this entity's player ally status.</br>Use this only if you need the setting to be exactly what you give it (e.g. when copying from another monster)"},{"declaration":"void SetPlayerAlly(bool fState)","documentation":"Sets this entity's player ally status."},{"declaration":"bool IsPlayerAlly() const","documentation":"Returns whether this entity is allied to players."},{"declaration":"int FindMonstersInWorld(array<CBaseEntity@>@ pArray, int flagMask)","documentation":"Finds monsters in the world"},{"declaration":"string SOUNDREPLACEMENT_Find(const string& in szFilename)","documentation":"Find sound replacement for the given file."},{"declaration":"bool FVisibleFromPos(const Vector& in vecTarget, const Vector& in vecStart)","documentation":"Returns whether this entity is visible from the given position."},{"declaration":"string GetTargetname() const","documentation":"Returns this entity's target name."},{"declaration":"string GetClassname() const","documentation":"Returns this entity's class name."},{"declaration":"string TeamID()","documentation":"Returns this entity's team ID."},{"declaration":"bool HasTarget(const string& in szTarget)","documentation":"Returns whether this entity has the given target."},{"declaration":"int GiveAmmo(int iAmount, const string& in szName, int iMax, const bool fFromWeapon = true)","documentation":"Gives ammo to this entity."},{"declaration":"void TraceBleed(float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)","documentation":"Traces entity bleed event."},{"declaration":"void TraceAttack(entvars_t@ pevAttacker, float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)","documentation":"Traces an attack by the given entity to this entity."},{"declaration":"bool KeyValue(const string& in szKeyName, const string& in szValue)","documentation":"Sets keyvalue data on this entity"},{"declaration":"void SetOrigin(const Vector& in vecOrigin)","documentation":"Sets this entity's (absolute) origin"},{"declaration":"const Vector& GetOrigin() const","documentation":"Gets the entity's (absolute) origin."},{"declaration":"CBaseEntity@ opImplCast()","documentation":"Implicitly casts to base type."}],"properties":[{"namespace":"","declaration":"Vector m_vecOriginalRenderColor","documentation":"Original render color."},{"namespace":"","declaration":"float m_flOriginalRenderAmount","documentation":"Original render amount."},{"namespace":"","declaration":"int m_iOriginalRenderFX","documentation":"Original render FX."},{"namespace":"","declaration":"int m_iOriginalRenderMode","documentation":"Original render model."},{"namespace":"","declaration":"string_t classnameInFilterType","documentation":"Class name in filter type."},{"namespace":"","declaration":"string_t targetnameInFilterType","documentation":"Target name in filter type."},{"namespace":"","declaration":"string_t classnameOutFilterType","documentation":"Class name out filter type."},{"namespace":"","declaration":"string_t targetnameOutFilterType","documentation":"Target name out filter type."},{"namespace":"","declaration":"Vector m_vecLastOrigin","documentation":"Last origin vector"},{"namespace":"","declaration":"bool m_fCustomModel","documentation":"Whether a custom model is used."},{"namespace":"","declaration":"bool m_fCanFadeStart","documentation":"Whether fading can start."},{"namespace":"","declaration":"float m_flMaximumFadeWaitB","documentation":"Maximum fade wait time B."},{"namespace":"","declaration":"float m_flMaximumFadeWait","documentation":"Maximum fade wait time."},{"namespace":"","declaration":"int m_iClassSelection","documentation":"The overridden classification."},{"namespace":"","declaration":"bool m_fOverrideClass","documentation":"Whether this entity overrides the classification."},{"namespace":"","declaration":"entvars_t@ pev","documentation":"Entity variables"}],"className":"CSprite","documentation":"Sprite class","namespace":""},{"flags":262145,"methods":[{"declaration":"void ShowOverheadSprite(const string& in szSpriteName, const float flZOffset, const float flLifeTime)","documentation":"Creates a sprite above the player's head"},{"declaration":"void SetViewMode(PlayerViewMode viewMode)","documentation":"Sets the player's view mode"},{"declaration":"void SetHasSuit(bool fHasSuit)","documentation":"Sets whether the player has an HEV suit."},{"declaration":"bool HasSuit()","documentation":"Returns whether the player has an HEV suit."},{"declaration":"void RemoveAllExcessAmmo()","documentation":"Clamps all the player's ammo to their maximum amounts."},{"declaration":"void RemoveExcessAmmo(const string& in szName)","documentation":"Clamps this player's ammo of the given type to the range 0 - MAX_AMMO."},{"declaration":"void RemoveExcessAmmo(size_t uiIndex)","documentation":"Clamps this player's ammo at the given inex to the range 0 - MAX_AMMO."},{"declaration":"void ResetAllMaxAmmoToDefault()","documentation":"Resets the ammo settings for this player for all ammo to their default values."},{"declaration":"void ResetMaxAmmoToDefault(const string& in szName)","documentation":"Resets the ammo setting for this player for the given ammo type to its default value."},{"declaration":"void ResetMaxAmmoToDefault(size_t uiIndex)","documentation":"Resets the ammo setting for this player at the given index to its default value."},{"declaration":"void SetMaxAmmo(const string& in szName, int iMaxAmmo)","documentation":"Sets the maximum ammo setting for this player for the given ammo type. Value must be >= 0."},{"declaration":"void SetMaxAmmo(size_t uiIndex, int iMaxAmmo)","documentation":"Sets the maximum ammo setting for this player for the ammo at the given index. Value must be >= 0."},{"declaration":"int GetMaxAmmo(const string& in szName) const","documentation":"Gets the maximum ammo setting for this player for the given ammo type. Returns -1 if no ammo setting is present."},{"declaration":"int GetMaxAmmo(size_t uiIndex) const","documentation":"Gets the maximum ammo setting for this player for the ammo at the given index. Returns -1 if no ammo setting is present."},{"declaration":"Vector GetAutoaimVector(float flDelta)","documentation":"Gets the autoaim vector for the given delta."},{"declaration":"int AmmoInventory(int iAmmoIndex)","documentation":"Returns the amount of ammo currently in inventory of the given ammo index."},{"declaration":"void SetSuitUpdate(const string& in szName, const bool bGroup, int iNoRepeat)","documentation":"Set a suit update."},{"declaration":"void CheckSuitUpdate()","documentation":"Check for suit update messages."},{"declaration":"void PlayerUse()","documentation":"Triggers the player's use behavior."},{"declaration":"void EnableControl(const bool bControl)","documentation":"Sets whether the player has control."},{"declaration":"void GiveNamedItem(const string& in szName, int iFlags = 0, int iAmmoCount = 0)","documentation":"Gives this player the item with the given name.<br/>Flags are spawnflags passed to the item."},{"declaration":"void SelectItem(const string& in szItemName)","documentation":"Selects the item with the given name."},{"declaration":"void SelectLastItem()","documentation":"Selects the last active item."},{"declaration":"void SelectNextItem()","documentation":"Selects the next item relative to the given item."},{"declaration":"void SelectPrevItem(int iItem)","documentation":"Selects the previous item relative to the given item."},{"declaration":"bool HasWeapons() const","documentation":"Returns whether this player has any weapons."},{"declaration":"CBasePlayerItem@ HasNamedPlayerItem(const string& in szItemName)","documentation":"Returns the given item, or null if this player has no item by that name."},{"declaration":"bool HasPlayerItem(CBasePlayerItem@ pCheckItem)","documentation":"Returns whether this player has the given item."},{"declaration":"CBasePlayerItem@ DropAmmo(const string& in szItemName)","documentation":"Drops ammo used by the named item."},{"declaration":"CBasePlayerItem@ DropItem(const string& in szItemName)","documentation":"Drops the given item, or if no name, the current weapon."},{"declaration":"Observer@ GetObserver()","documentation":"Gets the Observer instance that represents this player."},{"declaration":"void ShowForcedRespawnMessage(int iSeconds)","documentation":"Shows the forced respawn message."},{"declaration":"void StartPlayerDeathView(const Vector& in vecPosition, const Vector& in vecViewAngle)","documentation":"Sets the player's view to that of a dead person."},{"declaration":"bool CanSpawn()","documentation":"Returns whether this player can spawn."},{"declaration":"void StartDeathCam()","documentation":"Starts the death camera."},{"declaration":"void CheatImpulseCommands(int iImpulse)","documentation":"Triggers the given impulse command."},{"declaration":"void set_m_szAnimExtension(const string& in szAnimExtension)","documentation":"Sets the current animation extension."},{"declaration":"string get_m_szAnimExtension() const","documentation":"Gets the current animation extension."},{"declaration":"void SetAnimation(PLAYER_ANIM anim, int mode = 0)","documentation":"Set the player's animation."},{"declaration":"void FlashlightTurnOff()","documentation":"Turns off the flashlight."},{"declaration":"void FlashlightTurnOn()","documentation":"Turns on the flashlight."},{"declaration":"bool FlashlightIsOn() const","documentation":"Returns whether the flashlight is on."},{"declaration":"bool IsOnLadder() const","documentation":"Returns whether the player is on a ladder."},{"declaration":"void SetItemPickupTimes(float flTime)","documentation":"Sets all item pickup times the given absolute time."},{"declaration":"bool SwitchWeapon(CBasePlayerItem@ pWeapon)","documentation":"Switches weapons to the given item."},{"declaration":"void RemoveAllItems(const bool fRemoveSuit)","documentation":"Removes all items from the player's inventory."},{"declaration":"void PackDeadPlayerItems()","documentation":"Packs player weapons into a weapon box if possible."},{"declaration":"bool IsConnected() const","documentation":"Returns whether this player is connected."},{"declaration":"void Duck()","documentation":"Makes the player duck."},{"declaration":"void Jump()","documentation":"Makes the player jump."},{"declaration":"void m_rgAmmo(size_t uiIndex, int iValue)","documentation":"Set player ammo amount."},{"declaration":"int m_rgAmmo(size_t uiIndex)","documentation":"Get player ammo amount."},{"declaration":"CBasePlayerItem@ m_rgpPlayerItems(size_t uiIndex)","documentation":"Get player weapons. Index must be between 0 and MAX_ITEM_TYPES."},{"declaration":"void ClearEnemyList()","documentation":"Clears this monster's list of enemies"},{"declaration":"InventoryList@ get_m_pInventory() const","documentation":"The inventory items this monster has"},{"declaration":"void MedicCallSound(float flDistance = 0.0f)","documentation":"Medic call sound."},{"declaration":"string m_szTextureName()","documentation":"Current texture name we're standing on."},{"declaration":"void StopPlayerFollowing(const bool bClearSchedule)","documentation":"Stops following a player."},{"declaration":"void StartPlayerFollowing(CBaseEntity@ pLeader)","documentation":"Starts following a given player."},{"declaration":"bool CanPlayerFollow()","documentation":"Returns whether this monster can follow a player."},{"declaration":"bool IsPlayerFollowing()","documentation":"Returns whether this monster is following a player."},{"declaration":"void FollowerPlayerUse(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue)","documentation":"Use method for following players (set only if friendly)"},{"declaration":"void ShockGlowEffect(bool fMode)","documentation":"Turns the shock glow effect on or off."},{"declaration":"CBaseEntity@ DropItem(const string& in szItemName, const Vector& in vecPos, const Vector& in vecAng)","documentation":"Drops the given item from the given position at the given angle."},{"declaration":"bool CineCleanup()","documentation":"Cleans up after a cinematic event."},{"declaration":"bool ExitScriptedSequence()","documentation":"Exits the scripted sequence this monster is currently in, if any."},{"declaration":"bool HasAllMemories(int iMemory) const","documentation":"Returns whether this monster remembers all of the given memories."},{"declaration":"bool HasMemory(int iMemory) const","documentation":"Returns whether this monster remembers any of the given memories."},{"declaration":"void Forget(int iMemory)","documentation":"Makes this monster forget the given memories."},{"declaration":"void Remember(int iMemory)","documentation":"Makes this monster remember the given memories."},{"declaration":"void StopFollowing(const bool clearSchedule)","documentation":"Stops following its target."},{"declaration":"void PainSound()","documentation":"Plays this monster's pain sound."},{"declaration":"void IdleSound()","documentation":"Plays this monster's idle sound."},{"declaration":"void AlertSound()","documentation":"Plays this monster's alert sound."},{"declaration":"void DeathSound()","documentation":"Plays this monster's death sound."},{"declaration":"Vector GetGunPosition()","documentation":""},{"declaration":"Vector ShootAtEnemy(const Vector& in vecShootOrigin)","documentation":"Shoots at the specified location."},{"declaration":"void FadeMonster()","documentation":"Fades this monster.<br/>Note: does not kill the monster."},{"declaration":"bool HasAlienGibs()","documentation":"Returns whether this monster has alien gibs."},{"declaration":"bool HasHumanGibs()","documentation":"Returns whether this monster has human gibs."},{"declaration":"void CallGibMonster()","documentation":"Determines whether to gib or fade this monster, and acts accordingly."},{"declaration":"bool ShouldGibMonster(int iGib)","documentation":"Returns whether the monster should be gibbed given the gib type.<br/>See GIB enum."},{"declaration":"void GibMonster()","documentation":"Gibs the monster."},{"declaration":"bool GetEnemy()","documentation":"Tries to find the best suitable enemy for this monster."},{"declaration":"bool NoFriendlyFireToPos(Vector vecPos)","documentation":"Returns whether attacking the target location at this time would result in friendly fire"},{"declaration":"bool NoFriendlyFire(Vector vecPos, CBaseEntity@ pTarget)","documentation":"Returns whether attacking the given target at this time from the given location would result in friendly fire"},{"declaration":"bool NoFriendlyFire(Vector vecPos)","documentation":"Returns whether attacking at this time from the given location would result in friendly fire"},{"declaration":"bool NoFriendlyFire()","documentation":"Returns whether attacking at this time would result in friendly fire"},{"declaration":"bool FCheckAITrigger()","documentation":"Checks and, if necessary, fires the monster's trigger target."},{"declaration":"void Eat(float flFullDuration)","documentation":"Make the monster 'full' for a while."},{"declaration":"bool FShouldEat()","documentation":"Returns whether this monster should eat."},{"declaration":"CSound@ PBestSound()","documentation":"Returns a pointer to the sound the monster should react to."},{"declaration":"bool HasAllConditions(int iConditions) const","documentation":"Returns whether this monster has all of the given AI conditions."},{"declaration":"bool HasConditions(int iConditions) const","documentation":"Returns whether this monster has any of the given AI conditions."},{"declaration":"void ClearConditions(int iConditions)","documentation":"Clears AI conditions."},{"declaration":"void SetConditions(int iConditions)","documentation":"Sets AI conditions."},{"declaration":"bool CheckAttacker(CBaseEntity@ pAttacker)","documentation":"Determine if we should ignore damage."},{"declaration":"int RouteClassify(int iMoveFlag)","documentation":"Returns the MOVEGOAL for the given move flag."},{"declaration":"void SetYawSpeed()","documentation":"Allows different yaw_speeds for each activity."},{"declaration":"void MakeIdealYaw(Vector vecTarget)","documentation":"gets a yaw value for the caller that would<br/>face the supplied vector. Value is stuffed into the monster's<br/>ideal_yaw."},{"declaration":"int IScheduleFlags()","documentation":"Returns an integer with all Conditions<br/>bits that are currently set and also set in the current<br/>schedule's Interrupt mask."},{"declaration":"bool MovementIsComplete()","documentation":"Returns whether movement is complete."},{"declaration":"bool TaskIsComplete()","documentation":"Returns whether the task is complete."},{"declaration":"bool TaskIsRunning()","documentation":"Returns whether a task is running."},{"declaration":"void TaskBegin()","documentation":"Sets the task status to running."},{"declaration":"void TaskFail()","documentation":"Sets the condition bit for a failed task."},{"declaration":"void MovementComplete()","documentation":"Called when movement has completed."},{"declaration":"void TaskComplete()","documentation":"Sets the task status to complete."},{"declaration":"bool TestFGetNodeRoute(Vector vecDest)","documentation":"TEST FGetNodeRoute."},{"declaration":"bool FGetNodeRoute(Vector vecDest)","documentation":"tries to build an entire node path from<br/>the callers origin to the passed vector.<br/>If this is  possible, ROUTE_SIZE waypoints will be copied into the callers m_Route.<br/>true is returned if the operation  succeeds (path is valid) or false if failed (no path  exists )."},{"declaration":"bool PopEnemy()","documentation":"Try remembering the last few enemies."},{"declaration":"void PushEnemy(CBaseEntity@ pTarget, Vector& in vecLastKnownPos)","documentation":"Remember the last few enemies, always remember the player."},{"declaration":"bool CheckEnemy(CBaseEntity@ pEnemy)","documentation":"part of the Condition collection process, gets and stores data and conditions pertaining to a monster's enemy.<br/>Returns true if Enemy LKP was updated."},{"declaration":"bool CheckAttacksFromPosition(CBaseEntity@ pTarget, float flDist, Vector vecPos)","documentation":"Check whether attacks are possible from the given position."},{"declaration":"void CheckAttacks_Move(CBaseEntity@ pTarget, float flDist)","documentation":"Check attacks to the given enemy at the given distance while moving."},{"declaration":"void CheckAttacks(CBaseEntity@ pTarget, float flDist)","documentation":"Check attacks to the given enemy at the given distance."},{"declaration":"void ReportAIState()","documentation":"Reports the AI state."},{"declaration":"void SetState(MONSTERSTATE state)","documentation":"Sets the current monster state."},{"declaration":"void SetSequenceByName(const string& in szSequence)","documentation":"Sets the current sequence by name."},{"declaration":"void SetGaitActivity(Activity newActivity)","documentation":"Sets the current gait activity."},{"declaration":"void SetActivity(Activity newActivity)","documentation":"Sets the current activity."},{"declaration":"MONSTERSTATE GetIdealState()","documentation":"Gets the ideal monster state."},{"declaration":"Task@ GetTask()","documentation":"Gets the current task."},{"declaration":"void SentenceStop()","documentation":"Stops playing its current sentence."},{"declaration":"void PlayScriptedSentence(const string& in szSentence, float duration, float volume, float attenuation, const bool bConcurrent, CBaseEntity@ pListener)","documentation":"Plays the given scripted sentence."},{"declaration":"void PlaySentence(const string& in szSentence, float duration, float volume, float attenuation)","documentation":"Plays the given sentence."},{"declaration":"bool CanPlaySentence(const bool bDisregardState)","documentation":"Returns whether this monster can play its sentence."},{"declaration":"bool CanPlaySequence(const bool bDisregardState, int iInterruptLevel)","documentation":"Returns whether this monster can play its sequence."},{"declaration":"void ScheduleChange()","documentation":"Called after the monster's schedule changes."},{"declaration":"Schedule@ GetSchedule()","documentation":"Gets the current schedule."},{"declaration":"Schedule@ GetScheduleOfType(int iType)","documentation":"Gets one of the available schedules of the given type."},{"declaration":"void RunTask(Task@ pTask)","documentation":"Runs the given task."},{"declaration":"void StartTask(Task@ pTask)","documentation":"Starts the given task."},{"declaration":"void MaintainSchedule()","documentation":"Maintains the monster's schedule."},{"declaration":"Schedule@ ScheduleFromName(const string& in szName)","documentation":"Returns the schedule with name szName if it exists, NULL otherwise."},{"declaration":"Schedule@ ScheduleInList(const string& in szName, array<Schedule@>@ pArray)","documentation":"Returns the schedule with name szName if it's in the list, NULL otherwise."},{"declaration":"bool NextScheduledTask()","documentation":"Moves to the next scheduled task."},{"declaration":"void ChangeSchedule(Schedule@ pNewSchedule)","documentation":"Changes this monster's schedule."},{"declaration":"bool FScheduleDone()","documentation":"Returns whether this monster's schedule is done."},{"declaration":"void ClearSchedule()","documentation":"Clears this monster's schedule."},{"declaration":"bool FScheduleValid()","documentation":"Returns whether this monster's schedule is valid."},{"declaration":"bool FHaveSchedule()","documentation":"Returns whether this monster has a schedule."},{"declaration":"bool CheckTankUsage()","documentation":"Checks whether the monster can use a func_tank. Return true if possible."},{"declaration":"bool CheckMeleeAttack2_Move(float flDot, float flDist)","documentation":"this function will survey conditions and set appropriate conditions bits for attack types."},{"declaration":"bool CheckMeleeAttack2(float flDot, float flDist)","documentation":"this function will survey conditions and set appropriate conditions bits for attack types."},{"declaration":"bool CheckMeleeAttack1_Move(float flDot, float flDist)","documentation":"this function will survey conditions and set appropriate conditions bits for attack types."},{"declaration":"bool CheckMeleeAttack1(float flDot, float flDist)","documentation":"this function will survey conditions and set appropriate conditions bits for attack types."},{"declaration":"bool CheckRangeAttack2_Move(float flDot, float flDist)","documentation":"this function will survey conditions and set appropriate conditions bits for attack types."},{"declaration":"bool CheckRangeAttack2(float flDot, float flDist)","documentation":"this function will survey conditions and set appropriate conditions bits for attack types."},{"declaration":"bool CheckRangeAttack1_Move(float flDot, float flDist)","documentation":"this function will survey conditions and set appropriate conditions bits for attack types."},{"declaration":"bool CheckRangeAttack1(float flDot, float flDist)","documentation":"this function will survey conditions and set appropriate conditions bits for attack types."},{"declaration":"void StopAnimation()","documentation":"This will stop animation until you call ResetSequenceInfo() at some point in the future"},{"declaration":"void Stop()","documentation":"Stops this monster moving"},{"declaration":"Activity GetStoppedActivity()","documentation":"Gets the stopped activity"},{"declaration":"bool ShouldAdvanceRoute(float flWaypointDist)","documentation":"Returns whether this monster should advance its route"},{"declaration":"void MoveExecute(CBaseEntity@ pTargetEnt, const Vector& in vecDir, float flInterval)","documentation":"Starts the monster"},{"declaration":"void Move(float flInterval = 0.1f)","documentation":"Starts the monster"},{"declaration":"int CheckLocalMove(const Vector& in vecStart, const Vector& in vecEnd,CBaseEntity@ pTarget, float& out flDist, Vector& out vecEndPosition, bool fOriginalCheck = false)","documentation":"finds best visible enemy for attack"},{"declaration":"bool FInViewCone(const Vector& in vecOrigin)","documentation":"see if given location is in monster's view cone"},{"declaration":"bool FInViewCone(CBaseEntity@ pEntity)","documentation":"see if pEntity is in monster's view cone"},{"declaration":"void BestVisibleEnemy()","documentation":"finds best visible enemy for attack"},{"declaration":"void StartMonster()","documentation":"Starts the monster"},{"declaration":"void Revive()","documentation":"Revives the monster"},{"declaration":"void BecomeDead(float flSavedHealth)","documentation":"Makes the monster become dead"},{"declaration":"void MonsterInitDead()","documentation":"Call after animation/pose is set up"},{"declaration":"void MonsterInit()","documentation":"Initializes the monster"},{"declaration":"void SetupFriendly()","documentation":"use this overridden to make some other friendly monsters"},{"declaration":"float DamageForce(float flDamage)","documentation":"Returns the amount of force applied to this monster when the given amount of damage is done."},{"declaration":"float FlYawDiff()","documentation":"returns the difference ( in degrees ) between monster's current yaw and ideal_yaw.<br/>Positive result is left turn, negative is right turn."},{"declaration":"float VecToYaw(Vector vecDir)","documentation":"turns a directional vector into a yaw value that points down that vector."},{"declaration":"float ChangeYaw(int iSpeed)","documentation":"turns a monster towards its ideal_yaw"},{"declaration":"bool ShouldFadeOnDeath()","documentation":"Returns whether this monster should fade on death."},{"declaration":"void Listen()","documentation":"Listens for anything that is within audible distance."},{"declaration":"void RunAI()","documentation":"Runs this monster's AI."},{"declaration":"void Look(int iDistance)","documentation":"Look - Base class monster function to find enemies or<br/>food by sight. iDistance is distance ( in units ) that the<br/>monster can see.<br/>Sets the sight bits of the m_afConditions mask to indicate<br/>which types of entities were sighted.<br/>Function also sets the Looker's m_pLink<br/>to the head of a link list that contains all visible ents.<br/>(linked via each ent's m_pLink field)"},{"declaration":"void MonsterUse(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f)","documentation":"Will make a monster angry at whomever activated it."},{"declaration":"int8& m_rgbTimeBasedDamage(size_t uiIndex)","documentation":"time based damage counters, decr. 1 per 2 seconds. Index must be between 0 and CMG_TIMEBASED."},{"declaration":"Waypoint& m_Route(size_t uiIndex)","documentation":"Positions of movement. Index must be between 0 and ROUTE_SIZE"},{"declaration":"Vector& m_vecOldEnemy(size_t uiIndex)","documentation":"Target tank to control. Index must be between 0 and MAX_OLD_ENEMIES."},{"declaration":"EHandle& m_hOldEnemy(size_t uiIndex)","documentation":"Target tank to control. Index must be between 0 and MAX_OLD_ENEMIES."},{"declaration":"InventoryRules@ get_m_pInventoryRules() const","documentation":"The inventory rules."},{"declaration":"bool IsToggleLockedByMaster()","documentation":"Returns whether this entity is locked by its master.<br/>Separate from IsLockedByMaster due to limitations."},{"declaration":"void AngularMove(Vector vecDestAngle, float flSpeed)","documentation":"Performs angular movement."},{"declaration":"void LinearMove(Vector vecDest, float flSpeed)","documentation":"Performs linear movement."},{"declaration":"int GetSequenceActivityName(int iSequence)","documentation":"Sets the sequence box."},{"declaration":"void SetSequenceBox()","documentation":"Sets the sequence box."},{"declaration":"int GetAttachmentCount()","documentation":"Gets the number of attachments that the current model has."},{"declaration":"bool ExtractBbox(int iSequence, Vector& out mins, Vector& out maxs)","documentation":"Extracts the bounding box of the current model."},{"declaration":"int GetBodygroup(int iGroup)","documentation":"Gets the value of the given body group."},{"declaration":"void SetBodygroup(int iGroup, int iValue)","documentation":"Sets the given body group to the given value."},{"declaration":"void GetAttachment(int iAttachment, Vector& out origin, Vector& out angles)","documentation":"Gets the attachment position."},{"declaration":"int FindTransition(int iEndingSequence, int iGoalSequence)","documentation":"Find the transition between 2 sequences."},{"declaration":"int FindTransition(int iEndingSequence, int iGoalSequence, int& out iDir)","documentation":"Find the transition between 2 sequences."},{"declaration":"void GetAutomovement(Vector& out origin, Vector& out angles, float flInterval = 0.1f)","documentation":"Gets automatic movement."},{"declaration":"void GetBonePosition(int iBone, Vector& out origin, Vector& out angles)","documentation":"Gets the position of the given bone."},{"declaration":"float SetBlending(int iBlender, float flValue)","documentation":"Sets the given blending controller to the given value."},{"declaration":"void InitBoneControllers()","documentation":"Initializes bone controllers."},{"declaration":"float SetBoneController(int iController, float flValue)","documentation":"Sets the specified bone controller to the given value."},{"declaration":"void DispatchAnimEvents(float flFutureInterval = 0.1f)","documentation":"Handle events that have happend since last time called up until X seconds into the future."},{"declaration":"void ResetGaitSequenceInfo()","documentation":"Resets gait sequence info."},{"declaration":"void ResetSequenceInfo()","documentation":"Resets sequence info."},{"declaration":"int LookupSequence(const string& in szLabel)","documentation":"Returns the index of the given sequence, or -1 if no such sequence exists."},{"declaration":"int LookupActivityHeaviest(int iActivity)","documentation":"Returns the index of the given activity that has the heaviest weight, or -1 if no such activity exists."},{"declaration":"int LookupActivity(int iActivity)","documentation":"Returns the index of the given activity, or -1 if no such activity exists."},{"declaration":"int GetSequenceFlags()","documentation":"Get sequence flags."},{"declaration":"float StudioFrameAdvance(float flInterval = 0.0f)","documentation":"Accumulate animation frame time from last time called until now."},{"declaration":"void DelayThink()","documentation":"Think function. Used internally."},{"declaration":"void SUB_UseTargets(CBaseEntity@ pActivator, USE_TYPE useType, float flValue)","documentation":"Causes this entity to trigger its targets with an optional delay."},{"declaration":"void ClearUserData()","documentation":"Clears the user data on this entity. WARNING: clears all data.<br/>Only map scripts can use this."},{"declaration":"dictionaryValue& GetUserData(const string& in szKey)","documentation":"Gets the user data stored under the specified key on this entity.<br/>Do not keep references to this data, the object might be removed from this entity.<br/>Only map scripts can use this."},{"declaration":"dictionary@ GetUserData()","documentation":"Gets the user data on this entity. Do not keep references to this data, the object might be removed from this entity.<br/>Only map scripts can use this."},{"declaration":"void EndRevive(float flTimeUntilRevive)","documentation":"Called when this entity should be revived. flTimeUntilRevive is the time until the revival should start."},{"declaration":"void BeginRevive(float flTimeUntilRevive)","documentation":"Prepares this entity for revival. flTimeUntilRevive is the time until the revive action completes."},{"declaration":"bool IsRevivable()","documentation":"Returns whether this entity is revivable at this time."},{"declaration":"void OnDestroy()","documentation":"Entity destructor."},{"declaration":"void OnCreate()","documentation":"Entity constructor."},{"declaration":"void GetDamagePoints(entvars_t@ pevAttacker, entvars_t@ pevInflictor, float flDamage)","documentation":"Adds damage points to the inflicting entity."},{"declaration":"float GetPointsForDamage(float flDamage)","documentation":"Returns the points received for damage done."},{"declaration":"bool IsFacing(entvars_t@ pevTest, float flDotProduct = VIEW_FIELD_ULTRA_NARROW)","documentation":"Returns whether this entity is facing the given entity, within the given view field."},{"declaration":"bool FVisible(const Vector& in vecOrigin)","documentation":"Returns whether this entity is visible from the given origin."},{"declaration":"bool FVisible(CBaseEntity@ pEntity, bool fIgnoreGlass)","documentation":"Returns whether this entity is visible to the given entity."},{"declaration":"int Illumination()","documentation":"Returns this entity's illumination."},{"declaration":"Vector BodyTarget(const Vector& in posSrc)","documentation":"Returns this entity's body target for shooting."},{"declaration":"Vector EarPosition()","documentation":"Returns this entity's ear position."},{"declaration":"Vector EyePosition()","documentation":"Returns this entity's eye position."},{"declaration":"Vector Center()","documentation":"Returns this entity's center."},{"declaration":"bool FBecomeProne()","documentation":"Makes this entity become prone."},{"declaration":"CBaseEntity@ Respawn()","documentation":"Respawns this entity."},{"declaration":"void UpdateOnRemove()","documentation":"Updates this entity when removed."},{"declaration":"void Blocked(CBaseEntity@ pOther)","documentation":"Triggers this entity's blocked function."},{"declaration":"void Use(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f)","documentation":"Trigger's this entity's use function."},{"declaration":"void Touch(CBaseEntity@ pOther)","documentation":"Triggers this entity's touch function."},{"declaration":"void Think()","documentation":"Makes this entity think. Do not call directly."},{"declaration":"CBaseEntity@ GetNextTarget()","documentation":"Gets the next target to trigger."},{"declaration":"bool CriticalRemove()","documentation":"Removes this entity in critical situations."},{"declaration":"bool IsMachine()","documentation":"Returns whether this is a machine."},{"declaration":"bool IsPointEnt()","documentation":"Returns whether this is a point entity."},{"declaration":"bool IsNetClient()","documentation":"Returns whether this is a net client."},{"declaration":"bool IsPlayer()","documentation":"Returns whether this entity is a player."},{"declaration":"bool IsMonster()","documentation":"Returns whether this entity is a monster."},{"declaration":"bool IsInWorld()","documentation":"Returns whether this entity is in the world."},{"declaration":"bool ReflectGauss()","documentation":"Returns whether this entity reflects gauss shots."},{"declaration":"bool IsBSPModel()","documentation":"Returns whether this entity is a BSP model."},{"declaration":"bool IsAlive()","documentation":"Returns whether this entity is alive."},{"declaration":"bool IsSneaking()","documentation":"Returns whether this entity is sneaking."},{"declaration":"bool OnControls(entvars_t@ pev)","documentation":"Reacts to controls set on the pev."},{"declaration":"void StopSneaking()","documentation":"Stops sneaking."},{"declaration":"void StartSneaking()","documentation":"Starts sneaking."},{"declaration":"void SetToggleState(int state)","documentation":"Sets this entity's toggle state."},{"declaration":"int DamageDecal(int bitsDamageType)","documentation":"Returns the damage decal<br/>See decal_e."},{"declaration":"void OverrideReset()","documentation":"Resets this entity."},{"declaration":"bool IsMoving()","documentation":"Returns whether this entity is moving."},{"declaration":"float GetDelay()","documentation":"Gets this entity's trigger delay."},{"declaration":"bool RemovePlayerItem(CBasePlayerItem@ pItem)","documentation":"Removes the given player item to this entity."},{"declaration":"AddPlayerItemResult AddPlayerItem(CBasePlayerItem@ pItem)","documentation":"Adds the given player item to this entity."},{"declaration":"void AddPointsToTeam(int score, const bool bAllowNegativeScore)","documentation":"Adds points to this entity's team."},{"declaration":"void AddPoints(int score, const bool bAllowNegativeScore)","documentation":"Adds points to this entity."},{"declaration":"int GetToggleState()","documentation":"Gets the toggle state.<br/>See the TOGGLE_STATE enum."},{"declaration":"bool SetupModel()","documentation":"Sets up the model."},{"declaration":"int entindex()","documentation":"Returns this entity's index."},{"declaration":"edict_t@ edict()","documentation":"Returns this entity's edict."},{"declaration":"bool IsLockedByMaster()","documentation":"Returns whether this entity is locked by its master."},{"declaration":"bool IsDormant()","documentation":"Returns whether this entity is dormant."},{"declaration":"void MakeDormant()","documentation":"Makes this entity dormant."},{"declaration":"bool Intersects(CBaseEntity@ pOther)","documentation":"Returns whether this entity intersects with the given entity."},{"declaration":"void FireBullets(uint cShots, Vector vecSrc, Vector vecDirShooting, Vector vecSpread,float flDistance, Bullet iBulletType, int iTracerFreq = 4, int iDamage = 0, entvars_t@ pevAttacker = null, FireBulletsDrawMode fDraw = FBDM_DRAW)","documentation":"Fires bullets. Must call CMath::MakeAimVectors with an angle vector first."},{"declaration":"bool ShouldToggle(USE_TYPE useType, const bool currentState)","documentation":"Returns whether this entity should toggle."},{"declaration":"void SUB_CallUseToggle()","documentation":"Think function. Calls use toggle on this entity."},{"declaration":"void SUB_FadeOut()","documentation":"Think function. Fades this entity."},{"declaration":"void SUB_StartFadeOut()","documentation":"Think function. Starts fading this entity."},{"declaration":"void SUB_DoNothing()","documentation":"Think function. Explicitly does nothing."},{"declaration":"void SUB_Remove()","documentation":"Think function. Delay-removes this entity."},{"declaration":"bool BlockedByEntity(CBaseEntity@ pOther, float flDamage)","documentation":"Returns true if you should be blocked by the entity, false otherwise. Also deals blocking damage to the entity, if applicable."},{"declaration":"CustomKeyvalues@ GetCustomKeyvalues()","documentation":"Gets this entity's custom keyvalues."},{"declaration":"CBaseMonster@ MyMonsterPointer()","documentation":"Returns this entity as its monster entity, if it is a monster."},{"declaration":"bool IsTriggered(CBaseEntity@ pActivator)","documentation":"Returns whether this entity is triggered by the given entity."},{"declaration":"int BloodColor()","documentation":"Returns the blood color. See the BLOOD_COLOR enum."},{"declaration":"void Killed(entvars_t@pevAtttacker, int iGibbed)","documentation":"Tells this entity it's been killed. See the GIB enum for possible values."},{"declaration":"bool TakeArmor(float flArmor, int bitsDamageType, int armor_cap = 0)","documentation":"Takes armor from this entity. Note: flArmor is added to entity armor. Use negative values to subtract.If armor_cap is non-zero, won't add more than armor_cap. Returns 1 if it took damage, 0 otherwise."},{"declaration":"bool TakeHealth(float flHealth, int bitsDamageType, int health_cap = 0)","documentation":"Takes health from this entity. Note: flHealth is added to entity health. Use negative values to subtract.If health_cap is non-zero, won't add more than health_cap. Returns true if it took damage, false otherwise."},{"declaration":"int TakeDamage(entvars_t@ pevInflictor, entvars_t@ pevAttacker, float flDamage, int bitsDamageType)","documentation":"Causes this entity to take damage. Returns 1 if it took damage, 0 otherwise."},{"declaration":"int Classify()","documentation":"Gets this entity's classification."},{"declaration":"int IRelationshipByClass(CLASS iClass)","documentation":"Gets the relationship between this entity and the given entity classification. See the RELATIONSHIP enum."},{"declaration":"int IRelationship(CBaseEntity@ other)","documentation":"Gets the relationship between this entity and the given entity. See the RELATIONSHIP enum."},{"declaration":"void ClearClassification()","documentation":"Clears this entity's classification override."},{"declaration":"void SetClassificationFromEntity(CBaseEntity@ pEntity)","documentation":"Sets this entity's classification override to the classification override set on the given entity. Can override the entity's player ally setting."},{"declaration":"void SetClassification(int cl)","documentation":"Sets this entity's classification override. Can override the entity's player ally setting."},{"declaration":"int GetClassification(int cl)","documentation":"Gets this entity's classification. Returns the given value if none is set. See the CLASSIFICATION enum."},{"declaration":"void SetObjectCollisionBox()","documentation":"Sets up the object collision box."},{"declaration":"int ObjectCaps()","documentation":"Gets this entity's objects caps. See the FCAP enum."},{"declaration":"void Precache()","documentation":"Precaches the entity. Do not call directly."},{"declaration":"bool opEquals(CBaseEntity@ pOther)","documentation":"Compares 2 entities for equality."},{"declaration":"void SetPlayerAllyDirect(bool fState)","documentation":"Sets this entity's player ally status.</br>Use this only if you need the setting to be exactly what you give it (e.g. when copying from another monster)"},{"declaration":"void SetPlayerAlly(bool fState)","documentation":"Sets this entity's player ally status."},{"declaration":"bool IsPlayerAlly() const","documentation":"Returns whether this entity is allied to players."},{"declaration":"int FindMonstersInWorld(array<CBaseEntity@>@ pArray, int flagMask)","documentation":"Finds monsters in the world"},{"declaration":"string SOUNDREPLACEMENT_Find(const string& in szFilename)","documentation":"Find sound replacement for the given file."},{"declaration":"bool FVisibleFromPos(const Vector& in vecTarget, const Vector& in vecStart)","documentation":"Returns whether this entity is visible from the given position."},{"declaration":"string GetTargetname() const","documentation":"Returns this entity's target name."},{"declaration":"string GetClassname() const","documentation":"Returns this entity's class name."},{"declaration":"string TeamID()","documentation":"Returns this entity's team ID."},{"declaration":"bool HasTarget(const string& in szTarget)","documentation":"Returns whether this entity has the given target."},{"declaration":"int GiveAmmo(int iAmount, const string& in szName, int iMax, const bool fFromWeapon = true)","documentation":"Gives ammo to this entity."},{"declaration":"void TraceBleed(float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)","documentation":"Traces entity bleed event."},{"declaration":"void TraceAttack(entvars_t@ pevAttacker, float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)","documentation":"Traces an attack by the given entity to this entity."},{"declaration":"bool KeyValue(const string& in szKeyName, const string& in szValue)","documentation":"Sets keyvalue data on this entity"},{"declaration":"void SetOrigin(const Vector& in vecOrigin)","documentation":"Sets this entity's (absolute) origin"},{"declaration":"const Vector& GetOrigin() const","documentation":"Gets the entity's (absolute) origin."},{"declaration":"CBaseEntity@ opImplCast()","documentation":"Implicitly casts to base type."},{"declaration":"CBaseDelay@ opImplCast()","documentation":"Implicitly casts to base type."},{"declaration":"CBaseAnimating@ opImplCast()","documentation":"Implicitly casts to base type."},{"declaration":"CBaseToggle@ opImplCast()","documentation":"Implicitly casts to base type."},{"declaration":"CBaseMonster@ opImplCast()","documentation":"Implicitly casts to base type."}],"properties":[{"namespace":"","declaration":"int m_iPlayerClass","documentation":"The player's class type."},{"namespace":"","declaration":"float m_flNextDecalTime","documentation":"Next time this player can spray a decal."},{"namespace":"","declaration":"int m_iDeaths","documentation":"get player death count."},{"namespace":"","declaration":"CBasePlayerItem@ m_pActiveItem","documentation":"The active item."},{"namespace":"","declaration":"int m_iFOV","documentation":"Field of view."},{"namespace":"","declaration":"int m_iHideHUD","documentation":"The players hud weapon info is to be hidden."},{"namespace":"","declaration":"bool m_fLongJump","documentation":"Does this player have the longjump module?"},{"namespace":"","declaration":"float m_fDeadTime","documentation":"the time at which the player died"},{"namespace":"","declaration":"EHandle m_pTank","documentation":"the tank which the player is currently controlling, NULL if no tank"},{"namespace":"","declaration":"int m_iTrain","documentation":"Train control position"},{"namespace":"","declaration":"int m_iDrownRestored","documentation":"Track drowning damage restored."},{"namespace":"","declaration":"int m_iDrownDmg","documentation":"Track drowning damage taken."},{"namespace":"","declaration":"int m_lastPlayerDamageAmount","documentation":"Last damage taken."},{"namespace":"","declaration":"float m_flMaxSpeed","documentation":"How fast the player can move."},{"namespace":"","declaration":"float m_flSwimTime","documentation":"How long this player has been underwater."},{"namespace":"","declaration":"uint m_afPhysicsFlags","documentation":""},{"namespace":"","declaration":"float m_flPlayerFallVelocity","documentation":"Player fall velocity."},{"namespace":"","declaration":"int m_afButtonReleased","documentation":""},{"namespace":"","declaration":"int m_afButtonPressed","documentation":""},{"namespace":"","declaration":"int m_afButtonLast","documentation":""},{"namespace":"","declaration":"int m_iFlashBattery","documentation":"Player flashlight amount. 0 <= amount <= 100."},{"namespace":"","declaration":"float m_flStopExtraSoundTime","documentation":"When to stop the m_iExtraSoundTypes sounds."},{"namespace":"","declaration":"int m_iWeaponFlash","documentation":"Brightness of the weapon flash."},{"namespace":"","declaration":"int m_iExtraSoundTypes","documentation":"Additional classification for this weapon's sound."},{"namespace":"","declaration":"int m_iWeaponVolume","documentation":"How loud the player's weapon is right now."},{"namespace":"","declaration":"float m_flLastMove","documentation":"When did this player move or tried to move (with the IN_ keys) ?"},{"namespace":"","declaration":"edict_t@ m_pedSpawnPoint","documentation":"Pointer for a spawn point to use."},{"namespace":"","declaration":"float m_flRespawnDelayTime","documentation":"Gets added to the standard respawn delay time when killed, reset in spawn to 0.0."},{"namespace":"","declaration":"float m_flTimeOfLastDeath","documentation":"Time of last death."},{"namespace":"","declaration":"float m_flNextClientCommandTime","documentation":"The next time this player can execute a vocal client command"},{"namespace":"","declaration":"const int random_seed","documentation":"The player's random seed."},{"namespace":"","declaration":"string_t m_iszGuardEntName","documentation":"Guard entity name."},{"namespace":"","declaration":"EHandle m_pGuardEnt","documentation":"Monster will guard this entity and turn down follow requests."},{"namespace":"","declaration":"float m_flFallVelocity","documentation":"Current fall speed."},{"namespace":"","declaration":"float m_flAutomaticAttackTime","documentation":"How long an npc will attempt to fire full auto."},{"namespace":"","declaration":"bool m_fCanFearCreatures","documentation":"Whether this monster can fear creatures."},{"namespace":"","declaration":"int8 m_chTextureType","documentation":"Current texture type.<br/>See TextureType enum."},{"namespace":"","declaration":"string_t m_FormattedName","documentation":"The formatted name.<br/>For better name outputs. E.g. \"Alien Slave\" rather than \"alien_slave\"."},{"namespace":"","declaration":"float m_useTime","documentation":"Don't allow +USE until this time."},{"namespace":"","declaration":"CBaseEntity@ m_pCineBlocker","documentation":"Entity that is blocking cinematic execution."},{"namespace":"","declaration":"CCineMonster@ m_pCine","documentation":"Cinematic entity."},{"namespace":"","declaration":"SCRIPTSTATE m_scriptState","documentation":"internal cinematic state."},{"namespace":"","declaration":"Vector m_HackedGunPos","documentation":"HACK until we can query end of gun."},{"namespace":"","declaration":"string_t m_iszTriggerTarget","documentation":"Name of target that should be fired."},{"namespace":"","declaration":"int m_iTriggerCondition","documentation":"for scripted AI, this is the condition that will cause the activation of the monster's TriggerTarget."},{"namespace":"","declaration":"float m_flDistLook","documentation":"distance monster sees (Default 2048)."},{"namespace":"","declaration":"float m_flDistTooFar","documentation":"if enemy farther away than this, bits_COND_ENEMY_TOOFAR set in CheckEnemy."},{"namespace":"","declaration":"float m_flHungryTime","documentation":"Time based damage inflictor."},{"namespace":"","declaration":"int m_failSchedule","documentation":"Schedule type to choose if current schedule fails."},{"namespace":"","declaration":"entvars_t@ pevTimeBasedInflictor","documentation":"Time based damage inflictor."},{"namespace":"","declaration":"float m_tbdPrev","documentation":"Time-based damage timer."},{"namespace":"","declaration":"float m_lastDamageAmount","documentation":"how much damage did monster (player) last take."},{"namespace":"","declaration":"int m_bitsDamageType","documentation":"what types of damage has monster (player) taken."},{"namespace":"","declaration":"float m_flNextAttack","documentation":"cannot attack again until this time."},{"namespace":"","declaration":"int m_afMoveShootCap","documentation":"tells us what a monster can/can't do, while moving."},{"namespace":"","declaration":"int m_afCapability","documentation":"tells us what a monster can/can't do."},{"namespace":"","declaration":"int m_cAmmoLoaded","documentation":"how much ammo is in the weapon (used to trigger reload anim sequences)."},{"namespace":"","declaration":"Vector m_vecEnemyLKP","documentation":"last known position of enemy. (enemy's origin)."},{"namespace":"","declaration":"int m_iMaxHealth","documentation":"keeps track of monster's maximum health value (for re-healing, etc)."},{"namespace":"","declaration":"int m_bloodColor","documentation":"color of blood particles."},{"namespace":"","declaration":"int m_afMemory","documentation":"Monster memory."},{"namespace":"","declaration":"int m_iHintNode","documentation":"this is the hint node that the monster is moving towards or performing active idle on.."},{"namespace":"","declaration":"Vector m_vecLastPosition","documentation":"monster sometimes wants to return to where it started after an operation.."},{"namespace":"","declaration":"int m_afSoundTypes","documentation":"Sound types that can be heard."},{"namespace":"","declaration":"int m_iAudibleList","documentation":"first index of a linked list of sounds that the monster can hear."},{"namespace":"","declaration":"Activity m_movementActivity","documentation":"When moving, set this activity."},{"namespace":"","declaration":"Vector m_vecMoveGoal","documentation":"Kept around for node graph moves, so we know our ultimate goal."},{"namespace":"","declaration":"float m_moveradius","documentation":"Minimum radius."},{"namespace":"","declaration":"float m_moveWaitTime","documentation":"How long I should wait for something to move."},{"namespace":"","declaration":"int m_iRouteIndex","documentation":"Index into m_Route[]."},{"namespace":"","declaration":"int m_movementGoal","documentation":"Goal that defines route."},{"namespace":"","declaration":"int m_iScheduleIndex","documentation":"Schedule index."},{"namespace":"","declaration":"Schedule@ m_pScheduleSaved","documentation":"For land_on_ground schedules (remember last schedule and continue)."},{"namespace":"","declaration":"Schedule@ m_pSchedule","documentation":"Current schedule."},{"namespace":"","declaration":"int m_iTaskStatus","documentation":"Task status."},{"namespace":"","declaration":"MONSTERSTATE m_IdealMonsterState","documentation":"monster should change to this state."},{"namespace":"","declaration":"MONSTERSTATE m_MonsterState","documentation":"monster's current state."},{"namespace":"","declaration":"int m_LastHitGroup","documentation":"the last body region that took damage."},{"namespace":"","declaration":"Activity m_GaitActivity","documentation":"gaitsequence."},{"namespace":"","declaration":"Activity m_IdealActivity","documentation":"monster should switch to this activity."},{"namespace":"","declaration":"Activity m_Activity","documentation":"what the monster is doing (animation)."},{"namespace":"","declaration":"float m_flMoveWaitFinished","documentation":"if we're told to wait before moving, this is the time that the wait will be over."},{"namespace":"","declaration":"float m_flWaitFinished","documentation":"if we're told to wait, this is the time that the wait will be over."},{"namespace":"","declaration":"float m_flFieldOfView","documentation":"width of monster's field of view ( dot product )."},{"namespace":"","declaration":"EHandle m_hTargetTank","documentation":"Target tank to control."},{"namespace":"","declaration":"EHandle m_hTargetEnt","documentation":"the entity that the monster is trying to reach."},{"namespace":"","declaration":"EHandle m_hEnemy","documentation":"the entity that the monster is fighting."},{"namespace":"","declaration":"string_t m_sMaster","documentation":"This entity's master, if any."},{"namespace":"","declaration":"int m_bitsDamageInflict","documentation":"DMG_ damage type that the door or trigger does."},{"namespace":"","declaration":"Vector m_vecFinalAngle","documentation":"Final angle."},{"namespace":"","declaration":"Vector m_vecFinalDest","documentation":"Final destination."},{"namespace":"","declaration":"Vector m_vecAngle2","documentation":"Open angle."},{"namespace":"","declaration":"Vector m_vecAngle1","documentation":"Closed angle."},{"namespace":"","declaration":"Vector m_vecPosition2","documentation":"Open position."},{"namespace":"","declaration":"Vector m_vecPosition1","documentation":"Closed position."},{"namespace":"","declaration":"EHandle m_hActivator","documentation":"Handle to the activator."},{"namespace":"","declaration":"float m_flHeight","documentation":"Height."},{"namespace":"","declaration":"int m_cTriggersLeft","documentation":"Trigger_counter only: # of activations remaining."},{"namespace":"","declaration":"float m_flTLength","documentation":"For plats."},{"namespace":"","declaration":"float m_flTWidth","documentation":"For plats."},{"namespace":"","declaration":"float m_flLip","documentation":"How much to stick out of a wall. Will recede further into walls if negative."},{"namespace":"","declaration":"float m_flWait","documentation":"How long to wait before resetting."},{"namespace":"","declaration":"float m_flMoveDistance","documentation":"How far a door should slide or rotate."},{"namespace":"","declaration":"TOGGLE_STATE m_toggle_state","documentation":"Current toggle state."},{"namespace":"","declaration":"bool m_fSequenceLoops","documentation":"True if the sequence loops."},{"namespace":"","declaration":"bool m_fSequenceFinished","documentation":"Flag set when StudioAdvanceFrame moves across a frame boundry."},{"namespace":"","declaration":"float m_flLastGaitEventCheck","documentation":"Last time the event list was checked."},{"namespace":"","declaration":"float m_flLastEventCheck","documentation":"Last time the event list was checked."},{"namespace":"","declaration":"float m_flGroundSpeed","documentation":"Computed linear movement rate for current sequence."},{"namespace":"","declaration":"float m_flFrameRate","documentation":"Computed FPS for current sequence."},{"namespace":"","declaration":"string_t m_iszKillTarget","documentation":"The name of the kill target, if any."},{"namespace":"","declaration":"float m_flDelay","documentation":"Delay before fire."},{"namespace":"","declaration":"Vector m_vecOriginalRenderColor","documentation":"Original render color."},{"namespace":"","declaration":"float m_flOriginalRenderAmount","documentation":"Original render amount."},{"namespace":"","declaration":"int m_iOriginalRenderFX","documentation":"Original render FX."},{"namespace":"","declaration":"int m_iOriginalRenderMode","documentation":"Original render model."},{"namespace":"","declaration":"string_t classnameInFilterType","documentation":"Class name in filter type."},{"namespace":"","declaration":"string_t targetnameInFilterType","documentation":"Target name in filter type."},{"namespace":"","declaration":"string_t classnameOutFilterType","documentation":"Class name out filter type."},{"namespace":"","declaration":"string_t targetnameOutFilterType","documentation":"Target name out filter type."},{"namespace":"","declaration":"Vector m_vecLastOrigin","documentation":"Last origin vector"},{"namespace":"","declaration":"bool m_fCustomModel","documentation":"Whether a custom model is used."},{"namespace":"","declaration":"bool m_fCanFadeStart","documentation":"Whether fading can start."},{"namespace":"","declaration":"float m_flMaximumFadeWaitB","documentation":"Maximum fade wait time B."},{"namespace":"","declaration":"float m_flMaximumFadeWait","documentation":"Maximum fade wait time."},{"namespace":"","declaration":"int m_iClassSelection","documentation":"The overridden classification."},{"namespace":"","declaration":"bool m_fOverrideClass","documentation":"Whether this entity overrides the classification."},{"namespace":"","declaration":"entvars_t@ pev","documentation":"Entity variables"}],"className":"CBasePlayer","documentation":"Player entity base class","namespace":""},{"flags":262145,"methods":[{"declaration":"int IgnoreConditions()","documentation":"Gets the ignore conditions."},{"declaration":"bool CanInterrupt()","documentation":"Returns whether this script can be interrupted."},{"declaration":"bool FCanOverrideState() const","documentation":"If this returns false, scripted sequences cannot possess entities regardless of state."},{"declaration":"bool StartSequence(CBaseMonster@ pTarget, const string& in szSequence, const bool fCompleteOnEmpty)","documentation":"Make the entity enter a scripted sequence."},{"declaration":"void CancelScript()","documentation":"Find all the cinematic entities with my targetname and stop them from playing."},{"declaration":"void PossessEntity()","documentation":"Make the entity enter a scripted sequence."},{"declaration":"void DelayStart(int iState)","documentation":"Find all the cinematic entities with my targetname and tell them to wait before starting."},{"declaration":"void ClearEnemyList()","documentation":"Clears this monster's list of enemies"},{"declaration":"InventoryList@ get_m_pInventory() const","documentation":"The inventory items this monster has"},{"declaration":"void MedicCallSound(float flDistance = 0.0f)","documentation":"Medic call sound."},{"declaration":"string m_szTextureName()","documentation":"Current texture name we're standing on."},{"declaration":"void StopPlayerFollowing(const bool bClearSchedule)","documentation":"Stops following a player."},{"declaration":"void StartPlayerFollowing(CBaseEntity@ pLeader)","documentation":"Starts following a given player."},{"declaration":"bool CanPlayerFollow()","documentation":"Returns whether this monster can follow a player."},{"declaration":"bool IsPlayerFollowing()","documentation":"Returns whether this monster is following a player."},{"declaration":"void FollowerPlayerUse(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue)","documentation":"Use method for following players (set only if friendly)"},{"declaration":"void ShockGlowEffect(bool fMode)","documentation":"Turns the shock glow effect on or off."},{"declaration":"CBaseEntity@ DropItem(const string& in szItemName, const Vector& in vecPos, const Vector& in vecAng)","documentation":"Drops the given item from the given position at the given angle."},{"declaration":"bool CineCleanup()","documentation":"Cleans up after a cinematic event."},{"declaration":"bool ExitScriptedSequence()","documentation":"Exits the scripted sequence this monster is currently in, if any."},{"declaration":"bool HasAllMemories(int iMemory) const","documentation":"Returns whether this monster remembers all of the given memories."},{"declaration":"bool HasMemory(int iMemory) const","documentation":"Returns whether this monster remembers any of the given memories."},{"declaration":"void Forget(int iMemory)","documentation":"Makes this monster forget the given memories."},{"declaration":"void Remember(int iMemory)","documentation":"Makes this monster remember the given memories."},{"declaration":"void StopFollowing(const bool clearSchedule)","documentation":"Stops following its target."},{"declaration":"void PainSound()","documentation":"Plays this monster's pain sound."},{"declaration":"void IdleSound()","documentation":"Plays this monster's idle sound."},{"declaration":"void AlertSound()","documentation":"Plays this monster's alert sound."},{"declaration":"void DeathSound()","documentation":"Plays this monster's death sound."},{"declaration":"Vector GetGunPosition()","documentation":""},{"declaration":"Vector ShootAtEnemy(const Vector& in vecShootOrigin)","documentation":"Shoots at the specified location."},{"declaration":"void FadeMonster()","documentation":"Fades this monster.<br/>Note: does not kill the monster."},{"declaration":"bool HasAlienGibs()","documentation":"Returns whether this monster has alien gibs."},{"declaration":"bool HasHumanGibs()","documentation":"Returns whether this monster has human gibs."},{"declaration":"void CallGibMonster()","documentation":"Determines whether to gib or fade this monster, and acts accordingly."},{"declaration":"bool ShouldGibMonster(int iGib)","documentation":"Returns whether the monster should be gibbed given the gib type.<br/>See GIB enum."},{"declaration":"void GibMonster()","documentation":"Gibs the monster."},{"declaration":"bool GetEnemy()","documentation":"Tries to find the best suitable enemy for this monster."},{"declaration":"bool NoFriendlyFireToPos(Vector vecPos)","documentation":"Returns whether attacking the target location at this time would result in friendly fire"},{"declaration":"bool NoFriendlyFire(Vector vecPos, CBaseEntity@ pTarget)","documentation":"Returns whether attacking the given target at this time from the given location would result in friendly fire"},{"declaration":"bool NoFriendlyFire(Vector vecPos)","documentation":"Returns whether attacking at this time from the given location would result in friendly fire"},{"declaration":"bool NoFriendlyFire()","documentation":"Returns whether attacking at this time would result in friendly fire"},{"declaration":"bool FCheckAITrigger()","documentation":"Checks and, if necessary, fires the monster's trigger target."},{"declaration":"void Eat(float flFullDuration)","documentation":"Make the monster 'full' for a while."},{"declaration":"bool FShouldEat()","documentation":"Returns whether this monster should eat."},{"declaration":"CSound@ PBestSound()","documentation":"Returns a pointer to the sound the monster should react to."},{"declaration":"bool HasAllConditions(int iConditions) const","documentation":"Returns whether this monster has all of the given AI conditions."},{"declaration":"bool HasConditions(int iConditions) const","documentation":"Returns whether this monster has any of the given AI conditions."},{"declaration":"void ClearConditions(int iConditions)","documentation":"Clears AI conditions."},{"declaration":"void SetConditions(int iConditions)","documentation":"Sets AI conditions."},{"declaration":"bool CheckAttacker(CBaseEntity@ pAttacker)","documentation":"Determine if we should ignore damage."},{"declaration":"int RouteClassify(int iMoveFlag)","documentation":"Returns the MOVEGOAL for the given move flag."},{"declaration":"void SetYawSpeed()","documentation":"Allows different yaw_speeds for each activity."},{"declaration":"void MakeIdealYaw(Vector vecTarget)","documentation":"gets a yaw value for the caller that would<br/>face the supplied vector. Value is stuffed into the monster's<br/>ideal_yaw."},{"declaration":"int IScheduleFlags()","documentation":"Returns an integer with all Conditions<br/>bits that are currently set and also set in the current<br/>schedule's Interrupt mask."},{"declaration":"bool MovementIsComplete()","documentation":"Returns whether movement is complete."},{"declaration":"bool TaskIsComplete()","documentation":"Returns whether the task is complete."},{"declaration":"bool TaskIsRunning()","documentation":"Returns whether a task is running."},{"declaration":"void TaskBegin()","documentation":"Sets the task status to running."},{"declaration":"void TaskFail()","documentation":"Sets the condition bit for a failed task."},{"declaration":"void MovementComplete()","documentation":"Called when movement has completed."},{"declaration":"void TaskComplete()","documentation":"Sets the task status to complete."},{"declaration":"bool TestFGetNodeRoute(Vector vecDest)","documentation":"TEST FGetNodeRoute."},{"declaration":"bool FGetNodeRoute(Vector vecDest)","documentation":"tries to build an entire node path from<br/>the callers origin to the passed vector.<br/>If this is  possible, ROUTE_SIZE waypoints will be copied into the callers m_Route.<br/>true is returned if the operation  succeeds (path is valid) or false if failed (no path  exists )."},{"declaration":"bool PopEnemy()","documentation":"Try remembering the last few enemies."},{"declaration":"void PushEnemy(CBaseEntity@ pTarget, Vector& in vecLastKnownPos)","documentation":"Remember the last few enemies, always remember the player."},{"declaration":"bool CheckEnemy(CBaseEntity@ pEnemy)","documentation":"part of the Condition collection process, gets and stores data and conditions pertaining to a monster's enemy.<br/>Returns true if Enemy LKP was updated."},{"declaration":"bool CheckAttacksFromPosition(CBaseEntity@ pTarget, float flDist, Vector vecPos)","documentation":"Check whether attacks are possible from the given position."},{"declaration":"void CheckAttacks_Move(CBaseEntity@ pTarget, float flDist)","documentation":"Check attacks to the given enemy at the given distance while moving."},{"declaration":"void CheckAttacks(CBaseEntity@ pTarget, float flDist)","documentation":"Check attacks to the given enemy at the given distance."},{"declaration":"void ReportAIState()","documentation":"Reports the AI state."},{"declaration":"void SetState(MONSTERSTATE state)","documentation":"Sets the current monster state."},{"declaration":"void SetSequenceByName(const string& in szSequence)","documentation":"Sets the current sequence by name."},{"declaration":"void SetGaitActivity(Activity newActivity)","documentation":"Sets the current gait activity."},{"declaration":"void SetActivity(Activity newActivity)","documentation":"Sets the current activity."},{"declaration":"MONSTERSTATE GetIdealState()","documentation":"Gets the ideal monster state."},{"declaration":"Task@ GetTask()","documentation":"Gets the current task."},{"declaration":"void SentenceStop()","documentation":"Stops playing its current sentence."},{"declaration":"void PlayScriptedSentence(const string& in szSentence, float duration, float volume, float attenuation, const bool bConcurrent, CBaseEntity@ pListener)","documentation":"Plays the given scripted sentence."},{"declaration":"void PlaySentence(const string& in szSentence, float duration, float volume, float attenuation)","documentation":"Plays the given sentence."},{"declaration":"bool CanPlaySentence(const bool bDisregardState)","documentation":"Returns whether this monster can play its sentence."},{"declaration":"bool CanPlaySequence(const bool bDisregardState, int iInterruptLevel)","documentation":"Returns whether this monster can play its sequence."},{"declaration":"void ScheduleChange()","documentation":"Called after the monster's schedule changes."},{"declaration":"Schedule@ GetSchedule()","documentation":"Gets the current schedule."},{"declaration":"Schedule@ GetScheduleOfType(int iType)","documentation":"Gets one of the available schedules of the given type."},{"declaration":"void RunTask(Task@ pTask)","documentation":"Runs the given task."},{"declaration":"void StartTask(Task@ pTask)","documentation":"Starts the given task."},{"declaration":"void MaintainSchedule()","documentation":"Maintains the monster's schedule."},{"declaration":"Schedule@ ScheduleFromName(const string& in szName)","documentation":"Returns the schedule with name szName if it exists, NULL otherwise."},{"declaration":"Schedule@ ScheduleInList(const string& in szName, array<Schedule@>@ pArray)","documentation":"Returns the schedule with name szName if it's in the list, NULL otherwise."},{"declaration":"bool NextScheduledTask()","documentation":"Moves to the next scheduled task."},{"declaration":"void ChangeSchedule(Schedule@ pNewSchedule)","documentation":"Changes this monster's schedule."},{"declaration":"bool FScheduleDone()","documentation":"Returns whether this monster's schedule is done."},{"declaration":"void ClearSchedule()","documentation":"Clears this monster's schedule."},{"declaration":"bool FScheduleValid()","documentation":"Returns whether this monster's schedule is valid."},{"declaration":"bool FHaveSchedule()","documentation":"Returns whether this monster has a schedule."},{"declaration":"bool CheckTankUsage()","documentation":"Checks whether the monster can use a func_tank. Return true if possible."},{"declaration":"bool CheckMeleeAttack2_Move(float flDot, float flDist)","documentation":"this function will survey conditions and set appropriate conditions bits for attack types."},{"declaration":"bool CheckMeleeAttack2(float flDot, float flDist)","documentation":"this function will survey conditions and set appropriate conditions bits for attack types."},{"declaration":"bool CheckMeleeAttack1_Move(float flDot, float flDist)","documentation":"this function will survey conditions and set appropriate conditions bits for attack types."},{"declaration":"bool CheckMeleeAttack1(float flDot, float flDist)","documentation":"this function will survey conditions and set appropriate conditions bits for attack types."},{"declaration":"bool CheckRangeAttack2_Move(float flDot, float flDist)","documentation":"this function will survey conditions and set appropriate conditions bits for attack types."},{"declaration":"bool CheckRangeAttack2(float flDot, float flDist)","documentation":"this function will survey conditions and set appropriate conditions bits for attack types."},{"declaration":"bool CheckRangeAttack1_Move(float flDot, float flDist)","documentation":"this function will survey conditions and set appropriate conditions bits for attack types."},{"declaration":"bool CheckRangeAttack1(float flDot, float flDist)","documentation":"this function will survey conditions and set appropriate conditions bits for attack types."},{"declaration":"void StopAnimation()","documentation":"This will stop animation until you call ResetSequenceInfo() at some point in the future"},{"declaration":"void Stop()","documentation":"Stops this monster moving"},{"declaration":"Activity GetStoppedActivity()","documentation":"Gets the stopped activity"},{"declaration":"bool ShouldAdvanceRoute(float flWaypointDist)","documentation":"Returns whether this monster should advance its route"},{"declaration":"void MoveExecute(CBaseEntity@ pTargetEnt, const Vector& in vecDir, float flInterval)","documentation":"Starts the monster"},{"declaration":"void Move(float flInterval = 0.1f)","documentation":"Starts the monster"},{"declaration":"int CheckLocalMove(const Vector& in vecStart, const Vector& in vecEnd,CBaseEntity@ pTarget, float& out flDist, Vector& out vecEndPosition, bool fOriginalCheck = false)","documentation":"finds best visible enemy for attack"},{"declaration":"bool FInViewCone(const Vector& in vecOrigin)","documentation":"see if given location is in monster's view cone"},{"declaration":"bool FInViewCone(CBaseEntity@ pEntity)","documentation":"see if pEntity is in monster's view cone"},{"declaration":"void BestVisibleEnemy()","documentation":"finds best visible enemy for attack"},{"declaration":"void StartMonster()","documentation":"Starts the monster"},{"declaration":"void Revive()","documentation":"Revives the monster"},{"declaration":"void BecomeDead(float flSavedHealth)","documentation":"Makes the monster become dead"},{"declaration":"void MonsterInitDead()","documentation":"Call after animation/pose is set up"},{"declaration":"void MonsterInit()","documentation":"Initializes the monster"},{"declaration":"void SetupFriendly()","documentation":"use this overridden to make some other friendly monsters"},{"declaration":"float DamageForce(float flDamage)","documentation":"Returns the amount of force applied to this monster when the given amount of damage is done."},{"declaration":"float FlYawDiff()","documentation":"returns the difference ( in degrees ) between monster's current yaw and ideal_yaw.<br/>Positive result is left turn, negative is right turn."},{"declaration":"float VecToYaw(Vector vecDir)","documentation":"turns a directional vector into a yaw value that points down that vector."},{"declaration":"float ChangeYaw(int iSpeed)","documentation":"turns a monster towards its ideal_yaw"},{"declaration":"bool ShouldFadeOnDeath()","documentation":"Returns whether this monster should fade on death."},{"declaration":"void Listen()","documentation":"Listens for anything that is within audible distance."},{"declaration":"void RunAI()","documentation":"Runs this monster's AI."},{"declaration":"void Look(int iDistance)","documentation":"Look - Base class monster function to find enemies or<br/>food by sight. iDistance is distance ( in units ) that the<br/>monster can see.<br/>Sets the sight bits of the m_afConditions mask to indicate<br/>which types of entities were sighted.<br/>Function also sets the Looker's m_pLink<br/>to the head of a link list that contains all visible ents.<br/>(linked via each ent's m_pLink field)"},{"declaration":"void MonsterUse(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f)","documentation":"Will make a monster angry at whomever activated it."},{"declaration":"int8& m_rgbTimeBasedDamage(size_t uiIndex)","documentation":"time based damage counters, decr. 1 per 2 seconds. Index must be between 0 and CMG_TIMEBASED."},{"declaration":"Waypoint& m_Route(size_t uiIndex)","documentation":"Positions of movement. Index must be between 0 and ROUTE_SIZE"},{"declaration":"Vector& m_vecOldEnemy(size_t uiIndex)","documentation":"Target tank to control. Index must be between 0 and MAX_OLD_ENEMIES."},{"declaration":"EHandle& m_hOldEnemy(size_t uiIndex)","documentation":"Target tank to control. Index must be between 0 and MAX_OLD_ENEMIES."},{"declaration":"InventoryRules@ get_m_pInventoryRules() const","documentation":"The inventory rules."},{"declaration":"bool IsToggleLockedByMaster()","documentation":"Returns whether this entity is locked by its master.<br/>Separate from IsLockedByMaster due to limitations."},{"declaration":"void AngularMove(Vector vecDestAngle, float flSpeed)","documentation":"Performs angular movement."},{"declaration":"void LinearMove(Vector vecDest, float flSpeed)","documentation":"Performs linear movement."},{"declaration":"int GetSequenceActivityName(int iSequence)","documentation":"Sets the sequence box."},{"declaration":"void SetSequenceBox()","documentation":"Sets the sequence box."},{"declaration":"int GetAttachmentCount()","documentation":"Gets the number of attachments that the current model has."},{"declaration":"bool ExtractBbox(int iSequence, Vector& out mins, Vector& out maxs)","documentation":"Extracts the bounding box of the current model."},{"declaration":"int GetBodygroup(int iGroup)","documentation":"Gets the value of the given body group."},{"declaration":"void SetBodygroup(int iGroup, int iValue)","documentation":"Sets the given body group to the given value."},{"declaration":"void GetAttachment(int iAttachment, Vector& out origin, Vector& out angles)","documentation":"Gets the attachment position."},{"declaration":"int FindTransition(int iEndingSequence, int iGoalSequence)","documentation":"Find the transition between 2 sequences."},{"declaration":"int FindTransition(int iEndingSequence, int iGoalSequence, int& out iDir)","documentation":"Find the transition between 2 sequences."},{"declaration":"void GetAutomovement(Vector& out origin, Vector& out angles, float flInterval = 0.1f)","documentation":"Gets automatic movement."},{"declaration":"void GetBonePosition(int iBone, Vector& out origin, Vector& out angles)","documentation":"Gets the position of the given bone."},{"declaration":"float SetBlending(int iBlender, float flValue)","documentation":"Sets the given blending controller to the given value."},{"declaration":"void InitBoneControllers()","documentation":"Initializes bone controllers."},{"declaration":"float SetBoneController(int iController, float flValue)","documentation":"Sets the specified bone controller to the given value."},{"declaration":"void DispatchAnimEvents(float flFutureInterval = 0.1f)","documentation":"Handle events that have happend since last time called up until X seconds into the future."},{"declaration":"void ResetGaitSequenceInfo()","documentation":"Resets gait sequence info."},{"declaration":"void ResetSequenceInfo()","documentation":"Resets sequence info."},{"declaration":"int LookupSequence(const string& in szLabel)","documentation":"Returns the index of the given sequence, or -1 if no such sequence exists."},{"declaration":"int LookupActivityHeaviest(int iActivity)","documentation":"Returns the index of the given activity that has the heaviest weight, or -1 if no such activity exists."},{"declaration":"int LookupActivity(int iActivity)","documentation":"Returns the index of the given activity, or -1 if no such activity exists."},{"declaration":"int GetSequenceFlags()","documentation":"Get sequence flags."},{"declaration":"float StudioFrameAdvance(float flInterval = 0.0f)","documentation":"Accumulate animation frame time from last time called until now."},{"declaration":"void DelayThink()","documentation":"Think function. Used internally."},{"declaration":"void SUB_UseTargets(CBaseEntity@ pActivator, USE_TYPE useType, float flValue)","documentation":"Causes this entity to trigger its targets with an optional delay."},{"declaration":"void ClearUserData()","documentation":"Clears the user data on this entity. WARNING: clears all data.<br/>Only map scripts can use this."},{"declaration":"dictionaryValue& GetUserData(const string& in szKey)","documentation":"Gets the user data stored under the specified key on this entity.<br/>Do not keep references to this data, the object might be removed from this entity.<br/>Only map scripts can use this."},{"declaration":"dictionary@ GetUserData()","documentation":"Gets the user data on this entity. Do not keep references to this data, the object might be removed from this entity.<br/>Only map scripts can use this."},{"declaration":"void EndRevive(float flTimeUntilRevive)","documentation":"Called when this entity should be revived. flTimeUntilRevive is the time until the revival should start."},{"declaration":"void BeginRevive(float flTimeUntilRevive)","documentation":"Prepares this entity for revival. flTimeUntilRevive is the time until the revive action completes."},{"declaration":"bool IsRevivable()","documentation":"Returns whether this entity is revivable at this time."},{"declaration":"void OnDestroy()","documentation":"Entity destructor."},{"declaration":"void OnCreate()","documentation":"Entity constructor."},{"declaration":"void GetDamagePoints(entvars_t@ pevAttacker, entvars_t@ pevInflictor, float flDamage)","documentation":"Adds damage points to the inflicting entity."},{"declaration":"float GetPointsForDamage(float flDamage)","documentation":"Returns the points received for damage done."},{"declaration":"bool IsFacing(entvars_t@ pevTest, float flDotProduct = VIEW_FIELD_ULTRA_NARROW)","documentation":"Returns whether this entity is facing the given entity, within the given view field."},{"declaration":"bool FVisible(const Vector& in vecOrigin)","documentation":"Returns whether this entity is visible from the given origin."},{"declaration":"bool FVisible(CBaseEntity@ pEntity, bool fIgnoreGlass)","documentation":"Returns whether this entity is visible to the given entity."},{"declaration":"int Illumination()","documentation":"Returns this entity's illumination."},{"declaration":"Vector BodyTarget(const Vector& in posSrc)","documentation":"Returns this entity's body target for shooting."},{"declaration":"Vector EarPosition()","documentation":"Returns this entity's ear position."},{"declaration":"Vector EyePosition()","documentation":"Returns this entity's eye position."},{"declaration":"Vector Center()","documentation":"Returns this entity's center."},{"declaration":"bool FBecomeProne()","documentation":"Makes this entity become prone."},{"declaration":"CBaseEntity@ Respawn()","documentation":"Respawns this entity."},{"declaration":"void UpdateOnRemove()","documentation":"Updates this entity when removed."},{"declaration":"void Blocked(CBaseEntity@ pOther)","documentation":"Triggers this entity's blocked function."},{"declaration":"void Use(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f)","documentation":"Trigger's this entity's use function."},{"declaration":"void Touch(CBaseEntity@ pOther)","documentation":"Triggers this entity's touch function."},{"declaration":"void Think()","documentation":"Makes this entity think. Do not call directly."},{"declaration":"CBaseEntity@ GetNextTarget()","documentation":"Gets the next target to trigger."},{"declaration":"bool CriticalRemove()","documentation":"Removes this entity in critical situations."},{"declaration":"bool IsMachine()","documentation":"Returns whether this is a machine."},{"declaration":"bool IsPointEnt()","documentation":"Returns whether this is a point entity."},{"declaration":"bool IsNetClient()","documentation":"Returns whether this is a net client."},{"declaration":"bool IsPlayer()","documentation":"Returns whether this entity is a player."},{"declaration":"bool IsMonster()","documentation":"Returns whether this entity is a monster."},{"declaration":"bool IsInWorld()","documentation":"Returns whether this entity is in the world."},{"declaration":"bool ReflectGauss()","documentation":"Returns whether this entity reflects gauss shots."},{"declaration":"bool IsBSPModel()","documentation":"Returns whether this entity is a BSP model."},{"declaration":"bool IsAlive()","documentation":"Returns whether this entity is alive."},{"declaration":"bool IsSneaking()","documentation":"Returns whether this entity is sneaking."},{"declaration":"bool OnControls(entvars_t@ pev)","documentation":"Reacts to controls set on the pev."},{"declaration":"void StopSneaking()","documentation":"Stops sneaking."},{"declaration":"void StartSneaking()","documentation":"Starts sneaking."},{"declaration":"void SetToggleState(int state)","documentation":"Sets this entity's toggle state."},{"declaration":"int DamageDecal(int bitsDamageType)","documentation":"Returns the damage decal<br/>See decal_e."},{"declaration":"void OverrideReset()","documentation":"Resets this entity."},{"declaration":"bool IsMoving()","documentation":"Returns whether this entity is moving."},{"declaration":"float GetDelay()","documentation":"Gets this entity's trigger delay."},{"declaration":"bool RemovePlayerItem(CBasePlayerItem@ pItem)","documentation":"Removes the given player item to this entity."},{"declaration":"AddPlayerItemResult AddPlayerItem(CBasePlayerItem@ pItem)","documentation":"Adds the given player item to this entity."},{"declaration":"void AddPointsToTeam(int score, const bool bAllowNegativeScore)","documentation":"Adds points to this entity's team."},{"declaration":"void AddPoints(int score, const bool bAllowNegativeScore)","documentation":"Adds points to this entity."},{"declaration":"int GetToggleState()","documentation":"Gets the toggle state.<br/>See the TOGGLE_STATE enum."},{"declaration":"bool SetupModel()","documentation":"Sets up the model."},{"declaration":"int entindex()","documentation":"Returns this entity's index."},{"declaration":"edict_t@ edict()","documentation":"Returns this entity's edict."},{"declaration":"bool IsLockedByMaster()","documentation":"Returns whether this entity is locked by its master."},{"declaration":"bool IsDormant()","documentation":"Returns whether this entity is dormant."},{"declaration":"void MakeDormant()","documentation":"Makes this entity dormant."},{"declaration":"bool Intersects(CBaseEntity@ pOther)","documentation":"Returns whether this entity intersects with the given entity."},{"declaration":"void FireBullets(uint cShots, Vector vecSrc, Vector vecDirShooting, Vector vecSpread,float flDistance, Bullet iBulletType, int iTracerFreq = 4, int iDamage = 0, entvars_t@ pevAttacker = null, FireBulletsDrawMode fDraw = FBDM_DRAW)","documentation":"Fires bullets. Must call CMath::MakeAimVectors with an angle vector first."},{"declaration":"bool ShouldToggle(USE_TYPE useType, const bool currentState)","documentation":"Returns whether this entity should toggle."},{"declaration":"void SUB_CallUseToggle()","documentation":"Think function. Calls use toggle on this entity."},{"declaration":"void SUB_FadeOut()","documentation":"Think function. Fades this entity."},{"declaration":"void SUB_StartFadeOut()","documentation":"Think function. Starts fading this entity."},{"declaration":"void SUB_DoNothing()","documentation":"Think function. Explicitly does nothing."},{"declaration":"void SUB_Remove()","documentation":"Think function. Delay-removes this entity."},{"declaration":"bool BlockedByEntity(CBaseEntity@ pOther, float flDamage)","documentation":"Returns true if you should be blocked by the entity, false otherwise. Also deals blocking damage to the entity, if applicable."},{"declaration":"CustomKeyvalues@ GetCustomKeyvalues()","documentation":"Gets this entity's custom keyvalues."},{"declaration":"CBaseMonster@ MyMonsterPointer()","documentation":"Returns this entity as its monster entity, if it is a monster."},{"declaration":"bool IsTriggered(CBaseEntity@ pActivator)","documentation":"Returns whether this entity is triggered by the given entity."},{"declaration":"int BloodColor()","documentation":"Returns the blood color. See the BLOOD_COLOR enum."},{"declaration":"void Killed(entvars_t@pevAtttacker, int iGibbed)","documentation":"Tells this entity it's been killed. See the GIB enum for possible values."},{"declaration":"bool TakeArmor(float flArmor, int bitsDamageType, int armor_cap = 0)","documentation":"Takes armor from this entity. Note: flArmor is added to entity armor. Use negative values to subtract.If armor_cap is non-zero, won't add more than armor_cap. Returns 1 if it took damage, 0 otherwise."},{"declaration":"bool TakeHealth(float flHealth, int bitsDamageType, int health_cap = 0)","documentation":"Takes health from this entity. Note: flHealth is added to entity health. Use negative values to subtract.If health_cap is non-zero, won't add more than health_cap. Returns true if it took damage, false otherwise."},{"declaration":"int TakeDamage(entvars_t@ pevInflictor, entvars_t@ pevAttacker, float flDamage, int bitsDamageType)","documentation":"Causes this entity to take damage. Returns 1 if it took damage, 0 otherwise."},{"declaration":"int Classify()","documentation":"Gets this entity's classification."},{"declaration":"int IRelationshipByClass(CLASS iClass)","documentation":"Gets the relationship between this entity and the given entity classification. See the RELATIONSHIP enum."},{"declaration":"int IRelationship(CBaseEntity@ other)","documentation":"Gets the relationship between this entity and the given entity. See the RELATIONSHIP enum."},{"declaration":"void ClearClassification()","documentation":"Clears this entity's classification override."},{"declaration":"void SetClassificationFromEntity(CBaseEntity@ pEntity)","documentation":"Sets this entity's classification override to the classification override set on the given entity. Can override the entity's player ally setting."},{"declaration":"void SetClassification(int cl)","documentation":"Sets this entity's classification override. Can override the entity's player ally setting."},{"declaration":"int GetClassification(int cl)","documentation":"Gets this entity's classification. Returns the given value if none is set. See the CLASSIFICATION enum."},{"declaration":"void SetObjectCollisionBox()","documentation":"Sets up the object collision box."},{"declaration":"int ObjectCaps()","documentation":"Gets this entity's objects caps. See the FCAP enum."},{"declaration":"void Precache()","documentation":"Precaches the entity. Do not call directly."},{"declaration":"bool opEquals(CBaseEntity@ pOther)","documentation":"Compares 2 entities for equality."},{"declaration":"void SetPlayerAllyDirect(bool fState)","documentation":"Sets this entity's player ally status.</br>Use this only if you need the setting to be exactly what you give it (e.g. when copying from another monster)"},{"declaration":"void SetPlayerAlly(bool fState)","documentation":"Sets this entity's player ally status."},{"declaration":"bool IsPlayerAlly() const","documentation":"Returns whether this entity is allied to players."},{"declaration":"int FindMonstersInWorld(array<CBaseEntity@>@ pArray, int flagMask)","documentation":"Finds monsters in the world"},{"declaration":"string SOUNDREPLACEMENT_Find(const string& in szFilename)","documentation":"Find sound replacement for the given file."},{"declaration":"bool FVisibleFromPos(const Vector& in vecTarget, const Vector& in vecStart)","documentation":"Returns whether this entity is visible from the given position."},{"declaration":"string GetTargetname() const","documentation":"Returns this entity's target name."},{"declaration":"string GetClassname() const","documentation":"Returns this entity's class name."},{"declaration":"string TeamID()","documentation":"Returns this entity's team ID."},{"declaration":"bool HasTarget(const string& in szTarget)","documentation":"Returns whether this entity has the given target."},{"declaration":"int GiveAmmo(int iAmount, const string& in szName, int iMax, const bool fFromWeapon = true)","documentation":"Gives ammo to this entity."},{"declaration":"void TraceBleed(float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)","documentation":"Traces entity bleed event."},{"declaration":"void TraceAttack(entvars_t@ pevAttacker, float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)","documentation":"Traces an attack by the given entity to this entity."},{"declaration":"bool KeyValue(const string& in szKeyName, const string& in szValue)","documentation":"Sets keyvalue data on this entity"},{"declaration":"void SetOrigin(const Vector& in vecOrigin)","documentation":"Sets this entity's (absolute) origin"},{"declaration":"const Vector& GetOrigin() const","documentation":"Gets the entity's (absolute) origin."},{"declaration":"CBaseEntity@ opImplCast()","documentation":"Implicitly casts to base type."},{"declaration":"CBaseDelay@ opImplCast()","documentation":"Implicitly casts to base type."},{"declaration":"CBaseAnimating@ opImplCast()","documentation":"Implicitly casts to base type."},{"declaration":"CBaseToggle@ opImplCast()","documentation":"Implicitly casts to base type."},{"declaration":"CBaseMonster@ opImplCast()","documentation":"Implicitly casts to base type."}],"properties":[{"namespace":"","declaration":"float m_flMoveToRadius","documentation":"When in radius, script is done."},{"namespace":"","declaration":"bool m_interruptable","documentation":"Whether this scripted sequence can be interrupted."},{"namespace":"","declaration":"float m_startTime","documentation":"When to start the script."},{"namespace":"","declaration":"int m_iDelay","documentation":"Delay before execution."},{"namespace":"","declaration":"float m_flRepeat","documentation":"How much time has to pass before the scripted sequence can repeat."},{"namespace":"","declaration":"float m_flRadius","documentation":"The radius to search in."},{"namespace":"","declaration":"string_t m_iszEntity","documentation":"The target entity name."},{"namespace":"","declaration":"string_t m_iszPlay","documentation":"The play animation name."},{"namespace":"","declaration":"string_t m_iszIdle","documentation":"Te idle animation name."},{"namespace":"","declaration":"string_t m_iszGuardEntName","documentation":"Guard entity name."},{"namespace":"","declaration":"EHandle m_pGuardEnt","documentation":"Monster will guard this entity and turn down follow requests."},{"namespace":"","declaration":"float m_flFallVelocity","documentation":"Current fall speed."},{"namespace":"","declaration":"float m_flAutomaticAttackTime","documentation":"How long an npc will attempt to fire full auto."},{"namespace":"","declaration":"bool m_fCanFearCreatures","documentation":"Whether this monster can fear creatures."},{"namespace":"","declaration":"int8 m_chTextureType","documentation":"Current texture type.<br/>See TextureType enum."},{"namespace":"","declaration":"string_t m_FormattedName","documentation":"The formatted name.<br/>For better name outputs. E.g. \"Alien Slave\" rather than \"alien_slave\"."},{"namespace":"","declaration":"float m_useTime","documentation":"Don't allow +USE until this time."},{"namespace":"","declaration":"CBaseEntity@ m_pCineBlocker","documentation":"Entity that is blocking cinematic execution."},{"namespace":"","declaration":"CCineMonster@ m_pCine","documentation":"Cinematic entity."},{"namespace":"","declaration":"SCRIPTSTATE m_scriptState","documentation":"internal cinematic state."},{"namespace":"","declaration":"Vector m_HackedGunPos","documentation":"HACK until we can query end of gun."},{"namespace":"","declaration":"string_t m_iszTriggerTarget","documentation":"Name of target that should be fired."},{"namespace":"","declaration":"int m_iTriggerCondition","documentation":"for scripted AI, this is the condition that will cause the activation of the monster's TriggerTarget."},{"namespace":"","declaration":"float m_flDistLook","documentation":"distance monster sees (Default 2048)."},{"namespace":"","declaration":"float m_flDistTooFar","documentation":"if enemy farther away than this, bits_COND_ENEMY_TOOFAR set in CheckEnemy."},{"namespace":"","declaration":"float m_flHungryTime","documentation":"Time based damage inflictor."},{"namespace":"","declaration":"int m_failSchedule","documentation":"Schedule type to choose if current schedule fails."},{"namespace":"","declaration":"entvars_t@ pevTimeBasedInflictor","documentation":"Time based damage inflictor."},{"namespace":"","declaration":"float m_tbdPrev","documentation":"Time-based damage timer."},{"namespace":"","declaration":"float m_lastDamageAmount","documentation":"how much damage did monster (player) last take."},{"namespace":"","declaration":"int m_bitsDamageType","documentation":"what types of damage has monster (player) taken."},{"namespace":"","declaration":"float m_flNextAttack","documentation":"cannot attack again until this time."},{"namespace":"","declaration":"int m_afMoveShootCap","documentation":"tells us what a monster can/can't do, while moving."},{"namespace":"","declaration":"int m_afCapability","documentation":"tells us what a monster can/can't do."},{"namespace":"","declaration":"int m_cAmmoLoaded","documentation":"how much ammo is in the weapon (used to trigger reload anim sequences)."},{"namespace":"","declaration":"Vector m_vecEnemyLKP","documentation":"last known position of enemy. (enemy's origin)."},{"namespace":"","declaration":"int m_iMaxHealth","documentation":"keeps track of monster's maximum health value (for re-healing, etc)."},{"namespace":"","declaration":"int m_bloodColor","documentation":"color of blood particles."},{"namespace":"","declaration":"int m_afMemory","documentation":"Monster memory."},{"namespace":"","declaration":"int m_iHintNode","documentation":"this is the hint node that the monster is moving towards or performing active idle on.."},{"namespace":"","declaration":"Vector m_vecLastPosition","documentation":"monster sometimes wants to return to where it started after an operation.."},{"namespace":"","declaration":"int m_afSoundTypes","documentation":"Sound types that can be heard."},{"namespace":"","declaration":"int m_iAudibleList","documentation":"first index of a linked list of sounds that the monster can hear."},{"namespace":"","declaration":"Activity m_movementActivity","documentation":"When moving, set this activity."},{"namespace":"","declaration":"Vector m_vecMoveGoal","documentation":"Kept around for node graph moves, so we know our ultimate goal."},{"namespace":"","declaration":"float m_moveradius","documentation":"Minimum radius."},{"namespace":"","declaration":"float m_moveWaitTime","documentation":"How long I should wait for something to move."},{"namespace":"","declaration":"int m_iRouteIndex","documentation":"Index into m_Route[]."},{"namespace":"","declaration":"int m_movementGoal","documentation":"Goal that defines route."},{"namespace":"","declaration":"int m_iScheduleIndex","documentation":"Schedule index."},{"namespace":"","declaration":"Schedule@ m_pScheduleSaved","documentation":"For land_on_ground schedules (remember last schedule and continue)."},{"namespace":"","declaration":"Schedule@ m_pSchedule","documentation":"Current schedule."},{"namespace":"","declaration":"int m_iTaskStatus","documentation":"Task status."},{"namespace":"","declaration":"MONSTERSTATE m_IdealMonsterState","documentation":"monster should change to this state."},{"namespace":"","declaration":"MONSTERSTATE m_MonsterState","documentation":"monster's current state."},{"namespace":"","declaration":"int m_LastHitGroup","documentation":"the last body region that took damage."},{"namespace":"","declaration":"Activity m_GaitActivity","documentation":"gaitsequence."},{"namespace":"","declaration":"Activity m_IdealActivity","documentation":"monster should switch to this activity."},{"namespace":"","declaration":"Activity m_Activity","documentation":"what the monster is doing (animation)."},{"namespace":"","declaration":"float m_flMoveWaitFinished","documentation":"if we're told to wait before moving, this is the time that the wait will be over."},{"namespace":"","declaration":"float m_flWaitFinished","documentation":"if we're told to wait, this is the time that the wait will be over."},{"namespace":"","declaration":"float m_flFieldOfView","documentation":"width of monster's field of view ( dot product )."},{"namespace":"","declaration":"EHandle m_hTargetTank","documentation":"Target tank to control."},{"namespace":"","declaration":"EHandle m_hTargetEnt","documentation":"the entity that the monster is trying to reach."},{"namespace":"","declaration":"EHandle m_hEnemy","documentation":"the entity that the monster is fighting."},{"namespace":"","declaration":"string_t m_sMaster","documentation":"This entity's master, if any."},{"namespace":"","declaration":"int m_bitsDamageInflict","documentation":"DMG_ damage type that the door or trigger does."},{"namespace":"","declaration":"Vector m_vecFinalAngle","documentation":"Final angle."},{"namespace":"","declaration":"Vector m_vecFinalDest","documentation":"Final destination."},{"namespace":"","declaration":"Vector m_vecAngle2","documentation":"Open angle."},{"namespace":"","declaration":"Vector m_vecAngle1","documentation":"Closed angle."},{"namespace":"","declaration":"Vector m_vecPosition2","documentation":"Open position."},{"namespace":"","declaration":"Vector m_vecPosition1","documentation":"Closed position."},{"namespace":"","declaration":"EHandle m_hActivator","documentation":"Handle to the activator."},{"namespace":"","declaration":"float m_flHeight","documentation":"Height."},{"namespace":"","declaration":"int m_cTriggersLeft","documentation":"Trigger_counter only: # of activations remaining."},{"namespace":"","declaration":"float m_flTLength","documentation":"For plats."},{"namespace":"","declaration":"float m_flTWidth","documentation":"For plats."},{"namespace":"","declaration":"float m_flLip","documentation":"How much to stick out of a wall. Will recede further into walls if negative."},{"namespace":"","declaration":"float m_flWait","documentation":"How long to wait before resetting."},{"namespace":"","declaration":"float m_flMoveDistance","documentation":"How far a door should slide or rotate."},{"namespace":"","declaration":"TOGGLE_STATE m_toggle_state","documentation":"Current toggle state."},{"namespace":"","declaration":"bool m_fSequenceLoops","documentation":"True if the sequence loops."},{"namespace":"","declaration":"bool m_fSequenceFinished","documentation":"Flag set when StudioAdvanceFrame moves across a frame boundry."},{"namespace":"","declaration":"float m_flLastGaitEventCheck","documentation":"Last time the event list was checked."},{"namespace":"","declaration":"float m_flLastEventCheck","documentation":"Last time the event list was checked."},{"namespace":"","declaration":"float m_flGroundSpeed","documentation":"Computed linear movement rate for current sequence."},{"namespace":"","declaration":"float m_flFrameRate","documentation":"Computed FPS for current sequence."},{"namespace":"","declaration":"string_t m_iszKillTarget","documentation":"The name of the kill target, if any."},{"namespace":"","declaration":"float m_flDelay","documentation":"Delay before fire."},{"namespace":"","declaration":"Vector m_vecOriginalRenderColor","documentation":"Original render color."},{"namespace":"","declaration":"float m_flOriginalRenderAmount","documentation":"Original render amount."},{"namespace":"","declaration":"int m_iOriginalRenderFX","documentation":"Original render FX."},{"namespace":"","declaration":"int m_iOriginalRenderMode","documentation":"Original render model."},{"namespace":"","declaration":"string_t classnameInFilterType","documentation":"Class name in filter type."},{"namespace":"","declaration":"string_t targetnameInFilterType","documentation":"Target name in filter type."},{"namespace":"","declaration":"string_t classnameOutFilterType","documentation":"Class name out filter type."},{"namespace":"","declaration":"string_t targetnameOutFilterType","documentation":"Target name out filter type."},{"namespace":"","declaration":"Vector m_vecLastOrigin","documentation":"Last origin vector"},{"namespace":"","declaration":"bool m_fCustomModel","documentation":"Whether a custom model is used."},{"namespace":"","declaration":"bool m_fCanFadeStart","documentation":"Whether fading can start."},{"namespace":"","declaration":"float m_flMaximumFadeWaitB","documentation":"Maximum fade wait time B."},{"namespace":"","declaration":"float m_flMaximumFadeWait","documentation":"Maximum fade wait time."},{"namespace":"","declaration":"int m_iClassSelection","documentation":"The overridden classification."},{"namespace":"","declaration":"bool m_fOverrideClass","documentation":"Whether this entity overrides the classification."},{"namespace":"","declaration":"entvars_t@ pev","documentation":"Entity variables"}],"className":"CCineMonster","documentation":"Cinematic monster entity base class","namespace":""},{"flags":262145,"methods":[{"declaration":"CGrenade@ opCast()","documentation":"Explicitly casts to sub type."},{"declaration":"CBasePlayer@ opCast()","documentation":"Explicitly casts to sub type."},{"declaration":"CCineMonster@ opCast()","documentation":"Explicitly casts to sub type."},{"declaration":"void ClearEnemyList()","documentation":"Clears this monster's list of enemies"},{"declaration":"InventoryList@ get_m_pInventory() const","documentation":"The inventory items this monster has"},{"declaration":"void MedicCallSound(float flDistance = 0.0f)","documentation":"Medic call sound."},{"declaration":"string m_szTextureName()","documentation":"Current texture name we're standing on."},{"declaration":"void StopPlayerFollowing(const bool bClearSchedule)","documentation":"Stops following a player."},{"declaration":"void StartPlayerFollowing(CBaseEntity@ pLeader)","documentation":"Starts following a given player."},{"declaration":"bool CanPlayerFollow()","documentation":"Returns whether this monster can follow a player."},{"declaration":"bool IsPlayerFollowing()","documentation":"Returns whether this monster is following a player."},{"declaration":"void FollowerPlayerUse(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue)","documentation":"Use method for following players (set only if friendly)"},{"declaration":"void ShockGlowEffect(bool fMode)","documentation":"Turns the shock glow effect on or off."},{"declaration":"CBaseEntity@ DropItem(const string& in szItemName, const Vector& in vecPos, const Vector& in vecAng)","documentation":"Drops the given item from the given position at the given angle."},{"declaration":"bool CineCleanup()","documentation":"Cleans up after a cinematic event."},{"declaration":"bool ExitScriptedSequence()","documentation":"Exits the scripted sequence this monster is currently in, if any."},{"declaration":"bool HasAllMemories(int iMemory) const","documentation":"Returns whether this monster remembers all of the given memories."},{"declaration":"bool HasMemory(int iMemory) const","documentation":"Returns whether this monster remembers any of the given memories."},{"declaration":"void Forget(int iMemory)","documentation":"Makes this monster forget the given memories."},{"declaration":"void Remember(int iMemory)","documentation":"Makes this monster remember the given memories."},{"declaration":"void StopFollowing(const bool clearSchedule)","documentation":"Stops following its target."},{"declaration":"void PainSound()","documentation":"Plays this monster's pain sound."},{"declaration":"void IdleSound()","documentation":"Plays this monster's idle sound."},{"declaration":"void AlertSound()","documentation":"Plays this monster's alert sound."},{"declaration":"void DeathSound()","documentation":"Plays this monster's death sound."},{"declaration":"Vector GetGunPosition()","documentation":""},{"declaration":"Vector ShootAtEnemy(const Vector& in vecShootOrigin)","documentation":"Shoots at the specified location."},{"declaration":"void FadeMonster()","documentation":"Fades this monster.<br/>Note: does not kill the monster."},{"declaration":"bool HasAlienGibs()","documentation":"Returns whether this monster has alien gibs."},{"declaration":"bool HasHumanGibs()","documentation":"Returns whether this monster has human gibs."},{"declaration":"void CallGibMonster()","documentation":"Determines whether to gib or fade this monster, and acts accordingly."},{"declaration":"bool ShouldGibMonster(int iGib)","documentation":"Returns whether the monster should be gibbed given the gib type.<br/>See GIB enum."},{"declaration":"void GibMonster()","documentation":"Gibs the monster."},{"declaration":"bool GetEnemy()","documentation":"Tries to find the best suitable enemy for this monster."},{"declaration":"bool NoFriendlyFireToPos(Vector vecPos)","documentation":"Returns whether attacking the target location at this time would result in friendly fire"},{"declaration":"bool NoFriendlyFire(Vector vecPos, CBaseEntity@ pTarget)","documentation":"Returns whether attacking the given target at this time from the given location would result in friendly fire"},{"declaration":"bool NoFriendlyFire(Vector vecPos)","documentation":"Returns whether attacking at this time from the given location would result in friendly fire"},{"declaration":"bool NoFriendlyFire()","documentation":"Returns whether attacking at this time would result in friendly fire"},{"declaration":"bool FCheckAITrigger()","documentation":"Checks and, if necessary, fires the monster's trigger target."},{"declaration":"void Eat(float flFullDuration)","documentation":"Make the monster 'full' for a while."},{"declaration":"bool FShouldEat()","documentation":"Returns whether this monster should eat."},{"declaration":"CSound@ PBestSound()","documentation":"Returns a pointer to the sound the monster should react to."},{"declaration":"bool HasAllConditions(int iConditions) const","documentation":"Returns whether this monster has all of the given AI conditions."},{"declaration":"bool HasConditions(int iConditions) const","documentation":"Returns whether this monster has any of the given AI conditions."},{"declaration":"void ClearConditions(int iConditions)","documentation":"Clears AI conditions."},{"declaration":"void SetConditions(int iConditions)","documentation":"Sets AI conditions."},{"declaration":"bool CheckAttacker(CBaseEntity@ pAttacker)","documentation":"Determine if we should ignore damage."},{"declaration":"int RouteClassify(int iMoveFlag)","documentation":"Returns the MOVEGOAL for the given move flag."},{"declaration":"void SetYawSpeed()","documentation":"Allows different yaw_speeds for each activity."},{"declaration":"void MakeIdealYaw(Vector vecTarget)","documentation":"gets a yaw value for the caller that would<br/>face the supplied vector. Value is stuffed into the monster's<br/>ideal_yaw."},{"declaration":"int IScheduleFlags()","documentation":"Returns an integer with all Conditions<br/>bits that are currently set and also set in the current<br/>schedule's Interrupt mask."},{"declaration":"bool MovementIsComplete()","documentation":"Returns whether movement is complete."},{"declaration":"bool TaskIsComplete()","documentation":"Returns whether the task is complete."},{"declaration":"bool TaskIsRunning()","documentation":"Returns whether a task is running."},{"declaration":"void TaskBegin()","documentation":"Sets the task status to running."},{"declaration":"void TaskFail()","documentation":"Sets the condition bit for a failed task."},{"declaration":"void MovementComplete()","documentation":"Called when movement has completed."},{"declaration":"void TaskComplete()","documentation":"Sets the task status to complete."},{"declaration":"bool TestFGetNodeRoute(Vector vecDest)","documentation":"TEST FGetNodeRoute."},{"declaration":"bool FGetNodeRoute(Vector vecDest)","documentation":"tries to build an entire node path from<br/>the callers origin to the passed vector.<br/>If this is  possible, ROUTE_SIZE waypoints will be copied into the callers m_Route.<br/>true is returned if the operation  succeeds (path is valid) or false if failed (no path  exists )."},{"declaration":"bool PopEnemy()","documentation":"Try remembering the last few enemies."},{"declaration":"void PushEnemy(CBaseEntity@ pTarget, Vector& in vecLastKnownPos)","documentation":"Remember the last few enemies, always remember the player."},{"declaration":"bool CheckEnemy(CBaseEntity@ pEnemy)","documentation":"part of the Condition collection process, gets and stores data and conditions pertaining to a monster's enemy.<br/>Returns true if Enemy LKP was updated."},{"declaration":"bool CheckAttacksFromPosition(CBaseEntity@ pTarget, float flDist, Vector vecPos)","documentation":"Check whether attacks are possible from the given position."},{"declaration":"void CheckAttacks_Move(CBaseEntity@ pTarget, float flDist)","documentation":"Check attacks to the given enemy at the given distance while moving."},{"declaration":"void CheckAttacks(CBaseEntity@ pTarget, float flDist)","documentation":"Check attacks to the given enemy at the given distance."},{"declaration":"void ReportAIState()","documentation":"Reports the AI state."},{"declaration":"void SetState(MONSTERSTATE state)","documentation":"Sets the current monster state."},{"declaration":"void SetSequenceByName(const string& in szSequence)","documentation":"Sets the current sequence by name."},{"declaration":"void SetGaitActivity(Activity newActivity)","documentation":"Sets the current gait activity."},{"declaration":"void SetActivity(Activity newActivity)","documentation":"Sets the current activity."},{"declaration":"MONSTERSTATE GetIdealState()","documentation":"Gets the ideal monster state."},{"declaration":"Task@ GetTask()","documentation":"Gets the current task."},{"declaration":"void SentenceStop()","documentation":"Stops playing its current sentence."},{"declaration":"void PlayScriptedSentence(const string& in szSentence, float duration, float volume, float attenuation, const bool bConcurrent, CBaseEntity@ pListener)","documentation":"Plays the given scripted sentence."},{"declaration":"void PlaySentence(const string& in szSentence, float duration, float volume, float attenuation)","documentation":"Plays the given sentence."},{"declaration":"bool CanPlaySentence(const bool bDisregardState)","documentation":"Returns whether this monster can play its sentence."},{"declaration":"bool CanPlaySequence(const bool bDisregardState, int iInterruptLevel)","documentation":"Returns whether this monster can play its sequence."},{"declaration":"void ScheduleChange()","documentation":"Called after the monster's schedule changes."},{"declaration":"Schedule@ GetSchedule()","documentation":"Gets the current schedule."},{"declaration":"Schedule@ GetScheduleOfType(int iType)","documentation":"Gets one of the available schedules of the given type."},{"declaration":"void RunTask(Task@ pTask)","documentation":"Runs the given task."},{"declaration":"void StartTask(Task@ pTask)","documentation":"Starts the given task."},{"declaration":"void MaintainSchedule()","documentation":"Maintains the monster's schedule."},{"declaration":"Schedule@ ScheduleFromName(const string& in szName)","documentation":"Returns the schedule with name szName if it exists, NULL otherwise."},{"declaration":"Schedule@ ScheduleInList(const string& in szName, array<Schedule@>@ pArray)","documentation":"Returns the schedule with name szName if it's in the list, NULL otherwise."},{"declaration":"bool NextScheduledTask()","documentation":"Moves to the next scheduled task."},{"declaration":"void ChangeSchedule(Schedule@ pNewSchedule)","documentation":"Changes this monster's schedule."},{"declaration":"bool FScheduleDone()","documentation":"Returns whether this monster's schedule is done."},{"declaration":"void ClearSchedule()","documentation":"Clears this monster's schedule."},{"declaration":"bool FScheduleValid()","documentation":"Returns whether this monster's schedule is valid."},{"declaration":"bool FHaveSchedule()","documentation":"Returns whether this monster has a schedule."},{"declaration":"bool CheckTankUsage()","documentation":"Checks whether the monster can use a func_tank. Return true if possible."},{"declaration":"bool CheckMeleeAttack2_Move(float flDot, float flDist)","documentation":"this function will survey conditions and set appropriate conditions bits for attack types."},{"declaration":"bool CheckMeleeAttack2(float flDot, float flDist)","documentation":"this function will survey conditions and set appropriate conditions bits for attack types."},{"declaration":"bool CheckMeleeAttack1_Move(float flDot, float flDist)","documentation":"this function will survey conditions and set appropriate conditions bits for attack types."},{"declaration":"bool CheckMeleeAttack1(float flDot, float flDist)","documentation":"this function will survey conditions and set appropriate conditions bits for attack types."},{"declaration":"bool CheckRangeAttack2_Move(float flDot, float flDist)","documentation":"this function will survey conditions and set appropriate conditions bits for attack types."},{"declaration":"bool CheckRangeAttack2(float flDot, float flDist)","documentation":"this function will survey conditions and set appropriate conditions bits for attack types."},{"declaration":"bool CheckRangeAttack1_Move(float flDot, float flDist)","documentation":"this function will survey conditions and set appropriate conditions bits for attack types."},{"declaration":"bool CheckRangeAttack1(float flDot, float flDist)","documentation":"this function will survey conditions and set appropriate conditions bits for attack types."},{"declaration":"void StopAnimation()","documentation":"This will stop animation until you call ResetSequenceInfo() at some point in the future"},{"declaration":"void Stop()","documentation":"Stops this monster moving"},{"declaration":"Activity GetStoppedActivity()","documentation":"Gets the stopped activity"},{"declaration":"bool ShouldAdvanceRoute(float flWaypointDist)","documentation":"Returns whether this monster should advance its route"},{"declaration":"void MoveExecute(CBaseEntity@ pTargetEnt, const Vector& in vecDir, float flInterval)","documentation":"Starts the monster"},{"declaration":"void Move(float flInterval = 0.1f)","documentation":"Starts the monster"},{"declaration":"int CheckLocalMove(const Vector& in vecStart, const Vector& in vecEnd,CBaseEntity@ pTarget, float& out flDist, Vector& out vecEndPosition, bool fOriginalCheck = false)","documentation":"finds best visible enemy for attack"},{"declaration":"bool FInViewCone(const Vector& in vecOrigin)","documentation":"see if given location is in monster's view cone"},{"declaration":"bool FInViewCone(CBaseEntity@ pEntity)","documentation":"see if pEntity is in monster's view cone"},{"declaration":"void BestVisibleEnemy()","documentation":"finds best visible enemy for attack"},{"declaration":"void StartMonster()","documentation":"Starts the monster"},{"declaration":"void Revive()","documentation":"Revives the monster"},{"declaration":"void BecomeDead(float flSavedHealth)","documentation":"Makes the monster become dead"},{"declaration":"void MonsterInitDead()","documentation":"Call after animation/pose is set up"},{"declaration":"void MonsterInit()","documentation":"Initializes the monster"},{"declaration":"void SetupFriendly()","documentation":"use this overridden to make some other friendly monsters"},{"declaration":"float DamageForce(float flDamage)","documentation":"Returns the amount of force applied to this monster when the given amount of damage is done."},{"declaration":"float FlYawDiff()","documentation":"returns the difference ( in degrees ) between monster's current yaw and ideal_yaw.<br/>Positive result is left turn, negative is right turn."},{"declaration":"float VecToYaw(Vector vecDir)","documentation":"turns a directional vector into a yaw value that points down that vector."},{"declaration":"float ChangeYaw(int iSpeed)","documentation":"turns a monster towards its ideal_yaw"},{"declaration":"bool ShouldFadeOnDeath()","documentation":"Returns whether this monster should fade on death."},{"declaration":"void Listen()","documentation":"Listens for anything that is within audible distance."},{"declaration":"void RunAI()","documentation":"Runs this monster's AI."},{"declaration":"void Look(int iDistance)","documentation":"Look - Base class monster function to find enemies or<br/>food by sight. iDistance is distance ( in units ) that the<br/>monster can see.<br/>Sets the sight bits of the m_afConditions mask to indicate<br/>which types of entities were sighted.<br/>Function also sets the Looker's m_pLink<br/>to the head of a link list that contains all visible ents.<br/>(linked via each ent's m_pLink field)"},{"declaration":"void MonsterUse(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f)","documentation":"Will make a monster angry at whomever activated it."},{"declaration":"int8& m_rgbTimeBasedDamage(size_t uiIndex)","documentation":"time based damage counters, decr. 1 per 2 seconds. Index must be between 0 and CMG_TIMEBASED."},{"declaration":"Waypoint& m_Route(size_t uiIndex)","documentation":"Positions of movement. Index must be between 0 and ROUTE_SIZE"},{"declaration":"Vector& m_vecOldEnemy(size_t uiIndex)","documentation":"Target tank to control. Index must be between 0 and MAX_OLD_ENEMIES."},{"declaration":"EHandle& m_hOldEnemy(size_t uiIndex)","documentation":"Target tank to control. Index must be between 0 and MAX_OLD_ENEMIES."},{"declaration":"InventoryRules@ get_m_pInventoryRules() const","documentation":"The inventory rules."},{"declaration":"bool IsToggleLockedByMaster()","documentation":"Returns whether this entity is locked by its master.<br/>Separate from IsLockedByMaster due to limitations."},{"declaration":"void AngularMove(Vector vecDestAngle, float flSpeed)","documentation":"Performs angular movement."},{"declaration":"void LinearMove(Vector vecDest, float flSpeed)","documentation":"Performs linear movement."},{"declaration":"int GetSequenceActivityName(int iSequence)","documentation":"Sets the sequence box."},{"declaration":"void SetSequenceBox()","documentation":"Sets the sequence box."},{"declaration":"int GetAttachmentCount()","documentation":"Gets the number of attachments that the current model has."},{"declaration":"bool ExtractBbox(int iSequence, Vector& out mins, Vector& out maxs)","documentation":"Extracts the bounding box of the current model."},{"declaration":"int GetBodygroup(int iGroup)","documentation":"Gets the value of the given body group."},{"declaration":"void SetBodygroup(int iGroup, int iValue)","documentation":"Sets the given body group to the given value."},{"declaration":"void GetAttachment(int iAttachment, Vector& out origin, Vector& out angles)","documentation":"Gets the attachment position."},{"declaration":"int FindTransition(int iEndingSequence, int iGoalSequence)","documentation":"Find the transition between 2 sequences."},{"declaration":"int FindTransition(int iEndingSequence, int iGoalSequence, int& out iDir)","documentation":"Find the transition between 2 sequences."},{"declaration":"void GetAutomovement(Vector& out origin, Vector& out angles, float flInterval = 0.1f)","documentation":"Gets automatic movement."},{"declaration":"void GetBonePosition(int iBone, Vector& out origin, Vector& out angles)","documentation":"Gets the position of the given bone."},{"declaration":"float SetBlending(int iBlender, float flValue)","documentation":"Sets the given blending controller to the given value."},{"declaration":"void InitBoneControllers()","documentation":"Initializes bone controllers."},{"declaration":"float SetBoneController(int iController, float flValue)","documentation":"Sets the specified bone controller to the given value."},{"declaration":"void DispatchAnimEvents(float flFutureInterval = 0.1f)","documentation":"Handle events that have happend since last time called up until X seconds into the future."},{"declaration":"void ResetGaitSequenceInfo()","documentation":"Resets gait sequence info."},{"declaration":"void ResetSequenceInfo()","documentation":"Resets sequence info."},{"declaration":"int LookupSequence(const string& in szLabel)","documentation":"Returns the index of the given sequence, or -1 if no such sequence exists."},{"declaration":"int LookupActivityHeaviest(int iActivity)","documentation":"Returns the index of the given activity that has the heaviest weight, or -1 if no such activity exists."},{"declaration":"int LookupActivity(int iActivity)","documentation":"Returns the index of the given activity, or -1 if no such activity exists."},{"declaration":"int GetSequenceFlags()","documentation":"Get sequence flags."},{"declaration":"float StudioFrameAdvance(float flInterval = 0.0f)","documentation":"Accumulate animation frame time from last time called until now."},{"declaration":"void DelayThink()","documentation":"Think function. Used internally."},{"declaration":"void SUB_UseTargets(CBaseEntity@ pActivator, USE_TYPE useType, float flValue)","documentation":"Causes this entity to trigger its targets with an optional delay."},{"declaration":"void ClearUserData()","documentation":"Clears the user data on this entity. WARNING: clears all data.<br/>Only map scripts can use this."},{"declaration":"dictionaryValue& GetUserData(const string& in szKey)","documentation":"Gets the user data stored under the specified key on this entity.<br/>Do not keep references to this data, the object might be removed from this entity.<br/>Only map scripts can use this."},{"declaration":"dictionary@ GetUserData()","documentation":"Gets the user data on this entity. Do not keep references to this data, the object might be removed from this entity.<br/>Only map scripts can use this."},{"declaration":"void EndRevive(float flTimeUntilRevive)","documentation":"Called when this entity should be revived. flTimeUntilRevive is the time until the revival should start."},{"declaration":"void BeginRevive(float flTimeUntilRevive)","documentation":"Prepares this entity for revival. flTimeUntilRevive is the time until the revive action completes."},{"declaration":"bool IsRevivable()","documentation":"Returns whether this entity is revivable at this time."},{"declaration":"void OnDestroy()","documentation":"Entity destructor."},{"declaration":"void OnCreate()","documentation":"Entity constructor."},{"declaration":"void GetDamagePoints(entvars_t@ pevAttacker, entvars_t@ pevInflictor, float flDamage)","documentation":"Adds damage points to the inflicting entity."},{"declaration":"float GetPointsForDamage(float flDamage)","documentation":"Returns the points received for damage done."},{"declaration":"bool IsFacing(entvars_t@ pevTest, float flDotProduct = VIEW_FIELD_ULTRA_NARROW)","documentation":"Returns whether this entity is facing the given entity, within the given view field."},{"declaration":"bool FVisible(const Vector& in vecOrigin)","documentation":"Returns whether this entity is visible from the given origin."},{"declaration":"bool FVisible(CBaseEntity@ pEntity, bool fIgnoreGlass)","documentation":"Returns whether this entity is visible to the given entity."},{"declaration":"int Illumination()","documentation":"Returns this entity's illumination."},{"declaration":"Vector BodyTarget(const Vector& in posSrc)","documentation":"Returns this entity's body target for shooting."},{"declaration":"Vector EarPosition()","documentation":"Returns this entity's ear position."},{"declaration":"Vector EyePosition()","documentation":"Returns this entity's eye position."},{"declaration":"Vector Center()","documentation":"Returns this entity's center."},{"declaration":"bool FBecomeProne()","documentation":"Makes this entity become prone."},{"declaration":"CBaseEntity@ Respawn()","documentation":"Respawns this entity."},{"declaration":"void UpdateOnRemove()","documentation":"Updates this entity when removed."},{"declaration":"void Blocked(CBaseEntity@ pOther)","documentation":"Triggers this entity's blocked function."},{"declaration":"void Use(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f)","documentation":"Trigger's this entity's use function."},{"declaration":"void Touch(CBaseEntity@ pOther)","documentation":"Triggers this entity's touch function."},{"declaration":"void Think()","documentation":"Makes this entity think. Do not call directly."},{"declaration":"CBaseEntity@ GetNextTarget()","documentation":"Gets the next target to trigger."},{"declaration":"bool CriticalRemove()","documentation":"Removes this entity in critical situations."},{"declaration":"bool IsMachine()","documentation":"Returns whether this is a machine."},{"declaration":"bool IsPointEnt()","documentation":"Returns whether this is a point entity."},{"declaration":"bool IsNetClient()","documentation":"Returns whether this is a net client."},{"declaration":"bool IsPlayer()","documentation":"Returns whether this entity is a player."},{"declaration":"bool IsMonster()","documentation":"Returns whether this entity is a monster."},{"declaration":"bool IsInWorld()","documentation":"Returns whether this entity is in the world."},{"declaration":"bool ReflectGauss()","documentation":"Returns whether this entity reflects gauss shots."},{"declaration":"bool IsBSPModel()","documentation":"Returns whether this entity is a BSP model."},{"declaration":"bool IsAlive()","documentation":"Returns whether this entity is alive."},{"declaration":"bool IsSneaking()","documentation":"Returns whether this entity is sneaking."},{"declaration":"bool OnControls(entvars_t@ pev)","documentation":"Reacts to controls set on the pev."},{"declaration":"void StopSneaking()","documentation":"Stops sneaking."},{"declaration":"void StartSneaking()","documentation":"Starts sneaking."},{"declaration":"void SetToggleState(int state)","documentation":"Sets this entity's toggle state."},{"declaration":"int DamageDecal(int bitsDamageType)","documentation":"Returns the damage decal<br/>See decal_e."},{"declaration":"void OverrideReset()","documentation":"Resets this entity."},{"declaration":"bool IsMoving()","documentation":"Returns whether this entity is moving."},{"declaration":"float GetDelay()","documentation":"Gets this entity's trigger delay."},{"declaration":"bool RemovePlayerItem(CBasePlayerItem@ pItem)","documentation":"Removes the given player item to this entity."},{"declaration":"AddPlayerItemResult AddPlayerItem(CBasePlayerItem@ pItem)","documentation":"Adds the given player item to this entity."},{"declaration":"void AddPointsToTeam(int score, const bool bAllowNegativeScore)","documentation":"Adds points to this entity's team."},{"declaration":"void AddPoints(int score, const bool bAllowNegativeScore)","documentation":"Adds points to this entity."},{"declaration":"int GetToggleState()","documentation":"Gets the toggle state.<br/>See the TOGGLE_STATE enum."},{"declaration":"bool SetupModel()","documentation":"Sets up the model."},{"declaration":"int entindex()","documentation":"Returns this entity's index."},{"declaration":"edict_t@ edict()","documentation":"Returns this entity's edict."},{"declaration":"bool IsLockedByMaster()","documentation":"Returns whether this entity is locked by its master."},{"declaration":"bool IsDormant()","documentation":"Returns whether this entity is dormant."},{"declaration":"void MakeDormant()","documentation":"Makes this entity dormant."},{"declaration":"bool Intersects(CBaseEntity@ pOther)","documentation":"Returns whether this entity intersects with the given entity."},{"declaration":"void FireBullets(uint cShots, Vector vecSrc, Vector vecDirShooting, Vector vecSpread,float flDistance, Bullet iBulletType, int iTracerFreq = 4, int iDamage = 0, entvars_t@ pevAttacker = null, FireBulletsDrawMode fDraw = FBDM_DRAW)","documentation":"Fires bullets. Must call CMath::MakeAimVectors with an angle vector first."},{"declaration":"bool ShouldToggle(USE_TYPE useType, const bool currentState)","documentation":"Returns whether this entity should toggle."},{"declaration":"void SUB_CallUseToggle()","documentation":"Think function. Calls use toggle on this entity."},{"declaration":"void SUB_FadeOut()","documentation":"Think function. Fades this entity."},{"declaration":"void SUB_StartFadeOut()","documentation":"Think function. Starts fading this entity."},{"declaration":"void SUB_DoNothing()","documentation":"Think function. Explicitly does nothing."},{"declaration":"void SUB_Remove()","documentation":"Think function. Delay-removes this entity."},{"declaration":"bool BlockedByEntity(CBaseEntity@ pOther, float flDamage)","documentation":"Returns true if you should be blocked by the entity, false otherwise. Also deals blocking damage to the entity, if applicable."},{"declaration":"CustomKeyvalues@ GetCustomKeyvalues()","documentation":"Gets this entity's custom keyvalues."},{"declaration":"CBaseMonster@ MyMonsterPointer()","documentation":"Returns this entity as its monster entity, if it is a monster."},{"declaration":"bool IsTriggered(CBaseEntity@ pActivator)","documentation":"Returns whether this entity is triggered by the given entity."},{"declaration":"int BloodColor()","documentation":"Returns the blood color. See the BLOOD_COLOR enum."},{"declaration":"void Killed(entvars_t@pevAtttacker, int iGibbed)","documentation":"Tells this entity it's been killed. See the GIB enum for possible values."},{"declaration":"bool TakeArmor(float flArmor, int bitsDamageType, int armor_cap = 0)","documentation":"Takes armor from this entity. Note: flArmor is added to entity armor. Use negative values to subtract.If armor_cap is non-zero, won't add more than armor_cap. Returns 1 if it took damage, 0 otherwise."},{"declaration":"bool TakeHealth(float flHealth, int bitsDamageType, int health_cap = 0)","documentation":"Takes health from this entity. Note: flHealth is added to entity health. Use negative values to subtract.If health_cap is non-zero, won't add more than health_cap. Returns true if it took damage, false otherwise."},{"declaration":"int TakeDamage(entvars_t@ pevInflictor, entvars_t@ pevAttacker, float flDamage, int bitsDamageType)","documentation":"Causes this entity to take damage. Returns 1 if it took damage, 0 otherwise."},{"declaration":"int Classify()","documentation":"Gets this entity's classification."},{"declaration":"int IRelationshipByClass(CLASS iClass)","documentation":"Gets the relationship between this entity and the given entity classification. See the RELATIONSHIP enum."},{"declaration":"int IRelationship(CBaseEntity@ other)","documentation":"Gets the relationship between this entity and the given entity. See the RELATIONSHIP enum."},{"declaration":"void ClearClassification()","documentation":"Clears this entity's classification override."},{"declaration":"void SetClassificationFromEntity(CBaseEntity@ pEntity)","documentation":"Sets this entity's classification override to the classification override set on the given entity. Can override the entity's player ally setting."},{"declaration":"void SetClassification(int cl)","documentation":"Sets this entity's classification override. Can override the entity's player ally setting."},{"declaration":"int GetClassification(int cl)","documentation":"Gets this entity's classification. Returns the given value if none is set. See the CLASSIFICATION enum."},{"declaration":"void SetObjectCollisionBox()","documentation":"Sets up the object collision box."},{"declaration":"int ObjectCaps()","documentation":"Gets this entity's objects caps. See the FCAP enum."},{"declaration":"void Precache()","documentation":"Precaches the entity. Do not call directly."},{"declaration":"bool opEquals(CBaseEntity@ pOther)","documentation":"Compares 2 entities for equality."},{"declaration":"void SetPlayerAllyDirect(bool fState)","documentation":"Sets this entity's player ally status.</br>Use this only if you need the setting to be exactly what you give it (e.g. when copying from another monster)"},{"declaration":"void SetPlayerAlly(bool fState)","documentation":"Sets this entity's player ally status."},{"declaration":"bool IsPlayerAlly() const","documentation":"Returns whether this entity is allied to players."},{"declaration":"int FindMonstersInWorld(array<CBaseEntity@>@ pArray, int flagMask)","documentation":"Finds monsters in the world"},{"declaration":"string SOUNDREPLACEMENT_Find(const string& in szFilename)","documentation":"Find sound replacement for the given file."},{"declaration":"bool FVisibleFromPos(const Vector& in vecTarget, const Vector& in vecStart)","documentation":"Returns whether this entity is visible from the given position."},{"declaration":"string GetTargetname() const","documentation":"Returns this entity's target name."},{"declaration":"string GetClassname() const","documentation":"Returns this entity's class name."},{"declaration":"string TeamID()","documentation":"Returns this entity's team ID."},{"declaration":"bool HasTarget(const string& in szTarget)","documentation":"Returns whether this entity has the given target."},{"declaration":"int GiveAmmo(int iAmount, const string& in szName, int iMax, const bool fFromWeapon = true)","documentation":"Gives ammo to this entity."},{"declaration":"void TraceBleed(float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)","documentation":"Traces entity bleed event."},{"declaration":"void TraceAttack(entvars_t@ pevAttacker, float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)","documentation":"Traces an attack by the given entity to this entity."},{"declaration":"bool KeyValue(const string& in szKeyName, const string& in szValue)","documentation":"Sets keyvalue data on this entity"},{"declaration":"void SetOrigin(const Vector& in vecOrigin)","documentation":"Sets this entity's (absolute) origin"},{"declaration":"const Vector& GetOrigin() const","documentation":"Gets the entity's (absolute) origin."},{"declaration":"CBaseEntity@ opImplCast()","documentation":"Implicitly casts to base type."},{"declaration":"CBaseDelay@ opImplCast()","documentation":"Implicitly casts to base type."},{"declaration":"CBaseAnimating@ opImplCast()","documentation":"Implicitly casts to base type."},{"declaration":"CBaseToggle@ opImplCast()","documentation":"Implicitly casts to base type."}],"properties":[{"namespace":"","declaration":"string_t m_iszGuardEntName","documentation":"Guard entity name."},{"namespace":"","declaration":"EHandle m_pGuardEnt","documentation":"Monster will guard this entity and turn down follow requests."},{"namespace":"","declaration":"float m_flFallVelocity","documentation":"Current fall speed."},{"namespace":"","declaration":"float m_flAutomaticAttackTime","documentation":"How long an npc will attempt to fire full auto."},{"namespace":"","declaration":"bool m_fCanFearCreatures","documentation":"Whether this monster can fear creatures."},{"namespace":"","declaration":"int8 m_chTextureType","documentation":"Current texture type.<br/>See TextureType enum."},{"namespace":"","declaration":"string_t m_FormattedName","documentation":"The formatted name.<br/>For better name outputs. E.g. \"Alien Slave\" rather than \"alien_slave\"."},{"namespace":"","declaration":"float m_useTime","documentation":"Don't allow +USE until this time."},{"namespace":"","declaration":"CBaseEntity@ m_pCineBlocker","documentation":"Entity that is blocking cinematic execution."},{"namespace":"","declaration":"CCineMonster@ m_pCine","documentation":"Cinematic entity."},{"namespace":"","declaration":"SCRIPTSTATE m_scriptState","documentation":"internal cinematic state."},{"namespace":"","declaration":"Vector m_HackedGunPos","documentation":"HACK until we can query end of gun."},{"namespace":"","declaration":"string_t m_iszTriggerTarget","documentation":"Name of target that should be fired."},{"namespace":"","declaration":"int m_iTriggerCondition","documentation":"for scripted AI, this is the condition that will cause the activation of the monster's TriggerTarget."},{"namespace":"","declaration":"float m_flDistLook","documentation":"distance monster sees (Default 2048)."},{"namespace":"","declaration":"float m_flDistTooFar","documentation":"if enemy farther away than this, bits_COND_ENEMY_TOOFAR set in CheckEnemy."},{"namespace":"","declaration":"float m_flHungryTime","documentation":"Time based damage inflictor."},{"namespace":"","declaration":"int m_failSchedule","documentation":"Schedule type to choose if current schedule fails."},{"namespace":"","declaration":"entvars_t@ pevTimeBasedInflictor","documentation":"Time based damage inflictor."},{"namespace":"","declaration":"float m_tbdPrev","documentation":"Time-based damage timer."},{"namespace":"","declaration":"float m_lastDamageAmount","documentation":"how much damage did monster (player) last take."},{"namespace":"","declaration":"int m_bitsDamageType","documentation":"what types of damage has monster (player) taken."},{"namespace":"","declaration":"float m_flNextAttack","documentation":"cannot attack again until this time."},{"namespace":"","declaration":"int m_afMoveShootCap","documentation":"tells us what a monster can/can't do, while moving."},{"namespace":"","declaration":"int m_afCapability","documentation":"tells us what a monster can/can't do."},{"namespace":"","declaration":"int m_cAmmoLoaded","documentation":"how much ammo is in the weapon (used to trigger reload anim sequences)."},{"namespace":"","declaration":"Vector m_vecEnemyLKP","documentation":"last known position of enemy. (enemy's origin)."},{"namespace":"","declaration":"int m_iMaxHealth","documentation":"keeps track of monster's maximum health value (for re-healing, etc)."},{"namespace":"","declaration":"int m_bloodColor","documentation":"color of blood particles."},{"namespace":"","declaration":"int m_afMemory","documentation":"Monster memory."},{"namespace":"","declaration":"int m_iHintNode","documentation":"this is the hint node that the monster is moving towards or performing active idle on.."},{"namespace":"","declaration":"Vector m_vecLastPosition","documentation":"monster sometimes wants to return to where it started after an operation.."},{"namespace":"","declaration":"int m_afSoundTypes","documentation":"Sound types that can be heard."},{"namespace":"","declaration":"int m_iAudibleList","documentation":"first index of a linked list of sounds that the monster can hear."},{"namespace":"","declaration":"Activity m_movementActivity","documentation":"When moving, set this activity."},{"namespace":"","declaration":"Vector m_vecMoveGoal","documentation":"Kept around for node graph moves, so we know our ultimate goal."},{"namespace":"","declaration":"float m_moveradius","documentation":"Minimum radius."},{"namespace":"","declaration":"float m_moveWaitTime","documentation":"How long I should wait for something to move."},{"namespace":"","declaration":"int m_iRouteIndex","documentation":"Index into m_Route[]."},{"namespace":"","declaration":"int m_movementGoal","documentation":"Goal that defines route."},{"namespace":"","declaration":"int m_iScheduleIndex","documentation":"Schedule index."},{"namespace":"","declaration":"Schedule@ m_pScheduleSaved","documentation":"For land_on_ground schedules (remember last schedule and continue)."},{"namespace":"","declaration":"Schedule@ m_pSchedule","documentation":"Current schedule."},{"namespace":"","declaration":"int m_iTaskStatus","documentation":"Task status."},{"namespace":"","declaration":"MONSTERSTATE m_IdealMonsterState","documentation":"monster should change to this state."},{"namespace":"","declaration":"MONSTERSTATE m_MonsterState","documentation":"monster's current state."},{"namespace":"","declaration":"int m_LastHitGroup","documentation":"the last body region that took damage."},{"namespace":"","declaration":"Activity m_GaitActivity","documentation":"gaitsequence."},{"namespace":"","declaration":"Activity m_IdealActivity","documentation":"monster should switch to this activity."},{"namespace":"","declaration":"Activity m_Activity","documentation":"what the monster is doing (animation)."},{"namespace":"","declaration":"float m_flMoveWaitFinished","documentation":"if we're told to wait before moving, this is the time that the wait will be over."},{"namespace":"","declaration":"float m_flWaitFinished","documentation":"if we're told to wait, this is the time that the wait will be over."},{"namespace":"","declaration":"float m_flFieldOfView","documentation":"width of monster's field of view ( dot product )."},{"namespace":"","declaration":"EHandle m_hTargetTank","documentation":"Target tank to control."},{"namespace":"","declaration":"EHandle m_hTargetEnt","documentation":"the entity that the monster is trying to reach."},{"namespace":"","declaration":"EHandle m_hEnemy","documentation":"the entity that the monster is fighting."},{"namespace":"","declaration":"string_t m_sMaster","documentation":"This entity's master, if any."},{"namespace":"","declaration":"int m_bitsDamageInflict","documentation":"DMG_ damage type that the door or trigger does."},{"namespace":"","declaration":"Vector m_vecFinalAngle","documentation":"Final angle."},{"namespace":"","declaration":"Vector m_vecFinalDest","documentation":"Final destination."},{"namespace":"","declaration":"Vector m_vecAngle2","documentation":"Open angle."},{"namespace":"","declaration":"Vector m_vecAngle1","documentation":"Closed angle."},{"namespace":"","declaration":"Vector m_vecPosition2","documentation":"Open position."},{"namespace":"","declaration":"Vector m_vecPosition1","documentation":"Closed position."},{"namespace":"","declaration":"EHandle m_hActivator","documentation":"Handle to the activator."},{"namespace":"","declaration":"float m_flHeight","documentation":"Height."},{"namespace":"","declaration":"int m_cTriggersLeft","documentation":"Trigger_counter only: # of activations remaining."},{"namespace":"","declaration":"float m_flTLength","documentation":"For plats."},{"namespace":"","declaration":"float m_flTWidth","documentation":"For plats."},{"namespace":"","declaration":"float m_flLip","documentation":"How much to stick out of a wall. Will recede further into walls if negative."},{"namespace":"","declaration":"float m_flWait","documentation":"How long to wait before resetting."},{"namespace":"","declaration":"float m_flMoveDistance","documentation":"How far a door should slide or rotate."},{"namespace":"","declaration":"TOGGLE_STATE m_toggle_state","documentation":"Current toggle state."},{"namespace":"","declaration":"bool m_fSequenceLoops","documentation":"True if the sequence loops."},{"namespace":"","declaration":"bool m_fSequenceFinished","documentation":"Flag set when StudioAdvanceFrame moves across a frame boundry."},{"namespace":"","declaration":"float m_flLastGaitEventCheck","documentation":"Last time the event list was checked."},{"namespace":"","declaration":"float m_flLastEventCheck","documentation":"Last time the event list was checked."},{"namespace":"","declaration":"float m_flGroundSpeed","documentation":"Computed linear movement rate for current sequence."},{"namespace":"","declaration":"float m_flFrameRate","documentation":"Computed FPS for current sequence."},{"namespace":"","declaration":"string_t m_iszKillTarget","documentation":"The name of the kill target, if any."},{"namespace":"","declaration":"float m_flDelay","documentation":"Delay before fire."},{"namespace":"","declaration":"Vector m_vecOriginalRenderColor","documentation":"Original render color."},{"namespace":"","declaration":"float m_flOriginalRenderAmount","documentation":"Original render amount."},{"namespace":"","declaration":"int m_iOriginalRenderFX","documentation":"Original render FX."},{"namespace":"","declaration":"int m_iOriginalRenderMode","documentation":"Original render model."},{"namespace":"","declaration":"string_t classnameInFilterType","documentation":"Class name in filter type."},{"namespace":"","declaration":"string_t targetnameInFilterType","documentation":"Target name in filter type."},{"namespace":"","declaration":"string_t classnameOutFilterType","documentation":"Class name out filter type."},{"namespace":"","declaration":"string_t targetnameOutFilterType","documentation":"Target name out filter type."},{"namespace":"","declaration":"Vector m_vecLastOrigin","documentation":"Last origin vector"},{"namespace":"","declaration":"bool m_fCustomModel","documentation":"Whether a custom model is used."},{"namespace":"","declaration":"bool m_fCanFadeStart","documentation":"Whether fading can start."},{"namespace":"","declaration":"float m_flMaximumFadeWaitB","documentation":"Maximum fade wait time B."},{"namespace":"","declaration":"float m_flMaximumFadeWait","documentation":"Maximum fade wait time."},{"namespace":"","declaration":"int m_iClassSelection","documentation":"The overridden classification."},{"namespace":"","declaration":"bool m_fOverrideClass","documentation":"Whether this entity overrides the classification."},{"namespace":"","declaration":"entvars_t@ pev","documentation":"Entity variables"}],"className":"CBaseMonster","documentation":"Monster entity base class","namespace":""},{"flags":262145,"methods":[{"declaration":"void Explode(Vector vecSrc, Vector vecAim)","documentation":"Makes this grenade explode"},{"declaration":"void ClearEnemyList()","documentation":"Clears this monster's list of enemies"},{"declaration":"InventoryList@ get_m_pInventory() const","documentation":"The inventory items this monster has"},{"declaration":"void MedicCallSound(float flDistance = 0.0f)","documentation":"Medic call sound."},{"declaration":"string m_szTextureName()","documentation":"Current texture name we're standing on."},{"declaration":"void StopPlayerFollowing(const bool bClearSchedule)","documentation":"Stops following a player."},{"declaration":"void StartPlayerFollowing(CBaseEntity@ pLeader)","documentation":"Starts following a given player."},{"declaration":"bool CanPlayerFollow()","documentation":"Returns whether this monster can follow a player."},{"declaration":"bool IsPlayerFollowing()","documentation":"Returns whether this monster is following a player."},{"declaration":"void FollowerPlayerUse(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue)","documentation":"Use method for following players (set only if friendly)"},{"declaration":"void ShockGlowEffect(bool fMode)","documentation":"Turns the shock glow effect on or off."},{"declaration":"CBaseEntity@ DropItem(const string& in szItemName, const Vector& in vecPos, const Vector& in vecAng)","documentation":"Drops the given item from the given position at the given angle."},{"declaration":"bool CineCleanup()","documentation":"Cleans up after a cinematic event."},{"declaration":"bool ExitScriptedSequence()","documentation":"Exits the scripted sequence this monster is currently in, if any."},{"declaration":"bool HasAllMemories(int iMemory) const","documentation":"Returns whether this monster remembers all of the given memories."},{"declaration":"bool HasMemory(int iMemory) const","documentation":"Returns whether this monster remembers any of the given memories."},{"declaration":"void Forget(int iMemory)","documentation":"Makes this monster forget the given memories."},{"declaration":"void Remember(int iMemory)","documentation":"Makes this monster remember the given memories."},{"declaration":"void StopFollowing(const bool clearSchedule)","documentation":"Stops following its target."},{"declaration":"void PainSound()","documentation":"Plays this monster's pain sound."},{"declaration":"void IdleSound()","documentation":"Plays this monster's idle sound."},{"declaration":"void AlertSound()","documentation":"Plays this monster's alert sound."},{"declaration":"void DeathSound()","documentation":"Plays this monster's death sound."},{"declaration":"Vector GetGunPosition()","documentation":""},{"declaration":"Vector ShootAtEnemy(const Vector& in vecShootOrigin)","documentation":"Shoots at the specified location."},{"declaration":"void FadeMonster()","documentation":"Fades this monster.<br/>Note: does not kill the monster."},{"declaration":"bool HasAlienGibs()","documentation":"Returns whether this monster has alien gibs."},{"declaration":"bool HasHumanGibs()","documentation":"Returns whether this monster has human gibs."},{"declaration":"void CallGibMonster()","documentation":"Determines whether to gib or fade this monster, and acts accordingly."},{"declaration":"bool ShouldGibMonster(int iGib)","documentation":"Returns whether the monster should be gibbed given the gib type.<br/>See GIB enum."},{"declaration":"void GibMonster()","documentation":"Gibs the monster."},{"declaration":"bool GetEnemy()","documentation":"Tries to find the best suitable enemy for this monster."},{"declaration":"bool NoFriendlyFireToPos(Vector vecPos)","documentation":"Returns whether attacking the target location at this time would result in friendly fire"},{"declaration":"bool NoFriendlyFire(Vector vecPos, CBaseEntity@ pTarget)","documentation":"Returns whether attacking the given target at this time from the given location would result in friendly fire"},{"declaration":"bool NoFriendlyFire(Vector vecPos)","documentation":"Returns whether attacking at this time from the given location would result in friendly fire"},{"declaration":"bool NoFriendlyFire()","documentation":"Returns whether attacking at this time would result in friendly fire"},{"declaration":"bool FCheckAITrigger()","documentation":"Checks and, if necessary, fires the monster's trigger target."},{"declaration":"void Eat(float flFullDuration)","documentation":"Make the monster 'full' for a while."},{"declaration":"bool FShouldEat()","documentation":"Returns whether this monster should eat."},{"declaration":"CSound@ PBestSound()","documentation":"Returns a pointer to the sound the monster should react to."},{"declaration":"bool HasAllConditions(int iConditions) const","documentation":"Returns whether this monster has all of the given AI conditions."},{"declaration":"bool HasConditions(int iConditions) const","documentation":"Returns whether this monster has any of the given AI conditions."},{"declaration":"void ClearConditions(int iConditions)","documentation":"Clears AI conditions."},{"declaration":"void SetConditions(int iConditions)","documentation":"Sets AI conditions."},{"declaration":"bool CheckAttacker(CBaseEntity@ pAttacker)","documentation":"Determine if we should ignore damage."},{"declaration":"int RouteClassify(int iMoveFlag)","documentation":"Returns the MOVEGOAL for the given move flag."},{"declaration":"void SetYawSpeed()","documentation":"Allows different yaw_speeds for each activity."},{"declaration":"void MakeIdealYaw(Vector vecTarget)","documentation":"gets a yaw value for the caller that would<br/>face the supplied vector. Value is stuffed into the monster's<br/>ideal_yaw."},{"declaration":"int IScheduleFlags()","documentation":"Returns an integer with all Conditions<br/>bits that are currently set and also set in the current<br/>schedule's Interrupt mask."},{"declaration":"bool MovementIsComplete()","documentation":"Returns whether movement is complete."},{"declaration":"bool TaskIsComplete()","documentation":"Returns whether the task is complete."},{"declaration":"bool TaskIsRunning()","documentation":"Returns whether a task is running."},{"declaration":"void TaskBegin()","documentation":"Sets the task status to running."},{"declaration":"void TaskFail()","documentation":"Sets the condition bit for a failed task."},{"declaration":"void MovementComplete()","documentation":"Called when movement has completed."},{"declaration":"void TaskComplete()","documentation":"Sets the task status to complete."},{"declaration":"bool TestFGetNodeRoute(Vector vecDest)","documentation":"TEST FGetNodeRoute."},{"declaration":"bool FGetNodeRoute(Vector vecDest)","documentation":"tries to build an entire node path from<br/>the callers origin to the passed vector.<br/>If this is  possible, ROUTE_SIZE waypoints will be copied into the callers m_Route.<br/>true is returned if the operation  succeeds (path is valid) or false if failed (no path  exists )."},{"declaration":"bool PopEnemy()","documentation":"Try remembering the last few enemies."},{"declaration":"void PushEnemy(CBaseEntity@ pTarget, Vector& in vecLastKnownPos)","documentation":"Remember the last few enemies, always remember the player."},{"declaration":"bool CheckEnemy(CBaseEntity@ pEnemy)","documentation":"part of the Condition collection process, gets and stores data and conditions pertaining to a monster's enemy.<br/>Returns true if Enemy LKP was updated."},{"declaration":"bool CheckAttacksFromPosition(CBaseEntity@ pTarget, float flDist, Vector vecPos)","documentation":"Check whether attacks are possible from the given position."},{"declaration":"void CheckAttacks_Move(CBaseEntity@ pTarget, float flDist)","documentation":"Check attacks to the given enemy at the given distance while moving."},{"declaration":"void CheckAttacks(CBaseEntity@ pTarget, float flDist)","documentation":"Check attacks to the given enemy at the given distance."},{"declaration":"void ReportAIState()","documentation":"Reports the AI state."},{"declaration":"void SetState(MONSTERSTATE state)","documentation":"Sets the current monster state."},{"declaration":"void SetSequenceByName(const string& in szSequence)","documentation":"Sets the current sequence by name."},{"declaration":"void SetGaitActivity(Activity newActivity)","documentation":"Sets the current gait activity."},{"declaration":"void SetActivity(Activity newActivity)","documentation":"Sets the current activity."},{"declaration":"MONSTERSTATE GetIdealState()","documentation":"Gets the ideal monster state."},{"declaration":"Task@ GetTask()","documentation":"Gets the current task."},{"declaration":"void SentenceStop()","documentation":"Stops playing its current sentence."},{"declaration":"void PlayScriptedSentence(const string& in szSentence, float duration, float volume, float attenuation, const bool bConcurrent, CBaseEntity@ pListener)","documentation":"Plays the given scripted sentence."},{"declaration":"void PlaySentence(const string& in szSentence, float duration, float volume, float attenuation)","documentation":"Plays the given sentence."},{"declaration":"bool CanPlaySentence(const bool bDisregardState)","documentation":"Returns whether this monster can play its sentence."},{"declaration":"bool CanPlaySequence(const bool bDisregardState, int iInterruptLevel)","documentation":"Returns whether this monster can play its sequence."},{"declaration":"void ScheduleChange()","documentation":"Called after the monster's schedule changes."},{"declaration":"Schedule@ GetSchedule()","documentation":"Gets the current schedule."},{"declaration":"Schedule@ GetScheduleOfType(int iType)","documentation":"Gets one of the available schedules of the given type."},{"declaration":"void RunTask(Task@ pTask)","documentation":"Runs the given task."},{"declaration":"void StartTask(Task@ pTask)","documentation":"Starts the given task."},{"declaration":"void MaintainSchedule()","documentation":"Maintains the monster's schedule."},{"declaration":"Schedule@ ScheduleFromName(const string& in szName)","documentation":"Returns the schedule with name szName if it exists, NULL otherwise."},{"declaration":"Schedule@ ScheduleInList(const string& in szName, array<Schedule@>@ pArray)","documentation":"Returns the schedule with name szName if it's in the list, NULL otherwise."},{"declaration":"bool NextScheduledTask()","documentation":"Moves to the next scheduled task."},{"declaration":"void ChangeSchedule(Schedule@ pNewSchedule)","documentation":"Changes this monster's schedule."},{"declaration":"bool FScheduleDone()","documentation":"Returns whether this monster's schedule is done."},{"declaration":"void ClearSchedule()","documentation":"Clears this monster's schedule."},{"declaration":"bool FScheduleValid()","documentation":"Returns whether this monster's schedule is valid."},{"declaration":"bool FHaveSchedule()","documentation":"Returns whether this monster has a schedule."},{"declaration":"bool CheckTankUsage()","documentation":"Checks whether the monster can use a func_tank. Return true if possible."},{"declaration":"bool CheckMeleeAttack2_Move(float flDot, float flDist)","documentation":"this function will survey conditions and set appropriate conditions bits for attack types."},{"declaration":"bool CheckMeleeAttack2(float flDot, float flDist)","documentation":"this function will survey conditions and set appropriate conditions bits for attack types."},{"declaration":"bool CheckMeleeAttack1_Move(float flDot, float flDist)","documentation":"this function will survey conditions and set appropriate conditions bits for attack types."},{"declaration":"bool CheckMeleeAttack1(float flDot, float flDist)","documentation":"this function will survey conditions and set appropriate conditions bits for attack types."},{"declaration":"bool CheckRangeAttack2_Move(float flDot, float flDist)","documentation":"this function will survey conditions and set appropriate conditions bits for attack types."},{"declaration":"bool CheckRangeAttack2(float flDot, float flDist)","documentation":"this function will survey conditions and set appropriate conditions bits for attack types."},{"declaration":"bool CheckRangeAttack1_Move(float flDot, float flDist)","documentation":"this function will survey conditions and set appropriate conditions bits for attack types."},{"declaration":"bool CheckRangeAttack1(float flDot, float flDist)","documentation":"this function will survey conditions and set appropriate conditions bits for attack types."},{"declaration":"void StopAnimation()","documentation":"This will stop animation until you call ResetSequenceInfo() at some point in the future"},{"declaration":"void Stop()","documentation":"Stops this monster moving"},{"declaration":"Activity GetStoppedActivity()","documentation":"Gets the stopped activity"},{"declaration":"bool ShouldAdvanceRoute(float flWaypointDist)","documentation":"Returns whether this monster should advance its route"},{"declaration":"void MoveExecute(CBaseEntity@ pTargetEnt, const Vector& in vecDir, float flInterval)","documentation":"Starts the monster"},{"declaration":"void Move(float flInterval = 0.1f)","documentation":"Starts the monster"},{"declaration":"int CheckLocalMove(const Vector& in vecStart, const Vector& in vecEnd,CBaseEntity@ pTarget, float& out flDist, Vector& out vecEndPosition, bool fOriginalCheck = false)","documentation":"finds best visible enemy for attack"},{"declaration":"bool FInViewCone(const Vector& in vecOrigin)","documentation":"see if given location is in monster's view cone"},{"declaration":"bool FInViewCone(CBaseEntity@ pEntity)","documentation":"see if pEntity is in monster's view cone"},{"declaration":"void BestVisibleEnemy()","documentation":"finds best visible enemy for attack"},{"declaration":"void StartMonster()","documentation":"Starts the monster"},{"declaration":"void Revive()","documentation":"Revives the monster"},{"declaration":"void BecomeDead(float flSavedHealth)","documentation":"Makes the monster become dead"},{"declaration":"void MonsterInitDead()","documentation":"Call after animation/pose is set up"},{"declaration":"void MonsterInit()","documentation":"Initializes the monster"},{"declaration":"void SetupFriendly()","documentation":"use this overridden to make some other friendly monsters"},{"declaration":"float DamageForce(float flDamage)","documentation":"Returns the amount of force applied to this monster when the given amount of damage is done."},{"declaration":"float FlYawDiff()","documentation":"returns the difference ( in degrees ) between monster's current yaw and ideal_yaw.<br/>Positive result is left turn, negative is right turn."},{"declaration":"float VecToYaw(Vector vecDir)","documentation":"turns a directional vector into a yaw value that points down that vector."},{"declaration":"float ChangeYaw(int iSpeed)","documentation":"turns a monster towards its ideal_yaw"},{"declaration":"bool ShouldFadeOnDeath()","documentation":"Returns whether this monster should fade on death."},{"declaration":"void Listen()","documentation":"Listens for anything that is within audible distance."},{"declaration":"void RunAI()","documentation":"Runs this monster's AI."},{"declaration":"void Look(int iDistance)","documentation":"Look - Base class monster function to find enemies or<br/>food by sight. iDistance is distance ( in units ) that the<br/>monster can see.<br/>Sets the sight bits of the m_afConditions mask to indicate<br/>which types of entities were sighted.<br/>Function also sets the Looker's m_pLink<br/>to the head of a link list that contains all visible ents.<br/>(linked via each ent's m_pLink field)"},{"declaration":"void MonsterUse(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f)","documentation":"Will make a monster angry at whomever activated it."},{"declaration":"int8& m_rgbTimeBasedDamage(size_t uiIndex)","documentation":"time based damage counters, decr. 1 per 2 seconds. Index must be between 0 and CMG_TIMEBASED."},{"declaration":"Waypoint& m_Route(size_t uiIndex)","documentation":"Positions of movement. Index must be between 0 and ROUTE_SIZE"},{"declaration":"Vector& m_vecOldEnemy(size_t uiIndex)","documentation":"Target tank to control. Index must be between 0 and MAX_OLD_ENEMIES."},{"declaration":"EHandle& m_hOldEnemy(size_t uiIndex)","documentation":"Target tank to control. Index must be between 0 and MAX_OLD_ENEMIES."},{"declaration":"InventoryRules@ get_m_pInventoryRules() const","documentation":"The inventory rules."},{"declaration":"bool IsToggleLockedByMaster()","documentation":"Returns whether this entity is locked by its master.<br/>Separate from IsLockedByMaster due to limitations."},{"declaration":"void AngularMove(Vector vecDestAngle, float flSpeed)","documentation":"Performs angular movement."},{"declaration":"void LinearMove(Vector vecDest, float flSpeed)","documentation":"Performs linear movement."},{"declaration":"int GetSequenceActivityName(int iSequence)","documentation":"Sets the sequence box."},{"declaration":"void SetSequenceBox()","documentation":"Sets the sequence box."},{"declaration":"int GetAttachmentCount()","documentation":"Gets the number of attachments that the current model has."},{"declaration":"bool ExtractBbox(int iSequence, Vector& out mins, Vector& out maxs)","documentation":"Extracts the bounding box of the current model."},{"declaration":"int GetBodygroup(int iGroup)","documentation":"Gets the value of the given body group."},{"declaration":"void SetBodygroup(int iGroup, int iValue)","documentation":"Sets the given body group to the given value."},{"declaration":"void GetAttachment(int iAttachment, Vector& out origin, Vector& out angles)","documentation":"Gets the attachment position."},{"declaration":"int FindTransition(int iEndingSequence, int iGoalSequence)","documentation":"Find the transition between 2 sequences."},{"declaration":"int FindTransition(int iEndingSequence, int iGoalSequence, int& out iDir)","documentation":"Find the transition between 2 sequences."},{"declaration":"void GetAutomovement(Vector& out origin, Vector& out angles, float flInterval = 0.1f)","documentation":"Gets automatic movement."},{"declaration":"void GetBonePosition(int iBone, Vector& out origin, Vector& out angles)","documentation":"Gets the position of the given bone."},{"declaration":"float SetBlending(int iBlender, float flValue)","documentation":"Sets the given blending controller to the given value."},{"declaration":"void InitBoneControllers()","documentation":"Initializes bone controllers."},{"declaration":"float SetBoneController(int iController, float flValue)","documentation":"Sets the specified bone controller to the given value."},{"declaration":"void DispatchAnimEvents(float flFutureInterval = 0.1f)","documentation":"Handle events that have happend since last time called up until X seconds into the future."},{"declaration":"void ResetGaitSequenceInfo()","documentation":"Resets gait sequence info."},{"declaration":"void ResetSequenceInfo()","documentation":"Resets sequence info."},{"declaration":"int LookupSequence(const string& in szLabel)","documentation":"Returns the index of the given sequence, or -1 if no such sequence exists."},{"declaration":"int LookupActivityHeaviest(int iActivity)","documentation":"Returns the index of the given activity that has the heaviest weight, or -1 if no such activity exists."},{"declaration":"int LookupActivity(int iActivity)","documentation":"Returns the index of the given activity, or -1 if no such activity exists."},{"declaration":"int GetSequenceFlags()","documentation":"Get sequence flags."},{"declaration":"float StudioFrameAdvance(float flInterval = 0.0f)","documentation":"Accumulate animation frame time from last time called until now."},{"declaration":"void DelayThink()","documentation":"Think function. Used internally."},{"declaration":"void SUB_UseTargets(CBaseEntity@ pActivator, USE_TYPE useType, float flValue)","documentation":"Causes this entity to trigger its targets with an optional delay."},{"declaration":"void ClearUserData()","documentation":"Clears the user data on this entity. WARNING: clears all data.<br/>Only map scripts can use this."},{"declaration":"dictionaryValue& GetUserData(const string& in szKey)","documentation":"Gets the user data stored under the specified key on this entity.<br/>Do not keep references to this data, the object might be removed from this entity.<br/>Only map scripts can use this."},{"declaration":"dictionary@ GetUserData()","documentation":"Gets the user data on this entity. Do not keep references to this data, the object might be removed from this entity.<br/>Only map scripts can use this."},{"declaration":"void EndRevive(float flTimeUntilRevive)","documentation":"Called when this entity should be revived. flTimeUntilRevive is the time until the revival should start."},{"declaration":"void BeginRevive(float flTimeUntilRevive)","documentation":"Prepares this entity for revival. flTimeUntilRevive is the time until the revive action completes."},{"declaration":"bool IsRevivable()","documentation":"Returns whether this entity is revivable at this time."},{"declaration":"void OnDestroy()","documentation":"Entity destructor."},{"declaration":"void OnCreate()","documentation":"Entity constructor."},{"declaration":"void GetDamagePoints(entvars_t@ pevAttacker, entvars_t@ pevInflictor, float flDamage)","documentation":"Adds damage points to the inflicting entity."},{"declaration":"float GetPointsForDamage(float flDamage)","documentation":"Returns the points received for damage done."},{"declaration":"bool IsFacing(entvars_t@ pevTest, float flDotProduct = VIEW_FIELD_ULTRA_NARROW)","documentation":"Returns whether this entity is facing the given entity, within the given view field."},{"declaration":"bool FVisible(const Vector& in vecOrigin)","documentation":"Returns whether this entity is visible from the given origin."},{"declaration":"bool FVisible(CBaseEntity@ pEntity, bool fIgnoreGlass)","documentation":"Returns whether this entity is visible to the given entity."},{"declaration":"int Illumination()","documentation":"Returns this entity's illumination."},{"declaration":"Vector BodyTarget(const Vector& in posSrc)","documentation":"Returns this entity's body target for shooting."},{"declaration":"Vector EarPosition()","documentation":"Returns this entity's ear position."},{"declaration":"Vector EyePosition()","documentation":"Returns this entity's eye position."},{"declaration":"Vector Center()","documentation":"Returns this entity's center."},{"declaration":"bool FBecomeProne()","documentation":"Makes this entity become prone."},{"declaration":"CBaseEntity@ Respawn()","documentation":"Respawns this entity."},{"declaration":"void UpdateOnRemove()","documentation":"Updates this entity when removed."},{"declaration":"void Blocked(CBaseEntity@ pOther)","documentation":"Triggers this entity's blocked function."},{"declaration":"void Use(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f)","documentation":"Trigger's this entity's use function."},{"declaration":"void Touch(CBaseEntity@ pOther)","documentation":"Triggers this entity's touch function."},{"declaration":"void Think()","documentation":"Makes this entity think. Do not call directly."},{"declaration":"CBaseEntity@ GetNextTarget()","documentation":"Gets the next target to trigger."},{"declaration":"bool CriticalRemove()","documentation":"Removes this entity in critical situations."},{"declaration":"bool IsMachine()","documentation":"Returns whether this is a machine."},{"declaration":"bool IsPointEnt()","documentation":"Returns whether this is a point entity."},{"declaration":"bool IsNetClient()","documentation":"Returns whether this is a net client."},{"declaration":"bool IsPlayer()","documentation":"Returns whether this entity is a player."},{"declaration":"bool IsMonster()","documentation":"Returns whether this entity is a monster."},{"declaration":"bool IsInWorld()","documentation":"Returns whether this entity is in the world."},{"declaration":"bool ReflectGauss()","documentation":"Returns whether this entity reflects gauss shots."},{"declaration":"bool IsBSPModel()","documentation":"Returns whether this entity is a BSP model."},{"declaration":"bool IsAlive()","documentation":"Returns whether this entity is alive."},{"declaration":"bool IsSneaking()","documentation":"Returns whether this entity is sneaking."},{"declaration":"bool OnControls(entvars_t@ pev)","documentation":"Reacts to controls set on the pev."},{"declaration":"void StopSneaking()","documentation":"Stops sneaking."},{"declaration":"void StartSneaking()","documentation":"Starts sneaking."},{"declaration":"void SetToggleState(int state)","documentation":"Sets this entity's toggle state."},{"declaration":"int DamageDecal(int bitsDamageType)","documentation":"Returns the damage decal<br/>See decal_e."},{"declaration":"void OverrideReset()","documentation":"Resets this entity."},{"declaration":"bool IsMoving()","documentation":"Returns whether this entity is moving."},{"declaration":"float GetDelay()","documentation":"Gets this entity's trigger delay."},{"declaration":"bool RemovePlayerItem(CBasePlayerItem@ pItem)","documentation":"Removes the given player item to this entity."},{"declaration":"AddPlayerItemResult AddPlayerItem(CBasePlayerItem@ pItem)","documentation":"Adds the given player item to this entity."},{"declaration":"void AddPointsToTeam(int score, const bool bAllowNegativeScore)","documentation":"Adds points to this entity's team."},{"declaration":"void AddPoints(int score, const bool bAllowNegativeScore)","documentation":"Adds points to this entity."},{"declaration":"int GetToggleState()","documentation":"Gets the toggle state.<br/>See the TOGGLE_STATE enum."},{"declaration":"bool SetupModel()","documentation":"Sets up the model."},{"declaration":"int entindex()","documentation":"Returns this entity's index."},{"declaration":"edict_t@ edict()","documentation":"Returns this entity's edict."},{"declaration":"bool IsLockedByMaster()","documentation":"Returns whether this entity is locked by its master."},{"declaration":"bool IsDormant()","documentation":"Returns whether this entity is dormant."},{"declaration":"void MakeDormant()","documentation":"Makes this entity dormant."},{"declaration":"bool Intersects(CBaseEntity@ pOther)","documentation":"Returns whether this entity intersects with the given entity."},{"declaration":"void FireBullets(uint cShots, Vector vecSrc, Vector vecDirShooting, Vector vecSpread,float flDistance, Bullet iBulletType, int iTracerFreq = 4, int iDamage = 0, entvars_t@ pevAttacker = null, FireBulletsDrawMode fDraw = FBDM_DRAW)","documentation":"Fires bullets. Must call CMath::MakeAimVectors with an angle vector first."},{"declaration":"bool ShouldToggle(USE_TYPE useType, const bool currentState)","documentation":"Returns whether this entity should toggle."},{"declaration":"void SUB_CallUseToggle()","documentation":"Think function. Calls use toggle on this entity."},{"declaration":"void SUB_FadeOut()","documentation":"Think function. Fades this entity."},{"declaration":"void SUB_StartFadeOut()","documentation":"Think function. Starts fading this entity."},{"declaration":"void SUB_DoNothing()","documentation":"Think function. Explicitly does nothing."},{"declaration":"void SUB_Remove()","documentation":"Think function. Delay-removes this entity."},{"declaration":"bool BlockedByEntity(CBaseEntity@ pOther, float flDamage)","documentation":"Returns true if you should be blocked by the entity, false otherwise. Also deals blocking damage to the entity, if applicable."},{"declaration":"CustomKeyvalues@ GetCustomKeyvalues()","documentation":"Gets this entity's custom keyvalues."},{"declaration":"CBaseMonster@ MyMonsterPointer()","documentation":"Returns this entity as its monster entity, if it is a monster."},{"declaration":"bool IsTriggered(CBaseEntity@ pActivator)","documentation":"Returns whether this entity is triggered by the given entity."},{"declaration":"int BloodColor()","documentation":"Returns the blood color. See the BLOOD_COLOR enum."},{"declaration":"void Killed(entvars_t@pevAtttacker, int iGibbed)","documentation":"Tells this entity it's been killed. See the GIB enum for possible values."},{"declaration":"bool TakeArmor(float flArmor, int bitsDamageType, int armor_cap = 0)","documentation":"Takes armor from this entity. Note: flArmor is added to entity armor. Use negative values to subtract.If armor_cap is non-zero, won't add more than armor_cap. Returns 1 if it took damage, 0 otherwise."},{"declaration":"bool TakeHealth(float flHealth, int bitsDamageType, int health_cap = 0)","documentation":"Takes health from this entity. Note: flHealth is added to entity health. Use negative values to subtract.If health_cap is non-zero, won't add more than health_cap. Returns true if it took damage, false otherwise."},{"declaration":"int TakeDamage(entvars_t@ pevInflictor, entvars_t@ pevAttacker, float flDamage, int bitsDamageType)","documentation":"Causes this entity to take damage. Returns 1 if it took damage, 0 otherwise."},{"declaration":"int Classify()","documentation":"Gets this entity's classification."},{"declaration":"int IRelationshipByClass(CLASS iClass)","documentation":"Gets the relationship between this entity and the given entity classification. See the RELATIONSHIP enum."},{"declaration":"int IRelationship(CBaseEntity@ other)","documentation":"Gets the relationship between this entity and the given entity. See the RELATIONSHIP enum."},{"declaration":"void ClearClassification()","documentation":"Clears this entity's classification override."},{"declaration":"void SetClassificationFromEntity(CBaseEntity@ pEntity)","documentation":"Sets this entity's classification override to the classification override set on the given entity. Can override the entity's player ally setting."},{"declaration":"void SetClassification(int cl)","documentation":"Sets this entity's classification override. Can override the entity's player ally setting."},{"declaration":"int GetClassification(int cl)","documentation":"Gets this entity's classification. Returns the given value if none is set. See the CLASSIFICATION enum."},{"declaration":"void SetObjectCollisionBox()","documentation":"Sets up the object collision box."},{"declaration":"int ObjectCaps()","documentation":"Gets this entity's objects caps. See the FCAP enum."},{"declaration":"void Precache()","documentation":"Precaches the entity. Do not call directly."},{"declaration":"bool opEquals(CBaseEntity@ pOther)","documentation":"Compares 2 entities for equality."},{"declaration":"void SetPlayerAllyDirect(bool fState)","documentation":"Sets this entity's player ally status.</br>Use this only if you need the setting to be exactly what you give it (e.g. when copying from another monster)"},{"declaration":"void SetPlayerAlly(bool fState)","documentation":"Sets this entity's player ally status."},{"declaration":"bool IsPlayerAlly() const","documentation":"Returns whether this entity is allied to players."},{"declaration":"int FindMonstersInWorld(array<CBaseEntity@>@ pArray, int flagMask)","documentation":"Finds monsters in the world"},{"declaration":"string SOUNDREPLACEMENT_Find(const string& in szFilename)","documentation":"Find sound replacement for the given file."},{"declaration":"bool FVisibleFromPos(const Vector& in vecTarget, const Vector& in vecStart)","documentation":"Returns whether this entity is visible from the given position."},{"declaration":"string GetTargetname() const","documentation":"Returns this entity's target name."},{"declaration":"string GetClassname() const","documentation":"Returns this entity's class name."},{"declaration":"string TeamID()","documentation":"Returns this entity's team ID."},{"declaration":"bool HasTarget(const string& in szTarget)","documentation":"Returns whether this entity has the given target."},{"declaration":"int GiveAmmo(int iAmount, const string& in szName, int iMax, const bool fFromWeapon = true)","documentation":"Gives ammo to this entity."},{"declaration":"void TraceBleed(float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)","documentation":"Traces entity bleed event."},{"declaration":"void TraceAttack(entvars_t@ pevAttacker, float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)","documentation":"Traces an attack by the given entity to this entity."},{"declaration":"bool KeyValue(const string& in szKeyName, const string& in szValue)","documentation":"Sets keyvalue data on this entity"},{"declaration":"void SetOrigin(const Vector& in vecOrigin)","documentation":"Sets this entity's (absolute) origin"},{"declaration":"const Vector& GetOrigin() const","documentation":"Gets the entity's (absolute) origin."},{"declaration":"CBaseEntity@ opImplCast()","documentation":"Implicitly casts to base type."},{"declaration":"CBaseDelay@ opImplCast()","documentation":"Implicitly casts to base type."},{"declaration":"CBaseAnimating@ opImplCast()","documentation":"Implicitly casts to base type."},{"declaration":"CBaseToggle@ opImplCast()","documentation":"Implicitly casts to base type."},{"declaration":"CBaseMonster@ opImplCast()","documentation":"Implicitly casts to base type."}],"properties":[{"namespace":"","declaration":"string_t m_iszGuardEntName","documentation":"Guard entity name."},{"namespace":"","declaration":"EHandle m_pGuardEnt","documentation":"Monster will guard this entity and turn down follow requests."},{"namespace":"","declaration":"float m_flFallVelocity","documentation":"Current fall speed."},{"namespace":"","declaration":"float m_flAutomaticAttackTime","documentation":"How long an npc will attempt to fire full auto."},{"namespace":"","declaration":"bool m_fCanFearCreatures","documentation":"Whether this monster can fear creatures."},{"namespace":"","declaration":"int8 m_chTextureType","documentation":"Current texture type.<br/>See TextureType enum."},{"namespace":"","declaration":"string_t m_FormattedName","documentation":"The formatted name.<br/>For better name outputs. E.g. \"Alien Slave\" rather than \"alien_slave\"."},{"namespace":"","declaration":"float m_useTime","documentation":"Don't allow +USE until this time."},{"namespace":"","declaration":"CBaseEntity@ m_pCineBlocker","documentation":"Entity that is blocking cinematic execution."},{"namespace":"","declaration":"CCineMonster@ m_pCine","documentation":"Cinematic entity."},{"namespace":"","declaration":"SCRIPTSTATE m_scriptState","documentation":"internal cinematic state."},{"namespace":"","declaration":"Vector m_HackedGunPos","documentation":"HACK until we can query end of gun."},{"namespace":"","declaration":"string_t m_iszTriggerTarget","documentation":"Name of target that should be fired."},{"namespace":"","declaration":"int m_iTriggerCondition","documentation":"for scripted AI, this is the condition that will cause the activation of the monster's TriggerTarget."},{"namespace":"","declaration":"float m_flDistLook","documentation":"distance monster sees (Default 2048)."},{"namespace":"","declaration":"float m_flDistTooFar","documentation":"if enemy farther away than this, bits_COND_ENEMY_TOOFAR set in CheckEnemy."},{"namespace":"","declaration":"float m_flHungryTime","documentation":"Time based damage inflictor."},{"namespace":"","declaration":"int m_failSchedule","documentation":"Schedule type to choose if current schedule fails."},{"namespace":"","declaration":"entvars_t@ pevTimeBasedInflictor","documentation":"Time based damage inflictor."},{"namespace":"","declaration":"float m_tbdPrev","documentation":"Time-based damage timer."},{"namespace":"","declaration":"float m_lastDamageAmount","documentation":"how much damage did monster (player) last take."},{"namespace":"","declaration":"int m_bitsDamageType","documentation":"what types of damage has monster (player) taken."},{"namespace":"","declaration":"float m_flNextAttack","documentation":"cannot attack again until this time."},{"namespace":"","declaration":"int m_afMoveShootCap","documentation":"tells us what a monster can/can't do, while moving."},{"namespace":"","declaration":"int m_afCapability","documentation":"tells us what a monster can/can't do."},{"namespace":"","declaration":"int m_cAmmoLoaded","documentation":"how much ammo is in the weapon (used to trigger reload anim sequences)."},{"namespace":"","declaration":"Vector m_vecEnemyLKP","documentation":"last known position of enemy. (enemy's origin)."},{"namespace":"","declaration":"int m_iMaxHealth","documentation":"keeps track of monster's maximum health value (for re-healing, etc)."},{"namespace":"","declaration":"int m_bloodColor","documentation":"color of blood particles."},{"namespace":"","declaration":"int m_afMemory","documentation":"Monster memory."},{"namespace":"","declaration":"int m_iHintNode","documentation":"this is the hint node that the monster is moving towards or performing active idle on.."},{"namespace":"","declaration":"Vector m_vecLastPosition","documentation":"monster sometimes wants to return to where it started after an operation.."},{"namespace":"","declaration":"int m_afSoundTypes","documentation":"Sound types that can be heard."},{"namespace":"","declaration":"int m_iAudibleList","documentation":"first index of a linked list of sounds that the monster can hear."},{"namespace":"","declaration":"Activity m_movementActivity","documentation":"When moving, set this activity."},{"namespace":"","declaration":"Vector m_vecMoveGoal","documentation":"Kept around for node graph moves, so we know our ultimate goal."},{"namespace":"","declaration":"float m_moveradius","documentation":"Minimum radius."},{"namespace":"","declaration":"float m_moveWaitTime","documentation":"How long I should wait for something to move."},{"namespace":"","declaration":"int m_iRouteIndex","documentation":"Index into m_Route[]."},{"namespace":"","declaration":"int m_movementGoal","documentation":"Goal that defines route."},{"namespace":"","declaration":"int m_iScheduleIndex","documentation":"Schedule index."},{"namespace":"","declaration":"Schedule@ m_pScheduleSaved","documentation":"For land_on_ground schedules (remember last schedule and continue)."},{"namespace":"","declaration":"Schedule@ m_pSchedule","documentation":"Current schedule."},{"namespace":"","declaration":"int m_iTaskStatus","documentation":"Task status."},{"namespace":"","declaration":"MONSTERSTATE m_IdealMonsterState","documentation":"monster should change to this state."},{"namespace":"","declaration":"MONSTERSTATE m_MonsterState","documentation":"monster's current state."},{"namespace":"","declaration":"int m_LastHitGroup","documentation":"the last body region that took damage."},{"namespace":"","declaration":"Activity m_GaitActivity","documentation":"gaitsequence."},{"namespace":"","declaration":"Activity m_IdealActivity","documentation":"monster should switch to this activity."},{"namespace":"","declaration":"Activity m_Activity","documentation":"what the monster is doing (animation)."},{"namespace":"","declaration":"float m_flMoveWaitFinished","documentation":"if we're told to wait before moving, this is the time that the wait will be over."},{"namespace":"","declaration":"float m_flWaitFinished","documentation":"if we're told to wait, this is the time that the wait will be over."},{"namespace":"","declaration":"float m_flFieldOfView","documentation":"width of monster's field of view ( dot product )."},{"namespace":"","declaration":"EHandle m_hTargetTank","documentation":"Target tank to control."},{"namespace":"","declaration":"EHandle m_hTargetEnt","documentation":"the entity that the monster is trying to reach."},{"namespace":"","declaration":"EHandle m_hEnemy","documentation":"the entity that the monster is fighting."},{"namespace":"","declaration":"string_t m_sMaster","documentation":"This entity's master, if any."},{"namespace":"","declaration":"int m_bitsDamageInflict","documentation":"DMG_ damage type that the door or trigger does."},{"namespace":"","declaration":"Vector m_vecFinalAngle","documentation":"Final angle."},{"namespace":"","declaration":"Vector m_vecFinalDest","documentation":"Final destination."},{"namespace":"","declaration":"Vector m_vecAngle2","documentation":"Open angle."},{"namespace":"","declaration":"Vector m_vecAngle1","documentation":"Closed angle."},{"namespace":"","declaration":"Vector m_vecPosition2","documentation":"Open position."},{"namespace":"","declaration":"Vector m_vecPosition1","documentation":"Closed position."},{"namespace":"","declaration":"EHandle m_hActivator","documentation":"Handle to the activator."},{"namespace":"","declaration":"float m_flHeight","documentation":"Height."},{"namespace":"","declaration":"int m_cTriggersLeft","documentation":"Trigger_counter only: # of activations remaining."},{"namespace":"","declaration":"float m_flTLength","documentation":"For plats."},{"namespace":"","declaration":"float m_flTWidth","documentation":"For plats."},{"namespace":"","declaration":"float m_flLip","documentation":"How much to stick out of a wall. Will recede further into walls if negative."},{"namespace":"","declaration":"float m_flWait","documentation":"How long to wait before resetting."},{"namespace":"","declaration":"float m_flMoveDistance","documentation":"How far a door should slide or rotate."},{"namespace":"","declaration":"TOGGLE_STATE m_toggle_state","documentation":"Current toggle state."},{"namespace":"","declaration":"bool m_fSequenceLoops","documentation":"True if the sequence loops."},{"namespace":"","declaration":"bool m_fSequenceFinished","documentation":"Flag set when StudioAdvanceFrame moves across a frame boundry."},{"namespace":"","declaration":"float m_flLastGaitEventCheck","documentation":"Last time the event list was checked."},{"namespace":"","declaration":"float m_flLastEventCheck","documentation":"Last time the event list was checked."},{"namespace":"","declaration":"float m_flGroundSpeed","documentation":"Computed linear movement rate for current sequence."},{"namespace":"","declaration":"float m_flFrameRate","documentation":"Computed FPS for current sequence."},{"namespace":"","declaration":"string_t m_iszKillTarget","documentation":"The name of the kill target, if any."},{"namespace":"","declaration":"float m_flDelay","documentation":"Delay before fire."},{"namespace":"","declaration":"Vector m_vecOriginalRenderColor","documentation":"Original render color."},{"namespace":"","declaration":"float m_flOriginalRenderAmount","documentation":"Original render amount."},{"namespace":"","declaration":"int m_iOriginalRenderFX","documentation":"Original render FX."},{"namespace":"","declaration":"int m_iOriginalRenderMode","documentation":"Original render model."},{"namespace":"","declaration":"string_t classnameInFilterType","documentation":"Class name in filter type."},{"namespace":"","declaration":"string_t targetnameInFilterType","documentation":"Target name in filter type."},{"namespace":"","declaration":"string_t classnameOutFilterType","documentation":"Class name out filter type."},{"namespace":"","declaration":"string_t targetnameOutFilterType","documentation":"Target name out filter type."},{"namespace":"","declaration":"Vector m_vecLastOrigin","documentation":"Last origin vector"},{"namespace":"","declaration":"bool m_fCustomModel","documentation":"Whether a custom model is used."},{"namespace":"","declaration":"bool m_fCanFadeStart","documentation":"Whether fading can start."},{"namespace":"","declaration":"float m_flMaximumFadeWaitB","documentation":"Maximum fade wait time B."},{"namespace":"","declaration":"float m_flMaximumFadeWait","documentation":"Maximum fade wait time."},{"namespace":"","declaration":"int m_iClassSelection","documentation":"The overridden classification."},{"namespace":"","declaration":"bool m_fOverrideClass","documentation":"Whether this entity overrides the classification."},{"namespace":"","declaration":"entvars_t@ pev","documentation":"Entity variables"}],"className":"CGrenade","documentation":"Grenade class","namespace":""},{"flags":262145,"methods":[{"declaration":"bool MyTouch(CBasePlayer@ pPlayer)","documentation":"The item's touch function."},{"declaration":"void Materialize()","documentation":"Makes this entity visible and tangible."},{"declaration":"void ItemTouch(CBaseEntity@ pOther)","documentation":"Item touch function"},{"declaration":"void ClearUserData()","documentation":"Clears the user data on this entity. WARNING: clears all data.<br/>Only map scripts can use this."},{"declaration":"dictionaryValue& GetUserData(const string& in szKey)","documentation":"Gets the user data stored under the specified key on this entity.<br/>Do not keep references to this data, the object might be removed from this entity.<br/>Only map scripts can use this."},{"declaration":"dictionary@ GetUserData()","documentation":"Gets the user data on this entity. Do not keep references to this data, the object might be removed from this entity.<br/>Only map scripts can use this."},{"declaration":"void EndRevive(float flTimeUntilRevive)","documentation":"Called when this entity should be revived. flTimeUntilRevive is the time until the revival should start."},{"declaration":"void BeginRevive(float flTimeUntilRevive)","documentation":"Prepares this entity for revival. flTimeUntilRevive is the time until the revive action completes."},{"declaration":"bool IsRevivable()","documentation":"Returns whether this entity is revivable at this time."},{"declaration":"void OnDestroy()","documentation":"Entity destructor."},{"declaration":"void OnCreate()","documentation":"Entity constructor."},{"declaration":"void GetDamagePoints(entvars_t@ pevAttacker, entvars_t@ pevInflictor, float flDamage)","documentation":"Adds damage points to the inflicting entity."},{"declaration":"float GetPointsForDamage(float flDamage)","documentation":"Returns the points received for damage done."},{"declaration":"bool IsFacing(entvars_t@ pevTest, float flDotProduct = VIEW_FIELD_ULTRA_NARROW)","documentation":"Returns whether this entity is facing the given entity, within the given view field."},{"declaration":"bool FVisible(const Vector& in vecOrigin)","documentation":"Returns whether this entity is visible from the given origin."},{"declaration":"bool FVisible(CBaseEntity@ pEntity, bool fIgnoreGlass)","documentation":"Returns whether this entity is visible to the given entity."},{"declaration":"int Illumination()","documentation":"Returns this entity's illumination."},{"declaration":"Vector BodyTarget(const Vector& in posSrc)","documentation":"Returns this entity's body target for shooting."},{"declaration":"Vector EarPosition()","documentation":"Returns this entity's ear position."},{"declaration":"Vector EyePosition()","documentation":"Returns this entity's eye position."},{"declaration":"Vector Center()","documentation":"Returns this entity's center."},{"declaration":"bool FBecomeProne()","documentation":"Makes this entity become prone."},{"declaration":"CBaseEntity@ Respawn()","documentation":"Respawns this entity."},{"declaration":"void UpdateOnRemove()","documentation":"Updates this entity when removed."},{"declaration":"void Blocked(CBaseEntity@ pOther)","documentation":"Triggers this entity's blocked function."},{"declaration":"void Use(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f)","documentation":"Trigger's this entity's use function."},{"declaration":"void Touch(CBaseEntity@ pOther)","documentation":"Triggers this entity's touch function."},{"declaration":"void Think()","documentation":"Makes this entity think. Do not call directly."},{"declaration":"CBaseEntity@ GetNextTarget()","documentation":"Gets the next target to trigger."},{"declaration":"bool CriticalRemove()","documentation":"Removes this entity in critical situations."},{"declaration":"bool IsMachine()","documentation":"Returns whether this is a machine."},{"declaration":"bool IsPointEnt()","documentation":"Returns whether this is a point entity."},{"declaration":"bool IsNetClient()","documentation":"Returns whether this is a net client."},{"declaration":"bool IsPlayer()","documentation":"Returns whether this entity is a player."},{"declaration":"bool IsMonster()","documentation":"Returns whether this entity is a monster."},{"declaration":"bool IsInWorld()","documentation":"Returns whether this entity is in the world."},{"declaration":"bool ReflectGauss()","documentation":"Returns whether this entity reflects gauss shots."},{"declaration":"bool IsBSPModel()","documentation":"Returns whether this entity is a BSP model."},{"declaration":"bool IsAlive()","documentation":"Returns whether this entity is alive."},{"declaration":"bool IsSneaking()","documentation":"Returns whether this entity is sneaking."},{"declaration":"bool OnControls(entvars_t@ pev)","documentation":"Reacts to controls set on the pev."},{"declaration":"void StopSneaking()","documentation":"Stops sneaking."},{"declaration":"void StartSneaking()","documentation":"Starts sneaking."},{"declaration":"void SetToggleState(int state)","documentation":"Sets this entity's toggle state."},{"declaration":"int DamageDecal(int bitsDamageType)","documentation":"Returns the damage decal<br/>See decal_e."},{"declaration":"void OverrideReset()","documentation":"Resets this entity."},{"declaration":"bool IsMoving()","documentation":"Returns whether this entity is moving."},{"declaration":"float GetDelay()","documentation":"Gets this entity's trigger delay."},{"declaration":"bool RemovePlayerItem(CBasePlayerItem@ pItem)","documentation":"Removes the given player item to this entity."},{"declaration":"AddPlayerItemResult AddPlayerItem(CBasePlayerItem@ pItem)","documentation":"Adds the given player item to this entity."},{"declaration":"void AddPointsToTeam(int score, const bool bAllowNegativeScore)","documentation":"Adds points to this entity's team."},{"declaration":"void AddPoints(int score, const bool bAllowNegativeScore)","documentation":"Adds points to this entity."},{"declaration":"int GetToggleState()","documentation":"Gets the toggle state.<br/>See the TOGGLE_STATE enum."},{"declaration":"bool SetupModel()","documentation":"Sets up the model."},{"declaration":"int entindex()","documentation":"Returns this entity's index."},{"declaration":"edict_t@ edict()","documentation":"Returns this entity's edict."},{"declaration":"bool IsLockedByMaster()","documentation":"Returns whether this entity is locked by its master."},{"declaration":"bool IsDormant()","documentation":"Returns whether this entity is dormant."},{"declaration":"void MakeDormant()","documentation":"Makes this entity dormant."},{"declaration":"bool Intersects(CBaseEntity@ pOther)","documentation":"Returns whether this entity intersects with the given entity."},{"declaration":"void SUB_UseTargets(CBaseEntity@ pActivator, USE_TYPE useType, float flValue)","documentation":"Calls use on targets."},{"declaration":"void FireBullets(uint cShots, Vector vecSrc, Vector vecDirShooting, Vector vecSpread,float flDistance, Bullet iBulletType, int iTracerFreq = 4, int iDamage = 0, entvars_t@ pevAttacker = null, FireBulletsDrawMode fDraw = FBDM_DRAW)","documentation":"Fires bullets. Must call CMath::MakeAimVectors with an angle vector first."},{"declaration":"bool ShouldToggle(USE_TYPE useType, const bool currentState)","documentation":"Returns whether this entity should toggle."},{"declaration":"void SUB_CallUseToggle()","documentation":"Think function. Calls use toggle on this entity."},{"declaration":"void SUB_FadeOut()","documentation":"Think function. Fades this entity."},{"declaration":"void SUB_StartFadeOut()","documentation":"Think function. Starts fading this entity."},{"declaration":"void SUB_DoNothing()","documentation":"Think function. Explicitly does nothing."},{"declaration":"void SUB_Remove()","documentation":"Think function. Delay-removes this entity."},{"declaration":"bool BlockedByEntity(CBaseEntity@ pOther, float flDamage)","documentation":"Returns true if you should be blocked by the entity, false otherwise. Also deals blocking damage to the entity, if applicable."},{"declaration":"CustomKeyvalues@ GetCustomKeyvalues()","documentation":"Gets this entity's custom keyvalues."},{"declaration":"CBaseMonster@ MyMonsterPointer()","documentation":"Returns this entity as its monster entity, if it is a monster."},{"declaration":"bool IsTriggered(CBaseEntity@ pActivator)","documentation":"Returns whether this entity is triggered by the given entity."},{"declaration":"int BloodColor()","documentation":"Returns the blood color. See the BLOOD_COLOR enum."},{"declaration":"void Killed(entvars_t@pevAtttacker, int iGibbed)","documentation":"Tells this entity it's been killed. See the GIB enum for possible values."},{"declaration":"bool TakeArmor(float flArmor, int bitsDamageType, int armor_cap = 0)","documentation":"Takes armor from this entity. Note: flArmor is added to entity armor. Use negative values to subtract.If armor_cap is non-zero, won't add more than armor_cap. Returns 1 if it took damage, 0 otherwise."},{"declaration":"bool TakeHealth(float flHealth, int bitsDamageType, int health_cap = 0)","documentation":"Takes health from this entity. Note: flHealth is added to entity health. Use negative values to subtract.If health_cap is non-zero, won't add more than health_cap. Returns true if it took damage, false otherwise."},{"declaration":"int TakeDamage(entvars_t@ pevInflictor, entvars_t@ pevAttacker, float flDamage, int bitsDamageType)","documentation":"Causes this entity to take damage. Returns 1 if it took damage, 0 otherwise."},{"declaration":"int Classify()","documentation":"Gets this entity's classification."},{"declaration":"int IRelationshipByClass(CLASS iClass)","documentation":"Gets the relationship between this entity and the given entity classification. See the RELATIONSHIP enum."},{"declaration":"int IRelationship(CBaseEntity@ other)","documentation":"Gets the relationship between this entity and the given entity. See the RELATIONSHIP enum."},{"declaration":"void ClearClassification()","documentation":"Clears this entity's classification override."},{"declaration":"void SetClassificationFromEntity(CBaseEntity@ pEntity)","documentation":"Sets this entity's classification override to the classification override set on the given entity. Can override the entity's player ally setting."},{"declaration":"void SetClassification(int cl)","documentation":"Sets this entity's classification override. Can override the entity's player ally setting."},{"declaration":"int GetClassification(int cl)","documentation":"Gets this entity's classification. Returns the given value if none is set. See the CLASSIFICATION enum."},{"declaration":"void SetObjectCollisionBox()","documentation":"Sets up the object collision box."},{"declaration":"int ObjectCaps()","documentation":"Gets this entity's objects caps. See the FCAP enum."},{"declaration":"void Precache()","documentation":"Precaches the entity. Do not call directly."},{"declaration":"bool opEquals(CBaseEntity@ pOther)","documentation":"Compares 2 entities for equality."},{"declaration":"void SetPlayerAllyDirect(bool fState)","documentation":"Sets this entity's player ally status.</br>Use this only if you need the setting to be exactly what you give it (e.g. when copying from another monster)"},{"declaration":"void SetPlayerAlly(bool fState)","documentation":"Sets this entity's player ally status."},{"declaration":"bool IsPlayerAlly() const","documentation":"Returns whether this entity is allied to players."},{"declaration":"int FindMonstersInWorld(array<CBaseEntity@>@ pArray, int flagMask)","documentation":"Finds monsters in the world"},{"declaration":"string SOUNDREPLACEMENT_Find(const string& in szFilename)","documentation":"Find sound replacement for the given file."},{"declaration":"bool FVisibleFromPos(const Vector& in vecTarget, const Vector& in vecStart)","documentation":"Returns whether this entity is visible from the given position."},{"declaration":"string GetTargetname() const","documentation":"Returns this entity's target name."},{"declaration":"string GetClassname() const","documentation":"Returns this entity's class name."},{"declaration":"string TeamID()","documentation":"Returns this entity's team ID."},{"declaration":"bool HasTarget(const string& in szTarget)","documentation":"Returns whether this entity has the given target."},{"declaration":"int GiveAmmo(int iAmount, const string& in szName, int iMax, const bool fFromWeapon = true)","documentation":"Gives ammo to this entity."},{"declaration":"void TraceBleed(float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)","documentation":"Traces entity bleed event."},{"declaration":"void TraceAttack(entvars_t@ pevAttacker, float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)","documentation":"Traces an attack by the given entity to this entity."},{"declaration":"bool KeyValue(const string& in szKeyName, const string& in szValue)","documentation":"Sets keyvalue data on this entity"},{"declaration":"void SetOrigin(const Vector& in vecOrigin)","documentation":"Sets this entity's (absolute) origin"},{"declaration":"const Vector& GetOrigin() const","documentation":"Gets the entity's (absolute) origin."},{"declaration":"CBaseEntity@ opImplCast()","documentation":"Implicitly casts to base type."}],"properties":[{"namespace":"","declaration":"Vector m_vecOriginalRenderColor","documentation":"Original render color."},{"namespace":"","declaration":"float m_flOriginalRenderAmount","documentation":"Original render amount."},{"namespace":"","declaration":"int m_iOriginalRenderFX","documentation":"Original render FX."},{"namespace":"","declaration":"int m_iOriginalRenderMode","documentation":"Original render model."},{"namespace":"","declaration":"string_t classnameInFilterType","documentation":"Class name in filter type."},{"namespace":"","declaration":"string_t targetnameInFilterType","documentation":"Target name in filter type."},{"namespace":"","declaration":"string_t classnameOutFilterType","documentation":"Class name out filter type."},{"namespace":"","declaration":"string_t targetnameOutFilterType","documentation":"Target name out filter type."},{"namespace":"","declaration":"Vector m_vecLastOrigin","documentation":"Last origin vector"},{"namespace":"","declaration":"bool m_fCustomModel","documentation":"Whether a custom model is used."},{"namespace":"","declaration":"bool m_fCanFadeStart","documentation":"Whether fading can start."},{"namespace":"","declaration":"float m_flMaximumFadeWaitB","documentation":"Maximum fade wait time B."},{"namespace":"","declaration":"float m_flMaximumFadeWait","documentation":"Maximum fade wait time."},{"namespace":"","declaration":"int m_iClassSelection","documentation":"The overridden classification."},{"namespace":"","declaration":"bool m_fOverrideClass","documentation":"Whether this entity overrides the classification."},{"namespace":"","declaration":"entvars_t@ pev","documentation":"Entity variables"}],"className":"CItem","documentation":"Generic item class","namespace":""},{"flags":262145,"methods":[{"declaration":"void RemoveItemEffects()","documentation":"Prepares to remove effects from holder."},{"declaration":"void AddItemEffects()","documentation":"Prepares to add effects to holder."},{"declaration":"void Destroy()","documentation":"Destroys this item."},{"declaration":"void Return()","documentation":"Returns this item to its original spawn location."},{"declaration":"bool Drop(bool fForce = false, CBaseEntity@ pCaller = null)","documentation":"Drops this item, if it's being carried."},{"declaration":"bool CanCollect(CBaseEntity@ pOther)","documentation":"Returns whether this item can be collected by the given entity."},{"declaration":"void ClearUserData()","documentation":"Clears the user data on this entity. WARNING: clears all data.<br/>Only map scripts can use this."},{"declaration":"dictionaryValue& GetUserData(const string& in szKey)","documentation":"Gets the user data stored under the specified key on this entity.<br/>Do not keep references to this data, the object might be removed from this entity.<br/>Only map scripts can use this."},{"declaration":"dictionary@ GetUserData()","documentation":"Gets the user data on this entity. Do not keep references to this data, the object might be removed from this entity.<br/>Only map scripts can use this."},{"declaration":"void EndRevive(float flTimeUntilRevive)","documentation":"Called when this entity should be revived. flTimeUntilRevive is the time until the revival should start."},{"declaration":"void BeginRevive(float flTimeUntilRevive)","documentation":"Prepares this entity for revival. flTimeUntilRevive is the time until the revive action completes."},{"declaration":"bool IsRevivable()","documentation":"Returns whether this entity is revivable at this time."},{"declaration":"void OnDestroy()","documentation":"Entity destructor."},{"declaration":"void OnCreate()","documentation":"Entity constructor."},{"declaration":"void GetDamagePoints(entvars_t@ pevAttacker, entvars_t@ pevInflictor, float flDamage)","documentation":"Adds damage points to the inflicting entity."},{"declaration":"float GetPointsForDamage(float flDamage)","documentation":"Returns the points received for damage done."},{"declaration":"bool IsFacing(entvars_t@ pevTest, float flDotProduct = VIEW_FIELD_ULTRA_NARROW)","documentation":"Returns whether this entity is facing the given entity, within the given view field."},{"declaration":"bool FVisible(const Vector& in vecOrigin)","documentation":"Returns whether this entity is visible from the given origin."},{"declaration":"bool FVisible(CBaseEntity@ pEntity, bool fIgnoreGlass)","documentation":"Returns whether this entity is visible to the given entity."},{"declaration":"int Illumination()","documentation":"Returns this entity's illumination."},{"declaration":"Vector BodyTarget(const Vector& in posSrc)","documentation":"Returns this entity's body target for shooting."},{"declaration":"Vector EarPosition()","documentation":"Returns this entity's ear position."},{"declaration":"Vector EyePosition()","documentation":"Returns this entity's eye position."},{"declaration":"Vector Center()","documentation":"Returns this entity's center."},{"declaration":"bool FBecomeProne()","documentation":"Makes this entity become prone."},{"declaration":"CBaseEntity@ Respawn()","documentation":"Respawns this entity."},{"declaration":"void UpdateOnRemove()","documentation":"Updates this entity when removed."},{"declaration":"void Blocked(CBaseEntity@ pOther)","documentation":"Triggers this entity's blocked function."},{"declaration":"void Use(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f)","documentation":"Trigger's this entity's use function."},{"declaration":"void Touch(CBaseEntity@ pOther)","documentation":"Triggers this entity's touch function."},{"declaration":"void Think()","documentation":"Makes this entity think. Do not call directly."},{"declaration":"CBaseEntity@ GetNextTarget()","documentation":"Gets the next target to trigger."},{"declaration":"bool CriticalRemove()","documentation":"Removes this entity in critical situations."},{"declaration":"bool IsMachine()","documentation":"Returns whether this is a machine."},{"declaration":"bool IsPointEnt()","documentation":"Returns whether this is a point entity."},{"declaration":"bool IsNetClient()","documentation":"Returns whether this is a net client."},{"declaration":"bool IsPlayer()","documentation":"Returns whether this entity is a player."},{"declaration":"bool IsMonster()","documentation":"Returns whether this entity is a monster."},{"declaration":"bool IsInWorld()","documentation":"Returns whether this entity is in the world."},{"declaration":"bool ReflectGauss()","documentation":"Returns whether this entity reflects gauss shots."},{"declaration":"bool IsBSPModel()","documentation":"Returns whether this entity is a BSP model."},{"declaration":"bool IsAlive()","documentation":"Returns whether this entity is alive."},{"declaration":"bool IsSneaking()","documentation":"Returns whether this entity is sneaking."},{"declaration":"bool OnControls(entvars_t@ pev)","documentation":"Reacts to controls set on the pev."},{"declaration":"void StopSneaking()","documentation":"Stops sneaking."},{"declaration":"void StartSneaking()","documentation":"Starts sneaking."},{"declaration":"void SetToggleState(int state)","documentation":"Sets this entity's toggle state."},{"declaration":"int DamageDecal(int bitsDamageType)","documentation":"Returns the damage decal<br/>See decal_e."},{"declaration":"void OverrideReset()","documentation":"Resets this entity."},{"declaration":"bool IsMoving()","documentation":"Returns whether this entity is moving."},{"declaration":"float GetDelay()","documentation":"Gets this entity's trigger delay."},{"declaration":"bool RemovePlayerItem(CBasePlayerItem@ pItem)","documentation":"Removes the given player item to this entity."},{"declaration":"AddPlayerItemResult AddPlayerItem(CBasePlayerItem@ pItem)","documentation":"Adds the given player item to this entity."},{"declaration":"void AddPointsToTeam(int score, const bool bAllowNegativeScore)","documentation":"Adds points to this entity's team."},{"declaration":"void AddPoints(int score, const bool bAllowNegativeScore)","documentation":"Adds points to this entity."},{"declaration":"int GetToggleState()","documentation":"Gets the toggle state.<br/>See the TOGGLE_STATE enum."},{"declaration":"bool SetupModel()","documentation":"Sets up the model."},{"declaration":"int entindex()","documentation":"Returns this entity's index."},{"declaration":"edict_t@ edict()","documentation":"Returns this entity's edict."},{"declaration":"bool IsLockedByMaster()","documentation":"Returns whether this entity is locked by its master."},{"declaration":"bool IsDormant()","documentation":"Returns whether this entity is dormant."},{"declaration":"void MakeDormant()","documentation":"Makes this entity dormant."},{"declaration":"bool Intersects(CBaseEntity@ pOther)","documentation":"Returns whether this entity intersects with the given entity."},{"declaration":"void SUB_UseTargets(CBaseEntity@ pActivator, USE_TYPE useType, float flValue)","documentation":"Calls use on targets."},{"declaration":"void FireBullets(uint cShots, Vector vecSrc, Vector vecDirShooting, Vector vecSpread,float flDistance, Bullet iBulletType, int iTracerFreq = 4, int iDamage = 0, entvars_t@ pevAttacker = null, FireBulletsDrawMode fDraw = FBDM_DRAW)","documentation":"Fires bullets. Must call CMath::MakeAimVectors with an angle vector first."},{"declaration":"bool ShouldToggle(USE_TYPE useType, const bool currentState)","documentation":"Returns whether this entity should toggle."},{"declaration":"void SUB_CallUseToggle()","documentation":"Think function. Calls use toggle on this entity."},{"declaration":"void SUB_FadeOut()","documentation":"Think function. Fades this entity."},{"declaration":"void SUB_StartFadeOut()","documentation":"Think function. Starts fading this entity."},{"declaration":"void SUB_DoNothing()","documentation":"Think function. Explicitly does nothing."},{"declaration":"void SUB_Remove()","documentation":"Think function. Delay-removes this entity."},{"declaration":"bool BlockedByEntity(CBaseEntity@ pOther, float flDamage)","documentation":"Returns true if you should be blocked by the entity, false otherwise. Also deals blocking damage to the entity, if applicable."},{"declaration":"CustomKeyvalues@ GetCustomKeyvalues()","documentation":"Gets this entity's custom keyvalues."},{"declaration":"CBaseMonster@ MyMonsterPointer()","documentation":"Returns this entity as its monster entity, if it is a monster."},{"declaration":"bool IsTriggered(CBaseEntity@ pActivator)","documentation":"Returns whether this entity is triggered by the given entity."},{"declaration":"int BloodColor()","documentation":"Returns the blood color. See the BLOOD_COLOR enum."},{"declaration":"void Killed(entvars_t@pevAtttacker, int iGibbed)","documentation":"Tells this entity it's been killed. See the GIB enum for possible values."},{"declaration":"bool TakeArmor(float flArmor, int bitsDamageType, int armor_cap = 0)","documentation":"Takes armor from this entity. Note: flArmor is added to entity armor. Use negative values to subtract.If armor_cap is non-zero, won't add more than armor_cap. Returns 1 if it took damage, 0 otherwise."},{"declaration":"bool TakeHealth(float flHealth, int bitsDamageType, int health_cap = 0)","documentation":"Takes health from this entity. Note: flHealth is added to entity health. Use negative values to subtract.If health_cap is non-zero, won't add more than health_cap. Returns true if it took damage, false otherwise."},{"declaration":"int TakeDamage(entvars_t@ pevInflictor, entvars_t@ pevAttacker, float flDamage, int bitsDamageType)","documentation":"Causes this entity to take damage. Returns 1 if it took damage, 0 otherwise."},{"declaration":"int Classify()","documentation":"Gets this entity's classification."},{"declaration":"int IRelationshipByClass(CLASS iClass)","documentation":"Gets the relationship between this entity and the given entity classification. See the RELATIONSHIP enum."},{"declaration":"int IRelationship(CBaseEntity@ other)","documentation":"Gets the relationship between this entity and the given entity. See the RELATIONSHIP enum."},{"declaration":"void ClearClassification()","documentation":"Clears this entity's classification override."},{"declaration":"void SetClassificationFromEntity(CBaseEntity@ pEntity)","documentation":"Sets this entity's classification override to the classification override set on the given entity. Can override the entity's player ally setting."},{"declaration":"void SetClassification(int cl)","documentation":"Sets this entity's classification override. Can override the entity's player ally setting."},{"declaration":"int GetClassification(int cl)","documentation":"Gets this entity's classification. Returns the given value if none is set. See the CLASSIFICATION enum."},{"declaration":"void SetObjectCollisionBox()","documentation":"Sets up the object collision box."},{"declaration":"int ObjectCaps()","documentation":"Gets this entity's objects caps. See the FCAP enum."},{"declaration":"void Precache()","documentation":"Precaches the entity. Do not call directly."},{"declaration":"bool opEquals(CBaseEntity@ pOther)","documentation":"Compares 2 entities for equality."},{"declaration":"void SetPlayerAllyDirect(bool fState)","documentation":"Sets this entity's player ally status.</br>Use this only if you need the setting to be exactly what you give it (e.g. when copying from another monster)"},{"declaration":"void SetPlayerAlly(bool fState)","documentation":"Sets this entity's player ally status."},{"declaration":"bool IsPlayerAlly() const","documentation":"Returns whether this entity is allied to players."},{"declaration":"int FindMonstersInWorld(array<CBaseEntity@>@ pArray, int flagMask)","documentation":"Finds monsters in the world"},{"declaration":"string SOUNDREPLACEMENT_Find(const string& in szFilename)","documentation":"Find sound replacement for the given file."},{"declaration":"bool FVisibleFromPos(const Vector& in vecTarget, const Vector& in vecStart)","documentation":"Returns whether this entity is visible from the given position."},{"declaration":"string GetTargetname() const","documentation":"Returns this entity's target name."},{"declaration":"string GetClassname() const","documentation":"Returns this entity's class name."},{"declaration":"string TeamID()","documentation":"Returns this entity's team ID."},{"declaration":"bool HasTarget(const string& in szTarget)","documentation":"Returns whether this entity has the given target."},{"declaration":"int GiveAmmo(int iAmount, const string& in szName, int iMax, const bool fFromWeapon = true)","documentation":"Gives ammo to this entity."},{"declaration":"void TraceBleed(float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)","documentation":"Traces entity bleed event."},{"declaration":"void TraceAttack(entvars_t@ pevAttacker, float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)","documentation":"Traces an attack by the given entity to this entity."},{"declaration":"bool KeyValue(const string& in szKeyName, const string& in szValue)","documentation":"Sets keyvalue data on this entity"},{"declaration":"void SetOrigin(const Vector& in vecOrigin)","documentation":"Sets this entity's (absolute) origin"},{"declaration":"const Vector& GetOrigin() const","documentation":"Gets the entity's (absolute) origin."},{"declaration":"CBaseEntity@ opImplCast()","documentation":"Implicitly casts to base type."}],"properties":[{"namespace":"","declaration":"bool m_fRemovedByForced","documentation":"Item was just removed by force"},{"namespace":"","declaration":"float m_flDropTime","documentation":"Time the item was last dropped"},{"namespace":"","declaration":"float m_flCollectTime","documentation":"Time the item was last collected"},{"namespace":"","declaration":"float m_flTouchedTime","documentation":"Time the item was last touched"},{"namespace":"","declaration":"int m_iCollectCount","documentation":"Number of times the item has been collected"},{"namespace":"","declaration":"float m_flEffectDamage","documentation":"Damage modifier (%)"},{"namespace":"","declaration":"float m_flEffectSpeed","documentation":"Movement speed modifier (%)"},{"namespace":"","declaration":"float m_flEffectFriction","documentation":"Movement friction modifier (%)"},{"namespace":"","declaration":"float m_flEffectGravity","documentation":"Gravity modifier (%)"},{"namespace":"","declaration":"float m_flEffectRespiration","documentation":"Extra/less breathing time underwater in seconds"},{"namespace":"","declaration":"bool m_fEffectNonSolid","documentation":"Holder is non-solid"},{"namespace":"","declaration":"bool m_fEffectInvisible","documentation":"Holder is invisible (render + non-targetable)"},{"namespace":"","declaration":"bool m_fEffectInvulnerable","documentation":"Holder is invulnerable (god mode)"},{"namespace":"","declaration":"bool m_fEffectBlockWeapons","documentation":"Holder can't use weapons"},{"namespace":"","declaration":"Vector m_vecEffectGlowColor","documentation":"Holder has a glow shell"},{"namespace":"","declaration":"bool m_fEffectsPermanent","documentation":"Holder keeps effects after dropping the item"},{"namespace":"","declaration":"string_t m_szTriggerOnReturn","documentation":"On automatic return to original location"},{"namespace":"","declaration":"string_t m_szTriggerOnUse","documentation":"On usage (by trigger)"},{"namespace":"","declaration":"string_t m_szTriggerOnCantDrop","documentation":"On failed drop"},{"namespace":"","declaration":"string_t m_szTriggerOnDrop","documentation":"On successful drop"},{"namespace":"","declaration":"string_t m_szTriggerOnCantCollect","documentation":"On failed collection"},{"namespace":"","declaration":"string_t m_szTriggerOnCollect","documentation":"On successful collection"},{"namespace":"","declaration":"bool m_fKeepOnRespawn","documentation":"Holder still has the item after respawning (only applies to players -- re-equip NPC's manually)"},{"namespace":"","declaration":"bool m_fKeepOnDeath","documentation":"Holder still has the item after dying (i.e. so they can keep it while being revived)"},{"namespace":"","declaration":"bool m_fDelayedRespawn","documentation":"Delayed respawn on return (like with weapons/ammo/pickups)"},{"namespace":"","declaration":"float m_flReturnTime","documentation":"How long this item returns to its' original location when dropped (-1 = never, 0 = instant)"},{"namespace":"","declaration":"bool m_fCanBeDropped","documentation":"Holder is allowed to drop this item by choice"},{"namespace":"","declaration":"float m_flMaximumHoldTime","documentation":"Limit to how long this item can be held for, forcibly dropped after (0 = no limit)"},{"namespace":"","declaration":"string_t m_szItemNameNotMoved","documentation":"These item(s) must NOT have moved"},{"namespace":"","declaration":"int m_iCantHaveItemGroupNum","documentation":"Number of item(s) from the can't have group(s) (0 = all)"},{"namespace":"","declaration":"string_t m_szCantHaveItemGroup","documentation":"Must not have an item in these group(s)"},{"namespace":"","declaration":"string_t m_szCantHaveItemName","documentation":"Must not have these item(s)"},{"namespace":"","declaration":"string_t m_szItemNameMoved","documentation":"These item(s) must have moved"},{"namespace":"","declaration":"int m_iRequiresItemGroupNum","documentation":"Number of item(s) from the required group(s) required (0 = all)"},{"namespace":"","declaration":"string_t m_szRequiresItemGroup","documentation":"Require an item from these group(s)"},{"namespace":"","declaration":"string_t m_szRequiresItemName","documentation":"Require these item(s)"},{"namespace":"","declaration":"int m_iAllowedNpcClassify","documentation":"NPC classification filter"},{"namespace":"","declaration":"string_t m_szAllowedPlayerClasses","documentation":"Player class filters"},{"namespace":"","declaration":"string_t m_szAllowedTeams","documentation":"Team filters"},{"namespace":"","declaration":"string_t m_szAllowedClassNames","documentation":"CBaseEntity class name filters"},{"namespace":"","declaration":"string_t m_szAllowedTargetNames","documentation":"CBaseEntity target name filters"},{"namespace":"","declaration":"int m_iCarriedSequence","documentation":"Model sequence number while CARRIED."},{"namespace":"","declaration":"string_t m_szCarriedSequenceName","documentation":"Model sequence name while CARRIED."},{"namespace":"","declaration":"int m_iCarriedBody","documentation":"Model body while CARRIED."},{"namespace":"","declaration":"int m_iCarriedSkin","documentation":"Model skin while CARRIED."},{"namespace":"","declaration":"int m_iIdleSequence","documentation":"Model sequence number while IDLE."},{"namespace":"","declaration":"string_t m_szIdleSequenceName","documentation":"Model sequence name while IDLE."},{"namespace":"","declaration":"int m_iIdleBody","documentation":"Model body while IDLE."},{"namespace":"","declaration":"int m_iIdleSkin","documentation":"Model skin while IDLE (not carried)."},{"namespace":"","declaration":"bool m_fHiddenWhenCarried","documentation":"Model is hidden while it is being carried."},{"namespace":"","declaration":"float m_flWeight","documentation":"How heavy the item is (0-100),<br/>holders can hold multiple items up to a total weight 100, think of this as KG if you like (though what person can carry 100KG!?)."},{"namespace":"","declaration":"int m_iCollectLimit","documentation":"How many times the item can be picked up, destroyed when limit is reached (0 = infinite)."},{"namespace":"","declaration":"string_t m_szDescription","documentation":"Friendly item description for client-side UI."},{"namespace":"","declaration":"string m_szDisplayName","documentation":"Friendly item name for client-side UI."},{"namespace":"","declaration":"string_t m_szItemGroup","documentation":"Group name referred to by triggers."},{"namespace":"","declaration":"string_t m_szItemName","documentation":"Item name referred to by triggers, doesn't need to be unique -- remember the targetname refers to the entity itself only."},{"namespace":"","declaration":"int m_iMoveType","documentation":"Spawn-time move type."},{"namespace":"","declaration":"Vector m_vecSpawnAngles","documentation":"Spawn-time angles."},{"namespace":"","declaration":"Vector m_vecSpawnOrigin","documentation":"Spawn-time origin."},{"namespace":"","declaration":"CBaseMonster@ m_pHolder","documentation":"The monster or player holding this item."},{"namespace":"","declaration":"Vector m_vecOriginalRenderColor","documentation":"Original render color."},{"namespace":"","declaration":"float m_flOriginalRenderAmount","documentation":"Original render amount."},{"namespace":"","declaration":"int m_iOriginalRenderFX","documentation":"Original render FX."},{"namespace":"","declaration":"int m_iOriginalRenderMode","documentation":"Original render model."},{"namespace":"","declaration":"string_t classnameInFilterType","documentation":"Class name in filter type."},{"namespace":"","declaration":"string_t targetnameInFilterType","documentation":"Target name in filter type."},{"namespace":"","declaration":"string_t classnameOutFilterType","documentation":"Class name out filter type."},{"namespace":"","declaration":"string_t targetnameOutFilterType","documentation":"Target name out filter type."},{"namespace":"","declaration":"Vector m_vecLastOrigin","documentation":"Last origin vector"},{"namespace":"","declaration":"bool m_fCustomModel","documentation":"Whether a custom model is used."},{"namespace":"","declaration":"bool m_fCanFadeStart","documentation":"Whether fading can start."},{"namespace":"","declaration":"float m_flMaximumFadeWaitB","documentation":"Maximum fade wait time B."},{"namespace":"","declaration":"float m_flMaximumFadeWait","documentation":"Maximum fade wait time."},{"namespace":"","declaration":"int m_iClassSelection","documentation":"The overridden classification."},{"namespace":"","declaration":"bool m_fOverrideClass","documentation":"Whether this entity overrides the classification."},{"namespace":"","declaration":"entvars_t@ pev","documentation":"Entity variables"}],"className":"CItemInventory","documentation":"Item_inventory entity class<br/>Collection rules -- DENY/CAN'T have rules take precedence over REQUIRE/MUST<br/>All string filters can be tokenized with a semi-colon ';'","namespace":""},{"flags":262145,"methods":[{"declaration":"void Materialize()","documentation":"Makes this entity visible and tangible."},{"declaration":"bool AddAmmo(CBaseEntity@ pOther)","documentation":"Adds ammo to the given entity."},{"declaration":"void DefaultTouch(CBaseEntity@ pOther)","documentation":"Default touch"},{"declaration":"void ClearUserData()","documentation":"Clears the user data on this entity. WARNING: clears all data.<br/>Only map scripts can use this."},{"declaration":"dictionaryValue& GetUserData(const string& in szKey)","documentation":"Gets the user data stored under the specified key on this entity.<br/>Do not keep references to this data, the object might be removed from this entity.<br/>Only map scripts can use this."},{"declaration":"dictionary@ GetUserData()","documentation":"Gets the user data on this entity. Do not keep references to this data, the object might be removed from this entity.<br/>Only map scripts can use this."},{"declaration":"void EndRevive(float flTimeUntilRevive)","documentation":"Called when this entity should be revived. flTimeUntilRevive is the time until the revival should start."},{"declaration":"void BeginRevive(float flTimeUntilRevive)","documentation":"Prepares this entity for revival. flTimeUntilRevive is the time until the revive action completes."},{"declaration":"bool IsRevivable()","documentation":"Returns whether this entity is revivable at this time."},{"declaration":"void OnDestroy()","documentation":"Entity destructor."},{"declaration":"void OnCreate()","documentation":"Entity constructor."},{"declaration":"void GetDamagePoints(entvars_t@ pevAttacker, entvars_t@ pevInflictor, float flDamage)","documentation":"Adds damage points to the inflicting entity."},{"declaration":"float GetPointsForDamage(float flDamage)","documentation":"Returns the points received for damage done."},{"declaration":"bool IsFacing(entvars_t@ pevTest, float flDotProduct = VIEW_FIELD_ULTRA_NARROW)","documentation":"Returns whether this entity is facing the given entity, within the given view field."},{"declaration":"bool FVisible(const Vector& in vecOrigin)","documentation":"Returns whether this entity is visible from the given origin."},{"declaration":"bool FVisible(CBaseEntity@ pEntity, bool fIgnoreGlass)","documentation":"Returns whether this entity is visible to the given entity."},{"declaration":"int Illumination()","documentation":"Returns this entity's illumination."},{"declaration":"Vector BodyTarget(const Vector& in posSrc)","documentation":"Returns this entity's body target for shooting."},{"declaration":"Vector EarPosition()","documentation":"Returns this entity's ear position."},{"declaration":"Vector EyePosition()","documentation":"Returns this entity's eye position."},{"declaration":"Vector Center()","documentation":"Returns this entity's center."},{"declaration":"bool FBecomeProne()","documentation":"Makes this entity become prone."},{"declaration":"CBaseEntity@ Respawn()","documentation":"Respawns this entity."},{"declaration":"void UpdateOnRemove()","documentation":"Updates this entity when removed."},{"declaration":"void Blocked(CBaseEntity@ pOther)","documentation":"Triggers this entity's blocked function."},{"declaration":"void Use(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f)","documentation":"Trigger's this entity's use function."},{"declaration":"void Touch(CBaseEntity@ pOther)","documentation":"Triggers this entity's touch function."},{"declaration":"void Think()","documentation":"Makes this entity think. Do not call directly."},{"declaration":"CBaseEntity@ GetNextTarget()","documentation":"Gets the next target to trigger."},{"declaration":"bool CriticalRemove()","documentation":"Removes this entity in critical situations."},{"declaration":"bool IsMachine()","documentation":"Returns whether this is a machine."},{"declaration":"bool IsPointEnt()","documentation":"Returns whether this is a point entity."},{"declaration":"bool IsNetClient()","documentation":"Returns whether this is a net client."},{"declaration":"bool IsPlayer()","documentation":"Returns whether this entity is a player."},{"declaration":"bool IsMonster()","documentation":"Returns whether this entity is a monster."},{"declaration":"bool IsInWorld()","documentation":"Returns whether this entity is in the world."},{"declaration":"bool ReflectGauss()","documentation":"Returns whether this entity reflects gauss shots."},{"declaration":"bool IsBSPModel()","documentation":"Returns whether this entity is a BSP model."},{"declaration":"bool IsAlive()","documentation":"Returns whether this entity is alive."},{"declaration":"bool IsSneaking()","documentation":"Returns whether this entity is sneaking."},{"declaration":"bool OnControls(entvars_t@ pev)","documentation":"Reacts to controls set on the pev."},{"declaration":"void StopSneaking()","documentation":"Stops sneaking."},{"declaration":"void StartSneaking()","documentation":"Starts sneaking."},{"declaration":"void SetToggleState(int state)","documentation":"Sets this entity's toggle state."},{"declaration":"int DamageDecal(int bitsDamageType)","documentation":"Returns the damage decal<br/>See decal_e."},{"declaration":"void OverrideReset()","documentation":"Resets this entity."},{"declaration":"bool IsMoving()","documentation":"Returns whether this entity is moving."},{"declaration":"float GetDelay()","documentation":"Gets this entity's trigger delay."},{"declaration":"bool RemovePlayerItem(CBasePlayerItem@ pItem)","documentation":"Removes the given player item to this entity."},{"declaration":"AddPlayerItemResult AddPlayerItem(CBasePlayerItem@ pItem)","documentation":"Adds the given player item to this entity."},{"declaration":"void AddPointsToTeam(int score, const bool bAllowNegativeScore)","documentation":"Adds points to this entity's team."},{"declaration":"void AddPoints(int score, const bool bAllowNegativeScore)","documentation":"Adds points to this entity."},{"declaration":"int GetToggleState()","documentation":"Gets the toggle state.<br/>See the TOGGLE_STATE enum."},{"declaration":"bool SetupModel()","documentation":"Sets up the model."},{"declaration":"int entindex()","documentation":"Returns this entity's index."},{"declaration":"edict_t@ edict()","documentation":"Returns this entity's edict."},{"declaration":"bool IsLockedByMaster()","documentation":"Returns whether this entity is locked by its master."},{"declaration":"bool IsDormant()","documentation":"Returns whether this entity is dormant."},{"declaration":"void MakeDormant()","documentation":"Makes this entity dormant."},{"declaration":"bool Intersects(CBaseEntity@ pOther)","documentation":"Returns whether this entity intersects with the given entity."},{"declaration":"void SUB_UseTargets(CBaseEntity@ pActivator, USE_TYPE useType, float flValue)","documentation":"Calls use on targets."},{"declaration":"void FireBullets(uint cShots, Vector vecSrc, Vector vecDirShooting, Vector vecSpread,float flDistance, Bullet iBulletType, int iTracerFreq = 4, int iDamage = 0, entvars_t@ pevAttacker = null, FireBulletsDrawMode fDraw = FBDM_DRAW)","documentation":"Fires bullets. Must call CMath::MakeAimVectors with an angle vector first."},{"declaration":"bool ShouldToggle(USE_TYPE useType, const bool currentState)","documentation":"Returns whether this entity should toggle."},{"declaration":"void SUB_CallUseToggle()","documentation":"Think function. Calls use toggle on this entity."},{"declaration":"void SUB_FadeOut()","documentation":"Think function. Fades this entity."},{"declaration":"void SUB_StartFadeOut()","documentation":"Think function. Starts fading this entity."},{"declaration":"void SUB_DoNothing()","documentation":"Think function. Explicitly does nothing."},{"declaration":"void SUB_Remove()","documentation":"Think function. Delay-removes this entity."},{"declaration":"bool BlockedByEntity(CBaseEntity@ pOther, float flDamage)","documentation":"Returns true if you should be blocked by the entity, false otherwise. Also deals blocking damage to the entity, if applicable."},{"declaration":"CustomKeyvalues@ GetCustomKeyvalues()","documentation":"Gets this entity's custom keyvalues."},{"declaration":"CBaseMonster@ MyMonsterPointer()","documentation":"Returns this entity as its monster entity, if it is a monster."},{"declaration":"bool IsTriggered(CBaseEntity@ pActivator)","documentation":"Returns whether this entity is triggered by the given entity."},{"declaration":"int BloodColor()","documentation":"Returns the blood color. See the BLOOD_COLOR enum."},{"declaration":"void Killed(entvars_t@pevAtttacker, int iGibbed)","documentation":"Tells this entity it's been killed. See the GIB enum for possible values."},{"declaration":"bool TakeArmor(float flArmor, int bitsDamageType, int armor_cap = 0)","documentation":"Takes armor from this entity. Note: flArmor is added to entity armor. Use negative values to subtract.If armor_cap is non-zero, won't add more than armor_cap. Returns 1 if it took damage, 0 otherwise."},{"declaration":"bool TakeHealth(float flHealth, int bitsDamageType, int health_cap = 0)","documentation":"Takes health from this entity. Note: flHealth is added to entity health. Use negative values to subtract.If health_cap is non-zero, won't add more than health_cap. Returns true if it took damage, false otherwise."},{"declaration":"int TakeDamage(entvars_t@ pevInflictor, entvars_t@ pevAttacker, float flDamage, int bitsDamageType)","documentation":"Causes this entity to take damage. Returns 1 if it took damage, 0 otherwise."},{"declaration":"int Classify()","documentation":"Gets this entity's classification."},{"declaration":"int IRelationshipByClass(CLASS iClass)","documentation":"Gets the relationship between this entity and the given entity classification. See the RELATIONSHIP enum."},{"declaration":"int IRelationship(CBaseEntity@ other)","documentation":"Gets the relationship between this entity and the given entity. See the RELATIONSHIP enum."},{"declaration":"void ClearClassification()","documentation":"Clears this entity's classification override."},{"declaration":"void SetClassificationFromEntity(CBaseEntity@ pEntity)","documentation":"Sets this entity's classification override to the classification override set on the given entity. Can override the entity's player ally setting."},{"declaration":"void SetClassification(int cl)","documentation":"Sets this entity's classification override. Can override the entity's player ally setting."},{"declaration":"int GetClassification(int cl)","documentation":"Gets this entity's classification. Returns the given value if none is set. See the CLASSIFICATION enum."},{"declaration":"void SetObjectCollisionBox()","documentation":"Sets up the object collision box."},{"declaration":"int ObjectCaps()","documentation":"Gets this entity's objects caps. See the FCAP enum."},{"declaration":"void Precache()","documentation":"Precaches the entity. Do not call directly."},{"declaration":"bool opEquals(CBaseEntity@ pOther)","documentation":"Compares 2 entities for equality."},{"declaration":"void SetPlayerAllyDirect(bool fState)","documentation":"Sets this entity's player ally status.</br>Use this only if you need the setting to be exactly what you give it (e.g. when copying from another monster)"},{"declaration":"void SetPlayerAlly(bool fState)","documentation":"Sets this entity's player ally status."},{"declaration":"bool IsPlayerAlly() const","documentation":"Returns whether this entity is allied to players."},{"declaration":"int FindMonstersInWorld(array<CBaseEntity@>@ pArray, int flagMask)","documentation":"Finds monsters in the world"},{"declaration":"string SOUNDREPLACEMENT_Find(const string& in szFilename)","documentation":"Find sound replacement for the given file."},{"declaration":"bool FVisibleFromPos(const Vector& in vecTarget, const Vector& in vecStart)","documentation":"Returns whether this entity is visible from the given position."},{"declaration":"string GetTargetname() const","documentation":"Returns this entity's target name."},{"declaration":"string GetClassname() const","documentation":"Returns this entity's class name."},{"declaration":"string TeamID()","documentation":"Returns this entity's team ID."},{"declaration":"bool HasTarget(const string& in szTarget)","documentation":"Returns whether this entity has the given target."},{"declaration":"int GiveAmmo(int iAmount, const string& in szName, int iMax, const bool fFromWeapon = true)","documentation":"Gives ammo to this entity."},{"declaration":"void TraceBleed(float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)","documentation":"Traces entity bleed event."},{"declaration":"void TraceAttack(entvars_t@ pevAttacker, float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)","documentation":"Traces an attack by the given entity to this entity."},{"declaration":"bool KeyValue(const string& in szKeyName, const string& in szValue)","documentation":"Sets keyvalue data on this entity"},{"declaration":"void SetOrigin(const Vector& in vecOrigin)","documentation":"Sets this entity's (absolute) origin"},{"declaration":"const Vector& GetOrigin() const","documentation":"Gets the entity's (absolute) origin."},{"declaration":"CBaseEntity@ opImplCast()","documentation":"Implicitly casts to base type."}],"properties":[{"namespace":"","declaration":"Vector m_vecOriginalRenderColor","documentation":"Original render color."},{"namespace":"","declaration":"float m_flOriginalRenderAmount","documentation":"Original render amount."},{"namespace":"","declaration":"int m_iOriginalRenderFX","documentation":"Original render FX."},{"namespace":"","declaration":"int m_iOriginalRenderMode","documentation":"Original render model."},{"namespace":"","declaration":"string_t classnameInFilterType","documentation":"Class name in filter type."},{"namespace":"","declaration":"string_t targetnameInFilterType","documentation":"Target name in filter type."},{"namespace":"","declaration":"string_t classnameOutFilterType","documentation":"Class name out filter type."},{"namespace":"","declaration":"string_t targetnameOutFilterType","documentation":"Target name out filter type."},{"namespace":"","declaration":"Vector m_vecLastOrigin","documentation":"Last origin vector"},{"namespace":"","declaration":"bool m_fCustomModel","documentation":"Whether a custom model is used."},{"namespace":"","declaration":"bool m_fCanFadeStart","documentation":"Whether fading can start."},{"namespace":"","declaration":"float m_flMaximumFadeWaitB","documentation":"Maximum fade wait time B."},{"namespace":"","declaration":"float m_flMaximumFadeWait","documentation":"Maximum fade wait time."},{"namespace":"","declaration":"int m_iClassSelection","documentation":"The overridden classification."},{"namespace":"","declaration":"bool m_fOverrideClass","documentation":"Whether this entity overrides the classification."},{"namespace":"","declaration":"entvars_t@ pev","documentation":"Entity variables"}],"className":"CBasePlayerAmmo","documentation":"Player ammo class","namespace":""},{"flags":262145,"methods":[{"declaration":"void ChangeWeaponSkin(int16 skin)","documentation":""},{"declaration":"void SetFOV(int iFOV)","documentation":"0 means reset to default fov"},{"declaration":"void PrecacheCustomModels()","documentation":"Precaches custom models if needed."},{"declaration":"string GetV_Model(const string& in szAlternative)","documentation":"Gets the weapon's V model."},{"declaration":"string GetV_Model()","documentation":"Gets the weapon's V model."},{"declaration":"string GetW_Model(const string& in szAlternative)","documentation":"Gets the weapon's W model."},{"declaration":"string GetW_Model()","documentation":"Gets the weapon's W model."},{"declaration":"string GetP_Model(const string& in szAlternative)","documentation":"Gets the weapon's P model."},{"declaration":"string GetP_Model()","documentation":"Gets the weapon's P model."},{"declaration":"void BurstSupplement()","documentation":""},{"declaration":"bool UseDecrement()","documentation":"Whether the client predicts this weapon"},{"declaration":"bool ShouldWeaponIdle()","documentation":""},{"declaration":"void RetireWeapon()","documentation":"no more ammo for this gun, put it away."},{"declaration":"void WeaponIdle()","documentation":"called when no buttons pressed"},{"declaration":"bool ShouldReload()","documentation":"Returns whether this weapon should reload automatically."},{"declaration":"void FinishReload()","documentation":"Finishes the reload for this weapon."},{"declaration":"void Reload()","documentation":""},{"declaration":"void TertiaryAttack()","documentation":"do \"+ATTACK3\""},{"declaration":"void SecondaryAttack()","documentation":"do \"+ATTACK2\""},{"declaration":"void PrimaryAttack()","documentation":"do \"+ATTACK\""},{"declaration":"bool DefaultReload(int iClipSize, int iAnim, float flDelay, int iSubModel = 0)","documentation":""},{"declaration":"bool DefaultReload(int iClipSize, int iAnim, float flDelay, int iSubModel, int iClip, int iAmmoType)","documentation":""},{"declaration":"bool DefaultDeploy(const string& in szViewModel, const string& in szWeaponModel, int iAnim, const string& in szAnimExt, int skiplocal = 0, int body = 0)","documentation":""},{"declaration":"bool IsUseable()","documentation":""},{"declaration":"Vector BulletAccuracy(const Vector& in vecMoving, const Vector& in vecStanding, const Vector& in vecCrouched)","documentation":"Universal code to determine player bullet accuracy based on speed/stance"},{"declaration":"void SendWeaponAnim(int iAnim, int skiplocal = 0, int body = 0)","documentation":"skiplocal is 1 if client is predicting weapon animations"},{"declaration":"void ResetEmptySound()","documentation":""},{"declaration":"bool PlayEmptySound()","documentation":""},{"declaration":"bool AddPrimaryAmmo(int iCount, const string& in szName, int iMaxCarry)","documentation":""},{"declaration":"bool AddPrimaryAmmo(int iCount, const string& in szName, int iMaxClip, int iMaxCarry)","documentation":""},{"declaration":"bool AddWeapon()","documentation":""},{"declaration":"bool ExtractClipAmmo(CBasePlayerWeapon@ pWeapon)","documentation":""},{"declaration":"bool ExtractAmmo(CBasePlayerWeapon@ pWeapon)","documentation":""},{"declaration":"bool CanHaveDuplicates()","documentation":"Can this weapon have duplicates added?"},{"declaration":"CBasePlayerItem@ DropItem()","documentation":"CBaseEntity to drop.</br>By default, this entity."},{"declaration":"float GetRespawnTime() const","documentation":"Gets this item's respawn time (time from pickup to respawn)."},{"declaration":"int iFlags()","documentation":"Gets the item flags."},{"declaration":"int iWeight()","documentation":"Gets the item weight."},{"declaration":"int iMaxClip()","documentation":"Gets the max clip amount."},{"declaration":"string pszName()","documentation":"Gets the name of this item."},{"declaration":"int iMaxAmmo2()","documentation":"Gets the secondary ammo maximum."},{"declaration":"string pszAmmo2()","documentation":"Gets the name of the secondary ammo."},{"declaration":"int iMaxAmmo1()","documentation":"Gets the primary ammo maximum."},{"declaration":"string pszAmmo1()","documentation":"Gets the name of the primary ammo."},{"declaration":"int iItemPosition()","documentation":"Gets the item position."},{"declaration":"int iItemSlot()","documentation":"Gets the slot this item is in. 0 to MAX_ITEMS_SLOTS."},{"declaration":"CBasePlayerWeapon@ GetWeaponPtr()","documentation":"Gets this item as a weapon. Returns null if this is not a weapon."},{"declaration":"bool UpdateClientData(CBasePlayer@ pPlayer)","documentation":"Updates client data."},{"declaration":"int SecondaryAmmoIndex()","documentation":"Gets the secondary ammo index, or -1 if this item doesn't use secondary ammo."},{"declaration":"int PrimaryAmmoIndex()","documentation":"Gets the primary ammo index, or -1 if this item doesn't use primary ammo."},{"declaration":"void AttachToPlayer(CBasePlayer@ pPlayer)","documentation":"Attach this item to the given player."},{"declaration":"void Kill()","documentation":"Kills this item."},{"declaration":"void Drop()","documentation":"Drops this item."},{"declaration":"void UpdateItemInfo()","documentation":"Updates item info."},{"declaration":"void Holster(int iSkipLocal = 0)","documentation":"Holsters this weapon."},{"declaration":"bool CanHolster()","documentation":"Can this weapon be put away right now?"},{"declaration":"bool Deploy()","documentation":"Returns if deploy was successful."},{"declaration":"bool CanDeploy()","documentation":"Returns whether this item can deploy."},{"declaration":"void GetItemInfo(ItemInfo& out info)","documentation":"Gets item info."},{"declaration":"void CheckRespawn()","documentation":"Check respawn."},{"declaration":"void FallInit()","documentation":"Fall init."},{"declaration":"CBasePlayerItem@ RespawnItem()","documentation":"Copy a weapon."},{"declaration":"void AttemptToMaterialize()","documentation":"Think function. The weapon desires to become visible and tangible, if the game rules allow for it."},{"declaration":"void Materialize()","documentation":"Make a weapon visible and tangible."},{"declaration":"void FallThink()","documentation":"Think function. When an item is first spawned, this think is run to determine when the object has hit the ground."},{"declaration":"void ItemUse(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue)","documentation":"Default weapon use function."},{"declaration":"void DefaultTouch(CBaseEntity@ pOther)","documentation":"Touch function. Default touch."},{"declaration":"void Collect(CBaseEntity@ pOther)","documentation":"Attempts to let pOther collect this item."},{"declaration":"void DestroyItem()","documentation":"Think function. Destroys this item."},{"declaration":"bool AddDuplicate(CBasePlayerItem@ pItem)","documentation":"returns true if this item wants the duplicate removed from the world."},{"declaration":"bool AddToPlayer(CBasePlayer@ pPlayer)","documentation":"Returns true if this item wants itself added to the player's inventory."},{"declaration":"int GetSequenceActivityName(int iSequence)","documentation":"Sets the sequence box."},{"declaration":"void SetSequenceBox()","documentation":"Sets the sequence box."},{"declaration":"int GetAttachmentCount()","documentation":"Gets the number of attachments that the current model has."},{"declaration":"bool ExtractBbox(int iSequence, Vector& out mins, Vector& out maxs)","documentation":"Extracts the bounding box of the current model."},{"declaration":"int GetBodygroup(int iGroup)","documentation":"Gets the value of the given body group."},{"declaration":"void SetBodygroup(int iGroup, int iValue)","documentation":"Sets the given body group to the given value."},{"declaration":"void GetAttachment(int iAttachment, Vector& out origin, Vector& out angles)","documentation":"Gets the attachment position."},{"declaration":"int FindTransition(int iEndingSequence, int iGoalSequence)","documentation":"Find the transition between 2 sequences."},{"declaration":"int FindTransition(int iEndingSequence, int iGoalSequence, int& out iDir)","documentation":"Find the transition between 2 sequences."},{"declaration":"void GetAutomovement(Vector& out origin, Vector& out angles, float flInterval = 0.1f)","documentation":"Gets automatic movement."},{"declaration":"void GetBonePosition(int iBone, Vector& out origin, Vector& out angles)","documentation":"Gets the position of the given bone."},{"declaration":"float SetBlending(int iBlender, float flValue)","documentation":"Sets the given blending controller to the given value."},{"declaration":"void InitBoneControllers()","documentation":"Initializes bone controllers."},{"declaration":"float SetBoneController(int iController, float flValue)","documentation":"Sets the specified bone controller to the given value."},{"declaration":"void DispatchAnimEvents(float flFutureInterval = 0.1f)","documentation":"Handle events that have happend since last time called up until X seconds into the future."},{"declaration":"void ResetGaitSequenceInfo()","documentation":"Resets gait sequence info."},{"declaration":"void ResetSequenceInfo()","documentation":"Resets sequence info."},{"declaration":"int LookupSequence(const string& in szLabel)","documentation":"Returns the index of the given sequence, or -1 if no such sequence exists."},{"declaration":"int LookupActivityHeaviest(int iActivity)","documentation":"Returns the index of the given activity that has the heaviest weight, or -1 if no such activity exists."},{"declaration":"int LookupActivity(int iActivity)","documentation":"Returns the index of the given activity, or -1 if no such activity exists."},{"declaration":"int GetSequenceFlags()","documentation":"Get sequence flags."},{"declaration":"float StudioFrameAdvance(float flInterval = 0.0f)","documentation":"Accumulate animation frame time from last time called until now."},{"declaration":"void DelayThink()","documentation":"Think function. Used internally."},{"declaration":"void SUB_UseTargets(CBaseEntity@ pActivator, USE_TYPE useType, float flValue)","documentation":"Causes this entity to trigger its targets with an optional delay."},{"declaration":"void ClearUserData()","documentation":"Clears the user data on this entity. WARNING: clears all data.<br/>Only map scripts can use this."},{"declaration":"dictionaryValue& GetUserData(const string& in szKey)","documentation":"Gets the user data stored under the specified key on this entity.<br/>Do not keep references to this data, the object might be removed from this entity.<br/>Only map scripts can use this."},{"declaration":"dictionary@ GetUserData()","documentation":"Gets the user data on this entity. Do not keep references to this data, the object might be removed from this entity.<br/>Only map scripts can use this."},{"declaration":"void EndRevive(float flTimeUntilRevive)","documentation":"Called when this entity should be revived. flTimeUntilRevive is the time until the revival should start."},{"declaration":"void BeginRevive(float flTimeUntilRevive)","documentation":"Prepares this entity for revival. flTimeUntilRevive is the time until the revive action completes."},{"declaration":"bool IsRevivable()","documentation":"Returns whether this entity is revivable at this time."},{"declaration":"void OnDestroy()","documentation":"Entity destructor."},{"declaration":"void OnCreate()","documentation":"Entity constructor."},{"declaration":"void GetDamagePoints(entvars_t@ pevAttacker, entvars_t@ pevInflictor, float flDamage)","documentation":"Adds damage points to the inflicting entity."},{"declaration":"float GetPointsForDamage(float flDamage)","documentation":"Returns the points received for damage done."},{"declaration":"bool IsFacing(entvars_t@ pevTest, float flDotProduct = VIEW_FIELD_ULTRA_NARROW)","documentation":"Returns whether this entity is facing the given entity, within the given view field."},{"declaration":"bool FVisible(const Vector& in vecOrigin)","documentation":"Returns whether this entity is visible from the given origin."},{"declaration":"bool FVisible(CBaseEntity@ pEntity, bool fIgnoreGlass)","documentation":"Returns whether this entity is visible to the given entity."},{"declaration":"int Illumination()","documentation":"Returns this entity's illumination."},{"declaration":"Vector BodyTarget(const Vector& in posSrc)","documentation":"Returns this entity's body target for shooting."},{"declaration":"Vector EarPosition()","documentation":"Returns this entity's ear position."},{"declaration":"Vector EyePosition()","documentation":"Returns this entity's eye position."},{"declaration":"Vector Center()","documentation":"Returns this entity's center."},{"declaration":"bool FBecomeProne()","documentation":"Makes this entity become prone."},{"declaration":"CBaseEntity@ Respawn()","documentation":"Respawns this entity."},{"declaration":"void UpdateOnRemove()","documentation":"Updates this entity when removed."},{"declaration":"void Blocked(CBaseEntity@ pOther)","documentation":"Triggers this entity's blocked function."},{"declaration":"void Use(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f)","documentation":"Trigger's this entity's use function."},{"declaration":"void Touch(CBaseEntity@ pOther)","documentation":"Triggers this entity's touch function."},{"declaration":"void Think()","documentation":"Makes this entity think. Do not call directly."},{"declaration":"CBaseEntity@ GetNextTarget()","documentation":"Gets the next target to trigger."},{"declaration":"bool CriticalRemove()","documentation":"Removes this entity in critical situations."},{"declaration":"bool IsMachine()","documentation":"Returns whether this is a machine."},{"declaration":"bool IsPointEnt()","documentation":"Returns whether this is a point entity."},{"declaration":"bool IsNetClient()","documentation":"Returns whether this is a net client."},{"declaration":"bool IsPlayer()","documentation":"Returns whether this entity is a player."},{"declaration":"bool IsMonster()","documentation":"Returns whether this entity is a monster."},{"declaration":"bool IsInWorld()","documentation":"Returns whether this entity is in the world."},{"declaration":"bool ReflectGauss()","documentation":"Returns whether this entity reflects gauss shots."},{"declaration":"bool IsBSPModel()","documentation":"Returns whether this entity is a BSP model."},{"declaration":"bool IsAlive()","documentation":"Returns whether this entity is alive."},{"declaration":"bool IsSneaking()","documentation":"Returns whether this entity is sneaking."},{"declaration":"bool OnControls(entvars_t@ pev)","documentation":"Reacts to controls set on the pev."},{"declaration":"void StopSneaking()","documentation":"Stops sneaking."},{"declaration":"void StartSneaking()","documentation":"Starts sneaking."},{"declaration":"void SetToggleState(int state)","documentation":"Sets this entity's toggle state."},{"declaration":"int DamageDecal(int bitsDamageType)","documentation":"Returns the damage decal<br/>See decal_e."},{"declaration":"void OverrideReset()","documentation":"Resets this entity."},{"declaration":"bool IsMoving()","documentation":"Returns whether this entity is moving."},{"declaration":"float GetDelay()","documentation":"Gets this entity's trigger delay."},{"declaration":"bool RemovePlayerItem(CBasePlayerItem@ pItem)","documentation":"Removes the given player item to this entity."},{"declaration":"AddPlayerItemResult AddPlayerItem(CBasePlayerItem@ pItem)","documentation":"Adds the given player item to this entity."},{"declaration":"void AddPointsToTeam(int score, const bool bAllowNegativeScore)","documentation":"Adds points to this entity's team."},{"declaration":"void AddPoints(int score, const bool bAllowNegativeScore)","documentation":"Adds points to this entity."},{"declaration":"int GetToggleState()","documentation":"Gets the toggle state.<br/>See the TOGGLE_STATE enum."},{"declaration":"bool SetupModel()","documentation":"Sets up the model."},{"declaration":"int entindex()","documentation":"Returns this entity's index."},{"declaration":"edict_t@ edict()","documentation":"Returns this entity's edict."},{"declaration":"bool IsLockedByMaster()","documentation":"Returns whether this entity is locked by its master."},{"declaration":"bool IsDormant()","documentation":"Returns whether this entity is dormant."},{"declaration":"void MakeDormant()","documentation":"Makes this entity dormant."},{"declaration":"bool Intersects(CBaseEntity@ pOther)","documentation":"Returns whether this entity intersects with the given entity."},{"declaration":"void FireBullets(uint cShots, Vector vecSrc, Vector vecDirShooting, Vector vecSpread,float flDistance, Bullet iBulletType, int iTracerFreq = 4, int iDamage = 0, entvars_t@ pevAttacker = null, FireBulletsDrawMode fDraw = FBDM_DRAW)","documentation":"Fires bullets. Must call CMath::MakeAimVectors with an angle vector first."},{"declaration":"bool ShouldToggle(USE_TYPE useType, const bool currentState)","documentation":"Returns whether this entity should toggle."},{"declaration":"void SUB_CallUseToggle()","documentation":"Think function. Calls use toggle on this entity."},{"declaration":"void SUB_FadeOut()","documentation":"Think function. Fades this entity."},{"declaration":"void SUB_StartFadeOut()","documentation":"Think function. Starts fading this entity."},{"declaration":"void SUB_DoNothing()","documentation":"Think function. Explicitly does nothing."},{"declaration":"void SUB_Remove()","documentation":"Think function. Delay-removes this entity."},{"declaration":"bool BlockedByEntity(CBaseEntity@ pOther, float flDamage)","documentation":"Returns true if you should be blocked by the entity, false otherwise. Also deals blocking damage to the entity, if applicable."},{"declaration":"CustomKeyvalues@ GetCustomKeyvalues()","documentation":"Gets this entity's custom keyvalues."},{"declaration":"CBaseMonster@ MyMonsterPointer()","documentation":"Returns this entity as its monster entity, if it is a monster."},{"declaration":"bool IsTriggered(CBaseEntity@ pActivator)","documentation":"Returns whether this entity is triggered by the given entity."},{"declaration":"int BloodColor()","documentation":"Returns the blood color. See the BLOOD_COLOR enum."},{"declaration":"void Killed(entvars_t@pevAtttacker, int iGibbed)","documentation":"Tells this entity it's been killed. See the GIB enum for possible values."},{"declaration":"bool TakeArmor(float flArmor, int bitsDamageType, int armor_cap = 0)","documentation":"Takes armor from this entity. Note: flArmor is added to entity armor. Use negative values to subtract.If armor_cap is non-zero, won't add more than armor_cap. Returns 1 if it took damage, 0 otherwise."},{"declaration":"bool TakeHealth(float flHealth, int bitsDamageType, int health_cap = 0)","documentation":"Takes health from this entity. Note: flHealth is added to entity health. Use negative values to subtract.If health_cap is non-zero, won't add more than health_cap. Returns true if it took damage, false otherwise."},{"declaration":"int TakeDamage(entvars_t@ pevInflictor, entvars_t@ pevAttacker, float flDamage, int bitsDamageType)","documentation":"Causes this entity to take damage. Returns 1 if it took damage, 0 otherwise."},{"declaration":"int Classify()","documentation":"Gets this entity's classification."},{"declaration":"int IRelationshipByClass(CLASS iClass)","documentation":"Gets the relationship between this entity and the given entity classification. See the RELATIONSHIP enum."},{"declaration":"int IRelationship(CBaseEntity@ other)","documentation":"Gets the relationship between this entity and the given entity. See the RELATIONSHIP enum."},{"declaration":"void ClearClassification()","documentation":"Clears this entity's classification override."},{"declaration":"void SetClassificationFromEntity(CBaseEntity@ pEntity)","documentation":"Sets this entity's classification override to the classification override set on the given entity. Can override the entity's player ally setting."},{"declaration":"void SetClassification(int cl)","documentation":"Sets this entity's classification override. Can override the entity's player ally setting."},{"declaration":"int GetClassification(int cl)","documentation":"Gets this entity's classification. Returns the given value if none is set. See the CLASSIFICATION enum."},{"declaration":"void SetObjectCollisionBox()","documentation":"Sets up the object collision box."},{"declaration":"int ObjectCaps()","documentation":"Gets this entity's objects caps. See the FCAP enum."},{"declaration":"void Precache()","documentation":"Precaches the entity. Do not call directly."},{"declaration":"bool opEquals(CBaseEntity@ pOther)","documentation":"Compares 2 entities for equality."},{"declaration":"void SetPlayerAllyDirect(bool fState)","documentation":"Sets this entity's player ally status.</br>Use this only if you need the setting to be exactly what you give it (e.g. when copying from another monster)"},{"declaration":"void SetPlayerAlly(bool fState)","documentation":"Sets this entity's player ally status."},{"declaration":"bool IsPlayerAlly() const","documentation":"Returns whether this entity is allied to players."},{"declaration":"int FindMonstersInWorld(array<CBaseEntity@>@ pArray, int flagMask)","documentation":"Finds monsters in the world"},{"declaration":"string SOUNDREPLACEMENT_Find(const string& in szFilename)","documentation":"Find sound replacement for the given file."},{"declaration":"bool FVisibleFromPos(const Vector& in vecTarget, const Vector& in vecStart)","documentation":"Returns whether this entity is visible from the given position."},{"declaration":"string GetTargetname() const","documentation":"Returns this entity's target name."},{"declaration":"string GetClassname() const","documentation":"Returns this entity's class name."},{"declaration":"string TeamID()","documentation":"Returns this entity's team ID."},{"declaration":"bool HasTarget(const string& in szTarget)","documentation":"Returns whether this entity has the given target."},{"declaration":"int GiveAmmo(int iAmount, const string& in szName, int iMax, const bool fFromWeapon = true)","documentation":"Gives ammo to this entity."},{"declaration":"void TraceBleed(float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)","documentation":"Traces entity bleed event."},{"declaration":"void TraceAttack(entvars_t@ pevAttacker, float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)","documentation":"Traces an attack by the given entity to this entity."},{"declaration":"bool KeyValue(const string& in szKeyName, const string& in szValue)","documentation":"Sets keyvalue data on this entity"},{"declaration":"void SetOrigin(const Vector& in vecOrigin)","documentation":"Sets this entity's (absolute) origin"},{"declaration":"const Vector& GetOrigin() const","documentation":"Gets the entity's (absolute) origin."},{"declaration":"CBaseEntity@ opImplCast()","documentation":"Implicitly casts to base type."},{"declaration":"CBaseDelay@ opImplCast()","documentation":"Implicitly casts to base type."},{"declaration":"CBaseAnimating@ opImplCast()","documentation":"Implicitly casts to base type."},{"declaration":"CBasePlayerItem@ opImplCast()","documentation":"Implicitly casts to base type."}],"properties":[{"namespace":"","declaration":"int m_iDefaultAmmo","documentation":"how much ammo you get when you pick up this weapon as placed by a level designer."},{"namespace":"","declaration":"float m_flNextBurstRound","documentation":"When the next burt round is to be fired"},{"namespace":"","declaration":"bool m_fBlockWeapons","documentation":"Weapons are blocked, can't be used"},{"namespace":"","declaration":"bool m_fInZoom","documentation":"Weapon is zoomed in"},{"namespace":"","declaration":"float m_flCustomDmg","documentation":"per-entity weapon damage"},{"namespace":"","declaration":"bool m_fInReload","documentation":"Are we in the middle of a reload"},{"namespace":"","declaration":"int m_iClip2","documentation":"number of shots left in the secondary weapon clip, -1 it not used"},{"namespace":"","declaration":"int m_iClip","documentation":"number of shots left in the primary weapon clip, -1 it not used"},{"namespace":"","declaration":"int m_iSecondaryAmmoType","documentation":"\"secondary\" ammo index into players m_rgAmmo[]"},{"namespace":"","declaration":"int m_iPrimaryAmmoType","documentation":"\"primary\" ammo index into players m_rgAmmo[]"},{"namespace":"","declaration":"float m_flTimeWeaponIdle","documentation":"soonest time ItemPostFrame will call WeaponIdle"},{"namespace":"","declaration":"float m_flNextTertiaryAttack","documentation":"soonest time ItemPostFrame will call TertiaryAttack"},{"namespace":"","declaration":"float m_flNextSecondaryAttack","documentation":"soonest time ItemPostFrame will call SecondaryAttack"},{"namespace":"","declaration":"float m_flNextPrimaryAttack","documentation":"soonest time ItemPostFrame will call PrimaryAttack"},{"namespace":"","declaration":"bool m_bFireOnEmpty","documentation":"True when the gun is empty and the player is still holding down the attack key(s)"},{"namespace":"","declaration":"bool m_bPlayEmptySound","documentation":"Whether to play the empty sound when the player attempts to fire"},{"namespace":"","declaration":"bool m_bExclusiveHold","documentation":"If set, as long as a player has this item, the player must keep this weapon selected.No more than one item with this set can be carried at one time."},{"namespace":"","declaration":"float m_flLastBounce","documentation":"The last bounce time."},{"namespace":"","declaration":"const int m_iId","documentation":"The item id."},{"namespace":"","declaration":"CBasePlayerItem@ m_pNext","documentation":"Gets the next item. null if no next item."},{"namespace":"","declaration":"CBasePlayer@ m_pPlayer","documentation":"The owning player. null if no owner."},{"namespace":"","declaration":"bool m_fSequenceLoops","documentation":"True if the sequence loops."},{"namespace":"","declaration":"bool m_fSequenceFinished","documentation":"Flag set when StudioAdvanceFrame moves across a frame boundry."},{"namespace":"","declaration":"float m_flLastGaitEventCheck","documentation":"Last time the event list was checked."},{"namespace":"","declaration":"float m_flLastEventCheck","documentation":"Last time the event list was checked."},{"namespace":"","declaration":"float m_flGroundSpeed","documentation":"Computed linear movement rate for current sequence."},{"namespace":"","declaration":"float m_flFrameRate","documentation":"Computed FPS for current sequence."},{"namespace":"","declaration":"string_t m_iszKillTarget","documentation":"The name of the kill target, if any."},{"namespace":"","declaration":"float m_flDelay","documentation":"Delay before fire."},{"namespace":"","declaration":"Vector m_vecOriginalRenderColor","documentation":"Original render color."},{"namespace":"","declaration":"float m_flOriginalRenderAmount","documentation":"Original render amount."},{"namespace":"","declaration":"int m_iOriginalRenderFX","documentation":"Original render FX."},{"namespace":"","declaration":"int m_iOriginalRenderMode","documentation":"Original render model."},{"namespace":"","declaration":"string_t classnameInFilterType","documentation":"Class name in filter type."},{"namespace":"","declaration":"string_t targetnameInFilterType","documentation":"Target name in filter type."},{"namespace":"","declaration":"string_t classnameOutFilterType","documentation":"Class name out filter type."},{"namespace":"","declaration":"string_t targetnameOutFilterType","documentation":"Target name out filter type."},{"namespace":"","declaration":"Vector m_vecLastOrigin","documentation":"Last origin vector"},{"namespace":"","declaration":"bool m_fCustomModel","documentation":"Whether a custom model is used."},{"namespace":"","declaration":"bool m_fCanFadeStart","documentation":"Whether fading can start."},{"namespace":"","declaration":"float m_flMaximumFadeWaitB","documentation":"Maximum fade wait time B."},{"namespace":"","declaration":"float m_flMaximumFadeWait","documentation":"Maximum fade wait time."},{"namespace":"","declaration":"int m_iClassSelection","documentation":"The overridden classification."},{"namespace":"","declaration":"bool m_fOverrideClass","documentation":"Whether this entity overrides the classification."},{"namespace":"","declaration":"entvars_t@ pev","documentation":"Entity variables"}],"className":"CBasePlayerWeapon","documentation":"Player Weapon entity base class","namespace":""},{"flags":262145,"methods":[{"declaration":"CBasePlayerWeapon@ opCast()","documentation":"Explicitly casts to sub type."},{"declaration":"bool CanHaveDuplicates()","documentation":"Can this weapon have duplicates added?"},{"declaration":"CBasePlayerItem@ DropItem()","documentation":"CBaseEntity to drop.</br>By default, this entity."},{"declaration":"float GetRespawnTime() const","documentation":"Gets this item's respawn time (time from pickup to respawn)."},{"declaration":"int iFlags()","documentation":"Gets the item flags."},{"declaration":"int iWeight()","documentation":"Gets the item weight."},{"declaration":"int iMaxClip()","documentation":"Gets the max clip amount."},{"declaration":"string pszName()","documentation":"Gets the name of this item."},{"declaration":"int iMaxAmmo2()","documentation":"Gets the secondary ammo maximum."},{"declaration":"string pszAmmo2()","documentation":"Gets the name of the secondary ammo."},{"declaration":"int iMaxAmmo1()","documentation":"Gets the primary ammo maximum."},{"declaration":"string pszAmmo1()","documentation":"Gets the name of the primary ammo."},{"declaration":"int iItemPosition()","documentation":"Gets the item position."},{"declaration":"int iItemSlot()","documentation":"Gets the slot this item is in. 0 to MAX_ITEMS_SLOTS."},{"declaration":"CBasePlayerWeapon@ GetWeaponPtr()","documentation":"Gets this item as a weapon. Returns null if this is not a weapon."},{"declaration":"bool UpdateClientData(CBasePlayer@ pPlayer)","documentation":"Updates client data."},{"declaration":"int SecondaryAmmoIndex()","documentation":"Gets the secondary ammo index, or -1 if this item doesn't use secondary ammo."},{"declaration":"int PrimaryAmmoIndex()","documentation":"Gets the primary ammo index, or -1 if this item doesn't use primary ammo."},{"declaration":"void AttachToPlayer(CBasePlayer@ pPlayer)","documentation":"Attach this item to the given player."},{"declaration":"void Kill()","documentation":"Kills this item."},{"declaration":"void Drop()","documentation":"Drops this item."},{"declaration":"void UpdateItemInfo()","documentation":"Updates item info."},{"declaration":"void Holster(int iSkipLocal = 0)","documentation":"Holsters this weapon."},{"declaration":"bool CanHolster()","documentation":"Can this weapon be put away right now?"},{"declaration":"bool Deploy()","documentation":"Returns if deploy was successful."},{"declaration":"bool CanDeploy()","documentation":"Returns whether this item can deploy."},{"declaration":"void GetItemInfo(ItemInfo& out info)","documentation":"Gets item info."},{"declaration":"void CheckRespawn()","documentation":"Check respawn."},{"declaration":"void FallInit()","documentation":"Fall init."},{"declaration":"CBasePlayerItem@ RespawnItem()","documentation":"Copy a weapon."},{"declaration":"void AttemptToMaterialize()","documentation":"Think function. The weapon desires to become visible and tangible, if the game rules allow for it."},{"declaration":"void Materialize()","documentation":"Make a weapon visible and tangible."},{"declaration":"void FallThink()","documentation":"Think function. When an item is first spawned, this think is run to determine when the object has hit the ground."},{"declaration":"void ItemUse(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue)","documentation":"Default weapon use function."},{"declaration":"void DefaultTouch(CBaseEntity@ pOther)","documentation":"Touch function. Default touch."},{"declaration":"void Collect(CBaseEntity@ pOther)","documentation":"Attempts to let pOther collect this item."},{"declaration":"void DestroyItem()","documentation":"Think function. Destroys this item."},{"declaration":"bool AddDuplicate(CBasePlayerItem@ pItem)","documentation":"returns true if this item wants the duplicate removed from the world."},{"declaration":"bool AddToPlayer(CBasePlayer@ pPlayer)","documentation":"Returns true if this item wants itself added to the player's inventory."},{"declaration":"int GetSequenceActivityName(int iSequence)","documentation":"Sets the sequence box."},{"declaration":"void SetSequenceBox()","documentation":"Sets the sequence box."},{"declaration":"int GetAttachmentCount()","documentation":"Gets the number of attachments that the current model has."},{"declaration":"bool ExtractBbox(int iSequence, Vector& out mins, Vector& out maxs)","documentation":"Extracts the bounding box of the current model."},{"declaration":"int GetBodygroup(int iGroup)","documentation":"Gets the value of the given body group."},{"declaration":"void SetBodygroup(int iGroup, int iValue)","documentation":"Sets the given body group to the given value."},{"declaration":"void GetAttachment(int iAttachment, Vector& out origin, Vector& out angles)","documentation":"Gets the attachment position."},{"declaration":"int FindTransition(int iEndingSequence, int iGoalSequence)","documentation":"Find the transition between 2 sequences."},{"declaration":"int FindTransition(int iEndingSequence, int iGoalSequence, int& out iDir)","documentation":"Find the transition between 2 sequences."},{"declaration":"void GetAutomovement(Vector& out origin, Vector& out angles, float flInterval = 0.1f)","documentation":"Gets automatic movement."},{"declaration":"void GetBonePosition(int iBone, Vector& out origin, Vector& out angles)","documentation":"Gets the position of the given bone."},{"declaration":"float SetBlending(int iBlender, float flValue)","documentation":"Sets the given blending controller to the given value."},{"declaration":"void InitBoneControllers()","documentation":"Initializes bone controllers."},{"declaration":"float SetBoneController(int iController, float flValue)","documentation":"Sets the specified bone controller to the given value."},{"declaration":"void DispatchAnimEvents(float flFutureInterval = 0.1f)","documentation":"Handle events that have happend since last time called up until X seconds into the future."},{"declaration":"void ResetGaitSequenceInfo()","documentation":"Resets gait sequence info."},{"declaration":"void ResetSequenceInfo()","documentation":"Resets sequence info."},{"declaration":"int LookupSequence(const string& in szLabel)","documentation":"Returns the index of the given sequence, or -1 if no such sequence exists."},{"declaration":"int LookupActivityHeaviest(int iActivity)","documentation":"Returns the index of the given activity that has the heaviest weight, or -1 if no such activity exists."},{"declaration":"int LookupActivity(int iActivity)","documentation":"Returns the index of the given activity, or -1 if no such activity exists."},{"declaration":"int GetSequenceFlags()","documentation":"Get sequence flags."},{"declaration":"float StudioFrameAdvance(float flInterval = 0.0f)","documentation":"Accumulate animation frame time from last time called until now."},{"declaration":"void DelayThink()","documentation":"Think function. Used internally."},{"declaration":"void SUB_UseTargets(CBaseEntity@ pActivator, USE_TYPE useType, float flValue)","documentation":"Causes this entity to trigger its targets with an optional delay."},{"declaration":"void ClearUserData()","documentation":"Clears the user data on this entity. WARNING: clears all data.<br/>Only map scripts can use this."},{"declaration":"dictionaryValue& GetUserData(const string& in szKey)","documentation":"Gets the user data stored under the specified key on this entity.<br/>Do not keep references to this data, the object might be removed from this entity.<br/>Only map scripts can use this."},{"declaration":"dictionary@ GetUserData()","documentation":"Gets the user data on this entity. Do not keep references to this data, the object might be removed from this entity.<br/>Only map scripts can use this."},{"declaration":"void EndRevive(float flTimeUntilRevive)","documentation":"Called when this entity should be revived. flTimeUntilRevive is the time until the revival should start."},{"declaration":"void BeginRevive(float flTimeUntilRevive)","documentation":"Prepares this entity for revival. flTimeUntilRevive is the time until the revive action completes."},{"declaration":"bool IsRevivable()","documentation":"Returns whether this entity is revivable at this time."},{"declaration":"void OnDestroy()","documentation":"Entity destructor."},{"declaration":"void OnCreate()","documentation":"Entity constructor."},{"declaration":"void GetDamagePoints(entvars_t@ pevAttacker, entvars_t@ pevInflictor, float flDamage)","documentation":"Adds damage points to the inflicting entity."},{"declaration":"float GetPointsForDamage(float flDamage)","documentation":"Returns the points received for damage done."},{"declaration":"bool IsFacing(entvars_t@ pevTest, float flDotProduct = VIEW_FIELD_ULTRA_NARROW)","documentation":"Returns whether this entity is facing the given entity, within the given view field."},{"declaration":"bool FVisible(const Vector& in vecOrigin)","documentation":"Returns whether this entity is visible from the given origin."},{"declaration":"bool FVisible(CBaseEntity@ pEntity, bool fIgnoreGlass)","documentation":"Returns whether this entity is visible to the given entity."},{"declaration":"int Illumination()","documentation":"Returns this entity's illumination."},{"declaration":"Vector BodyTarget(const Vector& in posSrc)","documentation":"Returns this entity's body target for shooting."},{"declaration":"Vector EarPosition()","documentation":"Returns this entity's ear position."},{"declaration":"Vector EyePosition()","documentation":"Returns this entity's eye position."},{"declaration":"Vector Center()","documentation":"Returns this entity's center."},{"declaration":"bool FBecomeProne()","documentation":"Makes this entity become prone."},{"declaration":"CBaseEntity@ Respawn()","documentation":"Respawns this entity."},{"declaration":"void UpdateOnRemove()","documentation":"Updates this entity when removed."},{"declaration":"void Blocked(CBaseEntity@ pOther)","documentation":"Triggers this entity's blocked function."},{"declaration":"void Use(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f)","documentation":"Trigger's this entity's use function."},{"declaration":"void Touch(CBaseEntity@ pOther)","documentation":"Triggers this entity's touch function."},{"declaration":"void Think()","documentation":"Makes this entity think. Do not call directly."},{"declaration":"CBaseEntity@ GetNextTarget()","documentation":"Gets the next target to trigger."},{"declaration":"bool CriticalRemove()","documentation":"Removes this entity in critical situations."},{"declaration":"bool IsMachine()","documentation":"Returns whether this is a machine."},{"declaration":"bool IsPointEnt()","documentation":"Returns whether this is a point entity."},{"declaration":"bool IsNetClient()","documentation":"Returns whether this is a net client."},{"declaration":"bool IsPlayer()","documentation":"Returns whether this entity is a player."},{"declaration":"bool IsMonster()","documentation":"Returns whether this entity is a monster."},{"declaration":"bool IsInWorld()","documentation":"Returns whether this entity is in the world."},{"declaration":"bool ReflectGauss()","documentation":"Returns whether this entity reflects gauss shots."},{"declaration":"bool IsBSPModel()","documentation":"Returns whether this entity is a BSP model."},{"declaration":"bool IsAlive()","documentation":"Returns whether this entity is alive."},{"declaration":"bool IsSneaking()","documentation":"Returns whether this entity is sneaking."},{"declaration":"bool OnControls(entvars_t@ pev)","documentation":"Reacts to controls set on the pev."},{"declaration":"void StopSneaking()","documentation":"Stops sneaking."},{"declaration":"void StartSneaking()","documentation":"Starts sneaking."},{"declaration":"void SetToggleState(int state)","documentation":"Sets this entity's toggle state."},{"declaration":"int DamageDecal(int bitsDamageType)","documentation":"Returns the damage decal<br/>See decal_e."},{"declaration":"void OverrideReset()","documentation":"Resets this entity."},{"declaration":"bool IsMoving()","documentation":"Returns whether this entity is moving."},{"declaration":"float GetDelay()","documentation":"Gets this entity's trigger delay."},{"declaration":"bool RemovePlayerItem(CBasePlayerItem@ pItem)","documentation":"Removes the given player item to this entity."},{"declaration":"AddPlayerItemResult AddPlayerItem(CBasePlayerItem@ pItem)","documentation":"Adds the given player item to this entity."},{"declaration":"void AddPointsToTeam(int score, const bool bAllowNegativeScore)","documentation":"Adds points to this entity's team."},{"declaration":"void AddPoints(int score, const bool bAllowNegativeScore)","documentation":"Adds points to this entity."},{"declaration":"int GetToggleState()","documentation":"Gets the toggle state.<br/>See the TOGGLE_STATE enum."},{"declaration":"bool SetupModel()","documentation":"Sets up the model."},{"declaration":"int entindex()","documentation":"Returns this entity's index."},{"declaration":"edict_t@ edict()","documentation":"Returns this entity's edict."},{"declaration":"bool IsLockedByMaster()","documentation":"Returns whether this entity is locked by its master."},{"declaration":"bool IsDormant()","documentation":"Returns whether this entity is dormant."},{"declaration":"void MakeDormant()","documentation":"Makes this entity dormant."},{"declaration":"bool Intersects(CBaseEntity@ pOther)","documentation":"Returns whether this entity intersects with the given entity."},{"declaration":"void FireBullets(uint cShots, Vector vecSrc, Vector vecDirShooting, Vector vecSpread,float flDistance, Bullet iBulletType, int iTracerFreq = 4, int iDamage = 0, entvars_t@ pevAttacker = null, FireBulletsDrawMode fDraw = FBDM_DRAW)","documentation":"Fires bullets. Must call CMath::MakeAimVectors with an angle vector first."},{"declaration":"bool ShouldToggle(USE_TYPE useType, const bool currentState)","documentation":"Returns whether this entity should toggle."},{"declaration":"void SUB_CallUseToggle()","documentation":"Think function. Calls use toggle on this entity."},{"declaration":"void SUB_FadeOut()","documentation":"Think function. Fades this entity."},{"declaration":"void SUB_StartFadeOut()","documentation":"Think function. Starts fading this entity."},{"declaration":"void SUB_DoNothing()","documentation":"Think function. Explicitly does nothing."},{"declaration":"void SUB_Remove()","documentation":"Think function. Delay-removes this entity."},{"declaration":"bool BlockedByEntity(CBaseEntity@ pOther, float flDamage)","documentation":"Returns true if you should be blocked by the entity, false otherwise. Also deals blocking damage to the entity, if applicable."},{"declaration":"CustomKeyvalues@ GetCustomKeyvalues()","documentation":"Gets this entity's custom keyvalues."},{"declaration":"CBaseMonster@ MyMonsterPointer()","documentation":"Returns this entity as its monster entity, if it is a monster."},{"declaration":"bool IsTriggered(CBaseEntity@ pActivator)","documentation":"Returns whether this entity is triggered by the given entity."},{"declaration":"int BloodColor()","documentation":"Returns the blood color. See the BLOOD_COLOR enum."},{"declaration":"void Killed(entvars_t@pevAtttacker, int iGibbed)","documentation":"Tells this entity it's been killed. See the GIB enum for possible values."},{"declaration":"bool TakeArmor(float flArmor, int bitsDamageType, int armor_cap = 0)","documentation":"Takes armor from this entity. Note: flArmor is added to entity armor. Use negative values to subtract.If armor_cap is non-zero, won't add more than armor_cap. Returns 1 if it took damage, 0 otherwise."},{"declaration":"bool TakeHealth(float flHealth, int bitsDamageType, int health_cap = 0)","documentation":"Takes health from this entity. Note: flHealth is added to entity health. Use negative values to subtract.If health_cap is non-zero, won't add more than health_cap. Returns true if it took damage, false otherwise."},{"declaration":"int TakeDamage(entvars_t@ pevInflictor, entvars_t@ pevAttacker, float flDamage, int bitsDamageType)","documentation":"Causes this entity to take damage. Returns 1 if it took damage, 0 otherwise."},{"declaration":"int Classify()","documentation":"Gets this entity's classification."},{"declaration":"int IRelationshipByClass(CLASS iClass)","documentation":"Gets the relationship between this entity and the given entity classification. See the RELATIONSHIP enum."},{"declaration":"int IRelationship(CBaseEntity@ other)","documentation":"Gets the relationship between this entity and the given entity. See the RELATIONSHIP enum."},{"declaration":"void ClearClassification()","documentation":"Clears this entity's classification override."},{"declaration":"void SetClassificationFromEntity(CBaseEntity@ pEntity)","documentation":"Sets this entity's classification override to the classification override set on the given entity. Can override the entity's player ally setting."},{"declaration":"void SetClassification(int cl)","documentation":"Sets this entity's classification override. Can override the entity's player ally setting."},{"declaration":"int GetClassification(int cl)","documentation":"Gets this entity's classification. Returns the given value if none is set. See the CLASSIFICATION enum."},{"declaration":"void SetObjectCollisionBox()","documentation":"Sets up the object collision box."},{"declaration":"int ObjectCaps()","documentation":"Gets this entity's objects caps. See the FCAP enum."},{"declaration":"void Precache()","documentation":"Precaches the entity. Do not call directly."},{"declaration":"bool opEquals(CBaseEntity@ pOther)","documentation":"Compares 2 entities for equality."},{"declaration":"void SetPlayerAllyDirect(bool fState)","documentation":"Sets this entity's player ally status.</br>Use this only if you need the setting to be exactly what you give it (e.g. when copying from another monster)"},{"declaration":"void SetPlayerAlly(bool fState)","documentation":"Sets this entity's player ally status."},{"declaration":"bool IsPlayerAlly() const","documentation":"Returns whether this entity is allied to players."},{"declaration":"int FindMonstersInWorld(array<CBaseEntity@>@ pArray, int flagMask)","documentation":"Finds monsters in the world"},{"declaration":"string SOUNDREPLACEMENT_Find(const string& in szFilename)","documentation":"Find sound replacement for the given file."},{"declaration":"bool FVisibleFromPos(const Vector& in vecTarget, const Vector& in vecStart)","documentation":"Returns whether this entity is visible from the given position."},{"declaration":"string GetTargetname() const","documentation":"Returns this entity's target name."},{"declaration":"string GetClassname() const","documentation":"Returns this entity's class name."},{"declaration":"string TeamID()","documentation":"Returns this entity's team ID."},{"declaration":"bool HasTarget(const string& in szTarget)","documentation":"Returns whether this entity has the given target."},{"declaration":"int GiveAmmo(int iAmount, const string& in szName, int iMax, const bool fFromWeapon = true)","documentation":"Gives ammo to this entity."},{"declaration":"void TraceBleed(float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)","documentation":"Traces entity bleed event."},{"declaration":"void TraceAttack(entvars_t@ pevAttacker, float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)","documentation":"Traces an attack by the given entity to this entity."},{"declaration":"bool KeyValue(const string& in szKeyName, const string& in szValue)","documentation":"Sets keyvalue data on this entity"},{"declaration":"void SetOrigin(const Vector& in vecOrigin)","documentation":"Sets this entity's (absolute) origin"},{"declaration":"const Vector& GetOrigin() const","documentation":"Gets the entity's (absolute) origin."},{"declaration":"CBaseEntity@ opImplCast()","documentation":"Implicitly casts to base type."},{"declaration":"CBaseDelay@ opImplCast()","documentation":"Implicitly casts to base type."},{"declaration":"CBaseAnimating@ opImplCast()","documentation":"Implicitly casts to base type."}],"properties":[{"namespace":"","declaration":"bool m_bExclusiveHold","documentation":"If set, as long as a player has this item, the player must keep this weapon selected.No more than one item with this set can be carried at one time."},{"namespace":"","declaration":"float m_flLastBounce","documentation":"The last bounce time."},{"namespace":"","declaration":"const int m_iId","documentation":"The item id."},{"namespace":"","declaration":"CBasePlayerItem@ m_pNext","documentation":"Gets the next item. null if no next item."},{"namespace":"","declaration":"CBasePlayer@ m_pPlayer","documentation":"The owning player. null if no owner."},{"namespace":"","declaration":"bool m_fSequenceLoops","documentation":"True if the sequence loops."},{"namespace":"","declaration":"bool m_fSequenceFinished","documentation":"Flag set when StudioAdvanceFrame moves across a frame boundry."},{"namespace":"","declaration":"float m_flLastGaitEventCheck","documentation":"Last time the event list was checked."},{"namespace":"","declaration":"float m_flLastEventCheck","documentation":"Last time the event list was checked."},{"namespace":"","declaration":"float m_flGroundSpeed","documentation":"Computed linear movement rate for current sequence."},{"namespace":"","declaration":"float m_flFrameRate","documentation":"Computed FPS for current sequence."},{"namespace":"","declaration":"string_t m_iszKillTarget","documentation":"The name of the kill target, if any."},{"namespace":"","declaration":"float m_flDelay","documentation":"Delay before fire."},{"namespace":"","declaration":"Vector m_vecOriginalRenderColor","documentation":"Original render color."},{"namespace":"","declaration":"float m_flOriginalRenderAmount","documentation":"Original render amount."},{"namespace":"","declaration":"int m_iOriginalRenderFX","documentation":"Original render FX."},{"namespace":"","declaration":"int m_iOriginalRenderMode","documentation":"Original render model."},{"namespace":"","declaration":"string_t classnameInFilterType","documentation":"Class name in filter type."},{"namespace":"","declaration":"string_t targetnameInFilterType","documentation":"Target name in filter type."},{"namespace":"","declaration":"string_t classnameOutFilterType","documentation":"Class name out filter type."},{"namespace":"","declaration":"string_t targetnameOutFilterType","documentation":"Target name out filter type."},{"namespace":"","declaration":"Vector m_vecLastOrigin","documentation":"Last origin vector"},{"namespace":"","declaration":"bool m_fCustomModel","documentation":"Whether a custom model is used."},{"namespace":"","declaration":"bool m_fCanFadeStart","documentation":"Whether fading can start."},{"namespace":"","declaration":"float m_flMaximumFadeWaitB","documentation":"Maximum fade wait time B."},{"namespace":"","declaration":"float m_flMaximumFadeWait","documentation":"Maximum fade wait time."},{"namespace":"","declaration":"int m_iClassSelection","documentation":"The overridden classification."},{"namespace":"","declaration":"bool m_fOverrideClass","documentation":"Whether this entity overrides the classification."},{"namespace":"","declaration":"entvars_t@ pev","documentation":"Entity variables"}],"className":"CBasePlayerItem","documentation":"Player item base class","namespace":""},{"flags":262145,"methods":[{"declaration":"CBaseDoor@ opCast()","documentation":"Explicitly casts to sub type."},{"declaration":"CBaseButton@ opCast()","documentation":"Explicitly casts to sub type."},{"declaration":"CGrenade@ opCast()","documentation":"Explicitly casts to sub type."},{"declaration":"CBasePlayer@ opCast()","documentation":"Explicitly casts to sub type."},{"declaration":"CCineMonster@ opCast()","documentation":"Explicitly casts to sub type."},{"declaration":"CBaseMonster@ opCast()","documentation":"Explicitly casts to sub type."},{"declaration":"InventoryRules@ get_m_pInventoryRules() const","documentation":"The inventory rules."},{"declaration":"bool IsToggleLockedByMaster()","documentation":"Returns whether this entity is locked by its master.<br/>Separate from IsLockedByMaster due to limitations."},{"declaration":"void AngularMove(Vector vecDestAngle, float flSpeed)","documentation":"Performs angular movement."},{"declaration":"void LinearMove(Vector vecDest, float flSpeed)","documentation":"Performs linear movement."},{"declaration":"int GetSequenceActivityName(int iSequence)","documentation":"Sets the sequence box."},{"declaration":"void SetSequenceBox()","documentation":"Sets the sequence box."},{"declaration":"int GetAttachmentCount()","documentation":"Gets the number of attachments that the current model has."},{"declaration":"bool ExtractBbox(int iSequence, Vector& out mins, Vector& out maxs)","documentation":"Extracts the bounding box of the current model."},{"declaration":"int GetBodygroup(int iGroup)","documentation":"Gets the value of the given body group."},{"declaration":"void SetBodygroup(int iGroup, int iValue)","documentation":"Sets the given body group to the given value."},{"declaration":"void GetAttachment(int iAttachment, Vector& out origin, Vector& out angles)","documentation":"Gets the attachment position."},{"declaration":"int FindTransition(int iEndingSequence, int iGoalSequence)","documentation":"Find the transition between 2 sequences."},{"declaration":"int FindTransition(int iEndingSequence, int iGoalSequence, int& out iDir)","documentation":"Find the transition between 2 sequences."},{"declaration":"void GetAutomovement(Vector& out origin, Vector& out angles, float flInterval = 0.1f)","documentation":"Gets automatic movement."},{"declaration":"void GetBonePosition(int iBone, Vector& out origin, Vector& out angles)","documentation":"Gets the position of the given bone."},{"declaration":"float SetBlending(int iBlender, float flValue)","documentation":"Sets the given blending controller to the given value."},{"declaration":"void InitBoneControllers()","documentation":"Initializes bone controllers."},{"declaration":"float SetBoneController(int iController, float flValue)","documentation":"Sets the specified bone controller to the given value."},{"declaration":"void DispatchAnimEvents(float flFutureInterval = 0.1f)","documentation":"Handle events that have happend since last time called up until X seconds into the future."},{"declaration":"void ResetGaitSequenceInfo()","documentation":"Resets gait sequence info."},{"declaration":"void ResetSequenceInfo()","documentation":"Resets sequence info."},{"declaration":"int LookupSequence(const string& in szLabel)","documentation":"Returns the index of the given sequence, or -1 if no such sequence exists."},{"declaration":"int LookupActivityHeaviest(int iActivity)","documentation":"Returns the index of the given activity that has the heaviest weight, or -1 if no such activity exists."},{"declaration":"int LookupActivity(int iActivity)","documentation":"Returns the index of the given activity, or -1 if no such activity exists."},{"declaration":"int GetSequenceFlags()","documentation":"Get sequence flags."},{"declaration":"float StudioFrameAdvance(float flInterval = 0.0f)","documentation":"Accumulate animation frame time from last time called until now."},{"declaration":"void DelayThink()","documentation":"Think function. Used internally."},{"declaration":"void SUB_UseTargets(CBaseEntity@ pActivator, USE_TYPE useType, float flValue)","documentation":"Causes this entity to trigger its targets with an optional delay."},{"declaration":"void ClearUserData()","documentation":"Clears the user data on this entity. WARNING: clears all data.<br/>Only map scripts can use this."},{"declaration":"dictionaryValue& GetUserData(const string& in szKey)","documentation":"Gets the user data stored under the specified key on this entity.<br/>Do not keep references to this data, the object might be removed from this entity.<br/>Only map scripts can use this."},{"declaration":"dictionary@ GetUserData()","documentation":"Gets the user data on this entity. Do not keep references to this data, the object might be removed from this entity.<br/>Only map scripts can use this."},{"declaration":"void EndRevive(float flTimeUntilRevive)","documentation":"Called when this entity should be revived. flTimeUntilRevive is the time until the revival should start."},{"declaration":"void BeginRevive(float flTimeUntilRevive)","documentation":"Prepares this entity for revival. flTimeUntilRevive is the time until the revive action completes."},{"declaration":"bool IsRevivable()","documentation":"Returns whether this entity is revivable at this time."},{"declaration":"void OnDestroy()","documentation":"Entity destructor."},{"declaration":"void OnCreate()","documentation":"Entity constructor."},{"declaration":"void GetDamagePoints(entvars_t@ pevAttacker, entvars_t@ pevInflictor, float flDamage)","documentation":"Adds damage points to the inflicting entity."},{"declaration":"float GetPointsForDamage(float flDamage)","documentation":"Returns the points received for damage done."},{"declaration":"bool IsFacing(entvars_t@ pevTest, float flDotProduct = VIEW_FIELD_ULTRA_NARROW)","documentation":"Returns whether this entity is facing the given entity, within the given view field."},{"declaration":"bool FVisible(const Vector& in vecOrigin)","documentation":"Returns whether this entity is visible from the given origin."},{"declaration":"bool FVisible(CBaseEntity@ pEntity, bool fIgnoreGlass)","documentation":"Returns whether this entity is visible to the given entity."},{"declaration":"int Illumination()","documentation":"Returns this entity's illumination."},{"declaration":"Vector BodyTarget(const Vector& in posSrc)","documentation":"Returns this entity's body target for shooting."},{"declaration":"Vector EarPosition()","documentation":"Returns this entity's ear position."},{"declaration":"Vector EyePosition()","documentation":"Returns this entity's eye position."},{"declaration":"Vector Center()","documentation":"Returns this entity's center."},{"declaration":"bool FBecomeProne()","documentation":"Makes this entity become prone."},{"declaration":"CBaseEntity@ Respawn()","documentation":"Respawns this entity."},{"declaration":"void UpdateOnRemove()","documentation":"Updates this entity when removed."},{"declaration":"void Blocked(CBaseEntity@ pOther)","documentation":"Triggers this entity's blocked function."},{"declaration":"void Use(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f)","documentation":"Trigger's this entity's use function."},{"declaration":"void Touch(CBaseEntity@ pOther)","documentation":"Triggers this entity's touch function."},{"declaration":"void Think()","documentation":"Makes this entity think. Do not call directly."},{"declaration":"CBaseEntity@ GetNextTarget()","documentation":"Gets the next target to trigger."},{"declaration":"bool CriticalRemove()","documentation":"Removes this entity in critical situations."},{"declaration":"bool IsMachine()","documentation":"Returns whether this is a machine."},{"declaration":"bool IsPointEnt()","documentation":"Returns whether this is a point entity."},{"declaration":"bool IsNetClient()","documentation":"Returns whether this is a net client."},{"declaration":"bool IsPlayer()","documentation":"Returns whether this entity is a player."},{"declaration":"bool IsMonster()","documentation":"Returns whether this entity is a monster."},{"declaration":"bool IsInWorld()","documentation":"Returns whether this entity is in the world."},{"declaration":"bool ReflectGauss()","documentation":"Returns whether this entity reflects gauss shots."},{"declaration":"bool IsBSPModel()","documentation":"Returns whether this entity is a BSP model."},{"declaration":"bool IsAlive()","documentation":"Returns whether this entity is alive."},{"declaration":"bool IsSneaking()","documentation":"Returns whether this entity is sneaking."},{"declaration":"bool OnControls(entvars_t@ pev)","documentation":"Reacts to controls set on the pev."},{"declaration":"void StopSneaking()","documentation":"Stops sneaking."},{"declaration":"void StartSneaking()","documentation":"Starts sneaking."},{"declaration":"void SetToggleState(int state)","documentation":"Sets this entity's toggle state."},{"declaration":"int DamageDecal(int bitsDamageType)","documentation":"Returns the damage decal<br/>See decal_e."},{"declaration":"void OverrideReset()","documentation":"Resets this entity."},{"declaration":"bool IsMoving()","documentation":"Returns whether this entity is moving."},{"declaration":"float GetDelay()","documentation":"Gets this entity's trigger delay."},{"declaration":"bool RemovePlayerItem(CBasePlayerItem@ pItem)","documentation":"Removes the given player item to this entity."},{"declaration":"AddPlayerItemResult AddPlayerItem(CBasePlayerItem@ pItem)","documentation":"Adds the given player item to this entity."},{"declaration":"void AddPointsToTeam(int score, const bool bAllowNegativeScore)","documentation":"Adds points to this entity's team."},{"declaration":"void AddPoints(int score, const bool bAllowNegativeScore)","documentation":"Adds points to this entity."},{"declaration":"int GetToggleState()","documentation":"Gets the toggle state.<br/>See the TOGGLE_STATE enum."},{"declaration":"bool SetupModel()","documentation":"Sets up the model."},{"declaration":"int entindex()","documentation":"Returns this entity's index."},{"declaration":"edict_t@ edict()","documentation":"Returns this entity's edict."},{"declaration":"bool IsLockedByMaster()","documentation":"Returns whether this entity is locked by its master."},{"declaration":"bool IsDormant()","documentation":"Returns whether this entity is dormant."},{"declaration":"void MakeDormant()","documentation":"Makes this entity dormant."},{"declaration":"bool Intersects(CBaseEntity@ pOther)","documentation":"Returns whether this entity intersects with the given entity."},{"declaration":"void FireBullets(uint cShots, Vector vecSrc, Vector vecDirShooting, Vector vecSpread,float flDistance, Bullet iBulletType, int iTracerFreq = 4, int iDamage = 0, entvars_t@ pevAttacker = null, FireBulletsDrawMode fDraw = FBDM_DRAW)","documentation":"Fires bullets. Must call CMath::MakeAimVectors with an angle vector first."},{"declaration":"bool ShouldToggle(USE_TYPE useType, const bool currentState)","documentation":"Returns whether this entity should toggle."},{"declaration":"void SUB_CallUseToggle()","documentation":"Think function. Calls use toggle on this entity."},{"declaration":"void SUB_FadeOut()","documentation":"Think function. Fades this entity."},{"declaration":"void SUB_StartFadeOut()","documentation":"Think function. Starts fading this entity."},{"declaration":"void SUB_DoNothing()","documentation":"Think function. Explicitly does nothing."},{"declaration":"void SUB_Remove()","documentation":"Think function. Delay-removes this entity."},{"declaration":"bool BlockedByEntity(CBaseEntity@ pOther, float flDamage)","documentation":"Returns true if you should be blocked by the entity, false otherwise. Also deals blocking damage to the entity, if applicable."},{"declaration":"CustomKeyvalues@ GetCustomKeyvalues()","documentation":"Gets this entity's custom keyvalues."},{"declaration":"CBaseMonster@ MyMonsterPointer()","documentation":"Returns this entity as its monster entity, if it is a monster."},{"declaration":"bool IsTriggered(CBaseEntity@ pActivator)","documentation":"Returns whether this entity is triggered by the given entity."},{"declaration":"int BloodColor()","documentation":"Returns the blood color. See the BLOOD_COLOR enum."},{"declaration":"void Killed(entvars_t@pevAtttacker, int iGibbed)","documentation":"Tells this entity it's been killed. See the GIB enum for possible values."},{"declaration":"bool TakeArmor(float flArmor, int bitsDamageType, int armor_cap = 0)","documentation":"Takes armor from this entity. Note: flArmor is added to entity armor. Use negative values to subtract.If armor_cap is non-zero, won't add more than armor_cap. Returns 1 if it took damage, 0 otherwise."},{"declaration":"bool TakeHealth(float flHealth, int bitsDamageType, int health_cap = 0)","documentation":"Takes health from this entity. Note: flHealth is added to entity health. Use negative values to subtract.If health_cap is non-zero, won't add more than health_cap. Returns true if it took damage, false otherwise."},{"declaration":"int TakeDamage(entvars_t@ pevInflictor, entvars_t@ pevAttacker, float flDamage, int bitsDamageType)","documentation":"Causes this entity to take damage. Returns 1 if it took damage, 0 otherwise."},{"declaration":"int Classify()","documentation":"Gets this entity's classification."},{"declaration":"int IRelationshipByClass(CLASS iClass)","documentation":"Gets the relationship between this entity and the given entity classification. See the RELATIONSHIP enum."},{"declaration":"int IRelationship(CBaseEntity@ other)","documentation":"Gets the relationship between this entity and the given entity. See the RELATIONSHIP enum."},{"declaration":"void ClearClassification()","documentation":"Clears this entity's classification override."},{"declaration":"void SetClassificationFromEntity(CBaseEntity@ pEntity)","documentation":"Sets this entity's classification override to the classification override set on the given entity. Can override the entity's player ally setting."},{"declaration":"void SetClassification(int cl)","documentation":"Sets this entity's classification override. Can override the entity's player ally setting."},{"declaration":"int GetClassification(int cl)","documentation":"Gets this entity's classification. Returns the given value if none is set. See the CLASSIFICATION enum."},{"declaration":"void SetObjectCollisionBox()","documentation":"Sets up the object collision box."},{"declaration":"int ObjectCaps()","documentation":"Gets this entity's objects caps. See the FCAP enum."},{"declaration":"void Precache()","documentation":"Precaches the entity. Do not call directly."},{"declaration":"bool opEquals(CBaseEntity@ pOther)","documentation":"Compares 2 entities for equality."},{"declaration":"void SetPlayerAllyDirect(bool fState)","documentation":"Sets this entity's player ally status.</br>Use this only if you need the setting to be exactly what you give it (e.g. when copying from another monster)"},{"declaration":"void SetPlayerAlly(bool fState)","documentation":"Sets this entity's player ally status."},{"declaration":"bool IsPlayerAlly() const","documentation":"Returns whether this entity is allied to players."},{"declaration":"int FindMonstersInWorld(array<CBaseEntity@>@ pArray, int flagMask)","documentation":"Finds monsters in the world"},{"declaration":"string SOUNDREPLACEMENT_Find(const string& in szFilename)","documentation":"Find sound replacement for the given file."},{"declaration":"bool FVisibleFromPos(const Vector& in vecTarget, const Vector& in vecStart)","documentation":"Returns whether this entity is visible from the given position."},{"declaration":"string GetTargetname() const","documentation":"Returns this entity's target name."},{"declaration":"string GetClassname() const","documentation":"Returns this entity's class name."},{"declaration":"string TeamID()","documentation":"Returns this entity's team ID."},{"declaration":"bool HasTarget(const string& in szTarget)","documentation":"Returns whether this entity has the given target."},{"declaration":"int GiveAmmo(int iAmount, const string& in szName, int iMax, const bool fFromWeapon = true)","documentation":"Gives ammo to this entity."},{"declaration":"void TraceBleed(float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)","documentation":"Traces entity bleed event."},{"declaration":"void TraceAttack(entvars_t@ pevAttacker, float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)","documentation":"Traces an attack by the given entity to this entity."},{"declaration":"bool KeyValue(const string& in szKeyName, const string& in szValue)","documentation":"Sets keyvalue data on this entity"},{"declaration":"void SetOrigin(const Vector& in vecOrigin)","documentation":"Sets this entity's (absolute) origin"},{"declaration":"const Vector& GetOrigin() const","documentation":"Gets the entity's (absolute) origin."},{"declaration":"CBaseEntity@ opImplCast()","documentation":"Implicitly casts to base type."},{"declaration":"CBaseDelay@ opImplCast()","documentation":"Implicitly casts to base type."},{"declaration":"CBaseAnimating@ opImplCast()","documentation":"Implicitly casts to base type."}],"properties":[{"namespace":"","declaration":"string_t m_sMaster","documentation":"This entity's master, if any."},{"namespace":"","declaration":"int m_bitsDamageInflict","documentation":"DMG_ damage type that the door or trigger does."},{"namespace":"","declaration":"Vector m_vecFinalAngle","documentation":"Final angle."},{"namespace":"","declaration":"Vector m_vecFinalDest","documentation":"Final destination."},{"namespace":"","declaration":"Vector m_vecAngle2","documentation":"Open angle."},{"namespace":"","declaration":"Vector m_vecAngle1","documentation":"Closed angle."},{"namespace":"","declaration":"Vector m_vecPosition2","documentation":"Open position."},{"namespace":"","declaration":"Vector m_vecPosition1","documentation":"Closed position."},{"namespace":"","declaration":"EHandle m_hActivator","documentation":"Handle to the activator."},{"namespace":"","declaration":"float m_flHeight","documentation":"Height."},{"namespace":"","declaration":"int m_cTriggersLeft","documentation":"Trigger_counter only: # of activations remaining."},{"namespace":"","declaration":"float m_flTLength","documentation":"For plats."},{"namespace":"","declaration":"float m_flTWidth","documentation":"For plats."},{"namespace":"","declaration":"float m_flLip","documentation":"How much to stick out of a wall. Will recede further into walls if negative."},{"namespace":"","declaration":"float m_flWait","documentation":"How long to wait before resetting."},{"namespace":"","declaration":"float m_flMoveDistance","documentation":"How far a door should slide or rotate."},{"namespace":"","declaration":"TOGGLE_STATE m_toggle_state","documentation":"Current toggle state."},{"namespace":"","declaration":"bool m_fSequenceLoops","documentation":"True if the sequence loops."},{"namespace":"","declaration":"bool m_fSequenceFinished","documentation":"Flag set when StudioAdvanceFrame moves across a frame boundry."},{"namespace":"","declaration":"float m_flLastGaitEventCheck","documentation":"Last time the event list was checked."},{"namespace":"","declaration":"float m_flLastEventCheck","documentation":"Last time the event list was checked."},{"namespace":"","declaration":"float m_flGroundSpeed","documentation":"Computed linear movement rate for current sequence."},{"namespace":"","declaration":"float m_flFrameRate","documentation":"Computed FPS for current sequence."},{"namespace":"","declaration":"string_t m_iszKillTarget","documentation":"The name of the kill target, if any."},{"namespace":"","declaration":"float m_flDelay","documentation":"Delay before fire."},{"namespace":"","declaration":"Vector m_vecOriginalRenderColor","documentation":"Original render color."},{"namespace":"","declaration":"float m_flOriginalRenderAmount","documentation":"Original render amount."},{"namespace":"","declaration":"int m_iOriginalRenderFX","documentation":"Original render FX."},{"namespace":"","declaration":"int m_iOriginalRenderMode","documentation":"Original render model."},{"namespace":"","declaration":"string_t classnameInFilterType","documentation":"Class name in filter type."},{"namespace":"","declaration":"string_t targetnameInFilterType","documentation":"Target name in filter type."},{"namespace":"","declaration":"string_t classnameOutFilterType","documentation":"Class name out filter type."},{"namespace":"","declaration":"string_t targetnameOutFilterType","documentation":"Target name out filter type."},{"namespace":"","declaration":"Vector m_vecLastOrigin","documentation":"Last origin vector"},{"namespace":"","declaration":"bool m_fCustomModel","documentation":"Whether a custom model is used."},{"namespace":"","declaration":"bool m_fCanFadeStart","documentation":"Whether fading can start."},{"namespace":"","declaration":"float m_flMaximumFadeWaitB","documentation":"Maximum fade wait time B."},{"namespace":"","declaration":"float m_flMaximumFadeWait","documentation":"Maximum fade wait time."},{"namespace":"","declaration":"int m_iClassSelection","documentation":"The overridden classification."},{"namespace":"","declaration":"bool m_fOverrideClass","documentation":"Whether this entity overrides the classification."},{"namespace":"","declaration":"entvars_t@ pev","documentation":"Entity variables"}],"className":"CBaseToggle","documentation":"All entities that can be toggled derive from this","namespace":""},{"flags":262145,"methods":[{"declaration":"CBaseDoor@ opCast()","documentation":"Explicitly casts to sub type."},{"declaration":"CBaseButton@ opCast()","documentation":"Explicitly casts to sub type."},{"declaration":"CBasePlayerWeapon@ opCast()","documentation":"Explicitly casts to sub type."},{"declaration":"CGrenade@ opCast()","documentation":"Explicitly casts to sub type."},{"declaration":"CBasePlayer@ opCast()","documentation":"Explicitly casts to sub type."},{"declaration":"CCineMonster@ opCast()","documentation":"Explicitly casts to sub type."},{"declaration":"CBaseMonster@ opCast()","documentation":"Explicitly casts to sub type."},{"declaration":"CBasePlayerItem@ opCast()","documentation":"Explicitly casts to sub type."},{"declaration":"CBaseToggle@ opCast()","documentation":"Explicitly casts to sub type."},{"declaration":"int GetSequenceActivityName(int iSequence)","documentation":"Sets the sequence box."},{"declaration":"void SetSequenceBox()","documentation":"Sets the sequence box."},{"declaration":"int GetAttachmentCount()","documentation":"Gets the number of attachments that the current model has."},{"declaration":"bool ExtractBbox(int iSequence, Vector& out mins, Vector& out maxs)","documentation":"Extracts the bounding box of the current model."},{"declaration":"int GetBodygroup(int iGroup)","documentation":"Gets the value of the given body group."},{"declaration":"void SetBodygroup(int iGroup, int iValue)","documentation":"Sets the given body group to the given value."},{"declaration":"void GetAttachment(int iAttachment, Vector& out origin, Vector& out angles)","documentation":"Gets the attachment position."},{"declaration":"int FindTransition(int iEndingSequence, int iGoalSequence)","documentation":"Find the transition between 2 sequences."},{"declaration":"int FindTransition(int iEndingSequence, int iGoalSequence, int& out iDir)","documentation":"Find the transition between 2 sequences."},{"declaration":"void GetAutomovement(Vector& out origin, Vector& out angles, float flInterval = 0.1f)","documentation":"Gets automatic movement."},{"declaration":"void GetBonePosition(int iBone, Vector& out origin, Vector& out angles)","documentation":"Gets the position of the given bone."},{"declaration":"float SetBlending(int iBlender, float flValue)","documentation":"Sets the given blending controller to the given value."},{"declaration":"void InitBoneControllers()","documentation":"Initializes bone controllers."},{"declaration":"float SetBoneController(int iController, float flValue)","documentation":"Sets the specified bone controller to the given value."},{"declaration":"void DispatchAnimEvents(float flFutureInterval = 0.1f)","documentation":"Handle events that have happend since last time called up until X seconds into the future."},{"declaration":"void ResetGaitSequenceInfo()","documentation":"Resets gait sequence info."},{"declaration":"void ResetSequenceInfo()","documentation":"Resets sequence info."},{"declaration":"int LookupSequence(const string& in szLabel)","documentation":"Returns the index of the given sequence, or -1 if no such sequence exists."},{"declaration":"int LookupActivityHeaviest(int iActivity)","documentation":"Returns the index of the given activity that has the heaviest weight, or -1 if no such activity exists."},{"declaration":"int LookupActivity(int iActivity)","documentation":"Returns the index of the given activity, or -1 if no such activity exists."},{"declaration":"int GetSequenceFlags()","documentation":"Get sequence flags."},{"declaration":"float StudioFrameAdvance(float flInterval = 0.0f)","documentation":"Accumulate animation frame time from last time called until now."},{"declaration":"void DelayThink()","documentation":"Think function. Used internally."},{"declaration":"void SUB_UseTargets(CBaseEntity@ pActivator, USE_TYPE useType, float flValue)","documentation":"Causes this entity to trigger its targets with an optional delay."},{"declaration":"void ClearUserData()","documentation":"Clears the user data on this entity. WARNING: clears all data.<br/>Only map scripts can use this."},{"declaration":"dictionaryValue& GetUserData(const string& in szKey)","documentation":"Gets the user data stored under the specified key on this entity.<br/>Do not keep references to this data, the object might be removed from this entity.<br/>Only map scripts can use this."},{"declaration":"dictionary@ GetUserData()","documentation":"Gets the user data on this entity. Do not keep references to this data, the object might be removed from this entity.<br/>Only map scripts can use this."},{"declaration":"void EndRevive(float flTimeUntilRevive)","documentation":"Called when this entity should be revived. flTimeUntilRevive is the time until the revival should start."},{"declaration":"void BeginRevive(float flTimeUntilRevive)","documentation":"Prepares this entity for revival. flTimeUntilRevive is the time until the revive action completes."},{"declaration":"bool IsRevivable()","documentation":"Returns whether this entity is revivable at this time."},{"declaration":"void OnDestroy()","documentation":"Entity destructor."},{"declaration":"void OnCreate()","documentation":"Entity constructor."},{"declaration":"void GetDamagePoints(entvars_t@ pevAttacker, entvars_t@ pevInflictor, float flDamage)","documentation":"Adds damage points to the inflicting entity."},{"declaration":"float GetPointsForDamage(float flDamage)","documentation":"Returns the points received for damage done."},{"declaration":"bool IsFacing(entvars_t@ pevTest, float flDotProduct = VIEW_FIELD_ULTRA_NARROW)","documentation":"Returns whether this entity is facing the given entity, within the given view field."},{"declaration":"bool FVisible(const Vector& in vecOrigin)","documentation":"Returns whether this entity is visible from the given origin."},{"declaration":"bool FVisible(CBaseEntity@ pEntity, bool fIgnoreGlass)","documentation":"Returns whether this entity is visible to the given entity."},{"declaration":"int Illumination()","documentation":"Returns this entity's illumination."},{"declaration":"Vector BodyTarget(const Vector& in posSrc)","documentation":"Returns this entity's body target for shooting."},{"declaration":"Vector EarPosition()","documentation":"Returns this entity's ear position."},{"declaration":"Vector EyePosition()","documentation":"Returns this entity's eye position."},{"declaration":"Vector Center()","documentation":"Returns this entity's center."},{"declaration":"bool FBecomeProne()","documentation":"Makes this entity become prone."},{"declaration":"CBaseEntity@ Respawn()","documentation":"Respawns this entity."},{"declaration":"void UpdateOnRemove()","documentation":"Updates this entity when removed."},{"declaration":"void Blocked(CBaseEntity@ pOther)","documentation":"Triggers this entity's blocked function."},{"declaration":"void Use(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f)","documentation":"Trigger's this entity's use function."},{"declaration":"void Touch(CBaseEntity@ pOther)","documentation":"Triggers this entity's touch function."},{"declaration":"void Think()","documentation":"Makes this entity think. Do not call directly."},{"declaration":"CBaseEntity@ GetNextTarget()","documentation":"Gets the next target to trigger."},{"declaration":"bool CriticalRemove()","documentation":"Removes this entity in critical situations."},{"declaration":"bool IsMachine()","documentation":"Returns whether this is a machine."},{"declaration":"bool IsPointEnt()","documentation":"Returns whether this is a point entity."},{"declaration":"bool IsNetClient()","documentation":"Returns whether this is a net client."},{"declaration":"bool IsPlayer()","documentation":"Returns whether this entity is a player."},{"declaration":"bool IsMonster()","documentation":"Returns whether this entity is a monster."},{"declaration":"bool IsInWorld()","documentation":"Returns whether this entity is in the world."},{"declaration":"bool ReflectGauss()","documentation":"Returns whether this entity reflects gauss shots."},{"declaration":"bool IsBSPModel()","documentation":"Returns whether this entity is a BSP model."},{"declaration":"bool IsAlive()","documentation":"Returns whether this entity is alive."},{"declaration":"bool IsSneaking()","documentation":"Returns whether this entity is sneaking."},{"declaration":"bool OnControls(entvars_t@ pev)","documentation":"Reacts to controls set on the pev."},{"declaration":"void StopSneaking()","documentation":"Stops sneaking."},{"declaration":"void StartSneaking()","documentation":"Starts sneaking."},{"declaration":"void SetToggleState(int state)","documentation":"Sets this entity's toggle state."},{"declaration":"int DamageDecal(int bitsDamageType)","documentation":"Returns the damage decal<br/>See decal_e."},{"declaration":"void OverrideReset()","documentation":"Resets this entity."},{"declaration":"bool IsMoving()","documentation":"Returns whether this entity is moving."},{"declaration":"float GetDelay()","documentation":"Gets this entity's trigger delay."},{"declaration":"bool RemovePlayerItem(CBasePlayerItem@ pItem)","documentation":"Removes the given player item to this entity."},{"declaration":"AddPlayerItemResult AddPlayerItem(CBasePlayerItem@ pItem)","documentation":"Adds the given player item to this entity."},{"declaration":"void AddPointsToTeam(int score, const bool bAllowNegativeScore)","documentation":"Adds points to this entity's team."},{"declaration":"void AddPoints(int score, const bool bAllowNegativeScore)","documentation":"Adds points to this entity."},{"declaration":"int GetToggleState()","documentation":"Gets the toggle state.<br/>See the TOGGLE_STATE enum."},{"declaration":"bool SetupModel()","documentation":"Sets up the model."},{"declaration":"int entindex()","documentation":"Returns this entity's index."},{"declaration":"edict_t@ edict()","documentation":"Returns this entity's edict."},{"declaration":"bool IsLockedByMaster()","documentation":"Returns whether this entity is locked by its master."},{"declaration":"bool IsDormant()","documentation":"Returns whether this entity is dormant."},{"declaration":"void MakeDormant()","documentation":"Makes this entity dormant."},{"declaration":"bool Intersects(CBaseEntity@ pOther)","documentation":"Returns whether this entity intersects with the given entity."},{"declaration":"void FireBullets(uint cShots, Vector vecSrc, Vector vecDirShooting, Vector vecSpread,float flDistance, Bullet iBulletType, int iTracerFreq = 4, int iDamage = 0, entvars_t@ pevAttacker = null, FireBulletsDrawMode fDraw = FBDM_DRAW)","documentation":"Fires bullets. Must call CMath::MakeAimVectors with an angle vector first."},{"declaration":"bool ShouldToggle(USE_TYPE useType, const bool currentState)","documentation":"Returns whether this entity should toggle."},{"declaration":"void SUB_CallUseToggle()","documentation":"Think function. Calls use toggle on this entity."},{"declaration":"void SUB_FadeOut()","documentation":"Think function. Fades this entity."},{"declaration":"void SUB_StartFadeOut()","documentation":"Think function. Starts fading this entity."},{"declaration":"void SUB_DoNothing()","documentation":"Think function. Explicitly does nothing."},{"declaration":"void SUB_Remove()","documentation":"Think function. Delay-removes this entity."},{"declaration":"bool BlockedByEntity(CBaseEntity@ pOther, float flDamage)","documentation":"Returns true if you should be blocked by the entity, false otherwise. Also deals blocking damage to the entity, if applicable."},{"declaration":"CustomKeyvalues@ GetCustomKeyvalues()","documentation":"Gets this entity's custom keyvalues."},{"declaration":"CBaseMonster@ MyMonsterPointer()","documentation":"Returns this entity as its monster entity, if it is a monster."},{"declaration":"bool IsTriggered(CBaseEntity@ pActivator)","documentation":"Returns whether this entity is triggered by the given entity."},{"declaration":"int BloodColor()","documentation":"Returns the blood color. See the BLOOD_COLOR enum."},{"declaration":"void Killed(entvars_t@pevAtttacker, int iGibbed)","documentation":"Tells this entity it's been killed. See the GIB enum for possible values."},{"declaration":"bool TakeArmor(float flArmor, int bitsDamageType, int armor_cap = 0)","documentation":"Takes armor from this entity. Note: flArmor is added to entity armor. Use negative values to subtract.If armor_cap is non-zero, won't add more than armor_cap. Returns 1 if it took damage, 0 otherwise."},{"declaration":"bool TakeHealth(float flHealth, int bitsDamageType, int health_cap = 0)","documentation":"Takes health from this entity. Note: flHealth is added to entity health. Use negative values to subtract.If health_cap is non-zero, won't add more than health_cap. Returns true if it took damage, false otherwise."},{"declaration":"int TakeDamage(entvars_t@ pevInflictor, entvars_t@ pevAttacker, float flDamage, int bitsDamageType)","documentation":"Causes this entity to take damage. Returns 1 if it took damage, 0 otherwise."},{"declaration":"int Classify()","documentation":"Gets this entity's classification."},{"declaration":"int IRelationshipByClass(CLASS iClass)","documentation":"Gets the relationship between this entity and the given entity classification. See the RELATIONSHIP enum."},{"declaration":"int IRelationship(CBaseEntity@ other)","documentation":"Gets the relationship between this entity and the given entity. See the RELATIONSHIP enum."},{"declaration":"void ClearClassification()","documentation":"Clears this entity's classification override."},{"declaration":"void SetClassificationFromEntity(CBaseEntity@ pEntity)","documentation":"Sets this entity's classification override to the classification override set on the given entity. Can override the entity's player ally setting."},{"declaration":"void SetClassification(int cl)","documentation":"Sets this entity's classification override. Can override the entity's player ally setting."},{"declaration":"int GetClassification(int cl)","documentation":"Gets this entity's classification. Returns the given value if none is set. See the CLASSIFICATION enum."},{"declaration":"void SetObjectCollisionBox()","documentation":"Sets up the object collision box."},{"declaration":"int ObjectCaps()","documentation":"Gets this entity's objects caps. See the FCAP enum."},{"declaration":"void Precache()","documentation":"Precaches the entity. Do not call directly."},{"declaration":"bool opEquals(CBaseEntity@ pOther)","documentation":"Compares 2 entities for equality."},{"declaration":"void SetPlayerAllyDirect(bool fState)","documentation":"Sets this entity's player ally status.</br>Use this only if you need the setting to be exactly what you give it (e.g. when copying from another monster)"},{"declaration":"void SetPlayerAlly(bool fState)","documentation":"Sets this entity's player ally status."},{"declaration":"bool IsPlayerAlly() const","documentation":"Returns whether this entity is allied to players."},{"declaration":"int FindMonstersInWorld(array<CBaseEntity@>@ pArray, int flagMask)","documentation":"Finds monsters in the world"},{"declaration":"string SOUNDREPLACEMENT_Find(const string& in szFilename)","documentation":"Find sound replacement for the given file."},{"declaration":"bool FVisibleFromPos(const Vector& in vecTarget, const Vector& in vecStart)","documentation":"Returns whether this entity is visible from the given position."},{"declaration":"string GetTargetname() const","documentation":"Returns this entity's target name."},{"declaration":"string GetClassname() const","documentation":"Returns this entity's class name."},{"declaration":"string TeamID()","documentation":"Returns this entity's team ID."},{"declaration":"bool HasTarget(const string& in szTarget)","documentation":"Returns whether this entity has the given target."},{"declaration":"int GiveAmmo(int iAmount, const string& in szName, int iMax, const bool fFromWeapon = true)","documentation":"Gives ammo to this entity."},{"declaration":"void TraceBleed(float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)","documentation":"Traces entity bleed event."},{"declaration":"void TraceAttack(entvars_t@ pevAttacker, float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)","documentation":"Traces an attack by the given entity to this entity."},{"declaration":"bool KeyValue(const string& in szKeyName, const string& in szValue)","documentation":"Sets keyvalue data on this entity"},{"declaration":"void SetOrigin(const Vector& in vecOrigin)","documentation":"Sets this entity's (absolute) origin"},{"declaration":"const Vector& GetOrigin() const","documentation":"Gets the entity's (absolute) origin."},{"declaration":"CBaseEntity@ opImplCast()","documentation":"Implicitly casts to base type."},{"declaration":"CBaseDelay@ opImplCast()","documentation":"Implicitly casts to base type."}],"properties":[{"namespace":"","declaration":"bool m_fSequenceLoops","documentation":"True if the sequence loops."},{"namespace":"","declaration":"bool m_fSequenceFinished","documentation":"Flag set when StudioAdvanceFrame moves across a frame boundry."},{"namespace":"","declaration":"float m_flLastGaitEventCheck","documentation":"Last time the event list was checked."},{"namespace":"","declaration":"float m_flLastEventCheck","documentation":"Last time the event list was checked."},{"namespace":"","declaration":"float m_flGroundSpeed","documentation":"Computed linear movement rate for current sequence."},{"namespace":"","declaration":"float m_flFrameRate","documentation":"Computed FPS for current sequence."},{"namespace":"","declaration":"string_t m_iszKillTarget","documentation":"The name of the kill target, if any."},{"namespace":"","declaration":"float m_flDelay","documentation":"Delay before fire."},{"namespace":"","declaration":"Vector m_vecOriginalRenderColor","documentation":"Original render color."},{"namespace":"","declaration":"float m_flOriginalRenderAmount","documentation":"Original render amount."},{"namespace":"","declaration":"int m_iOriginalRenderFX","documentation":"Original render FX."},{"namespace":"","declaration":"int m_iOriginalRenderMode","documentation":"Original render model."},{"namespace":"","declaration":"string_t classnameInFilterType","documentation":"Class name in filter type."},{"namespace":"","declaration":"string_t targetnameInFilterType","documentation":"Target name in filter type."},{"namespace":"","declaration":"string_t classnameOutFilterType","documentation":"Class name out filter type."},{"namespace":"","declaration":"string_t targetnameOutFilterType","documentation":"Target name out filter type."},{"namespace":"","declaration":"Vector m_vecLastOrigin","documentation":"Last origin vector"},{"namespace":"","declaration":"bool m_fCustomModel","documentation":"Whether a custom model is used."},{"namespace":"","declaration":"bool m_fCanFadeStart","documentation":"Whether fading can start."},{"namespace":"","declaration":"float m_flMaximumFadeWaitB","documentation":"Maximum fade wait time B."},{"namespace":"","declaration":"float m_flMaximumFadeWait","documentation":"Maximum fade wait time."},{"namespace":"","declaration":"int m_iClassSelection","documentation":"The overridden classification."},{"namespace":"","declaration":"bool m_fOverrideClass","documentation":"Whether this entity overrides the classification."},{"namespace":"","declaration":"entvars_t@ pev","documentation":"Entity variables"}],"className":"CBaseAnimating","documentation":"All entities that can animate derive from this","namespace":""},{"flags":262145,"methods":[{"declaration":"CBaseDoor@ opCast()","documentation":"Explicitly casts to sub type."},{"declaration":"CBaseButton@ opCast()","documentation":"Explicitly casts to sub type."},{"declaration":"CBasePlayerWeapon@ opCast()","documentation":"Explicitly casts to sub type."},{"declaration":"CGrenade@ opCast()","documentation":"Explicitly casts to sub type."},{"declaration":"CBasePlayer@ opCast()","documentation":"Explicitly casts to sub type."},{"declaration":"CCineMonster@ opCast()","documentation":"Explicitly casts to sub type."},{"declaration":"CBaseMonster@ opCast()","documentation":"Explicitly casts to sub type."},{"declaration":"CBasePlayerItem@ opCast()","documentation":"Explicitly casts to sub type."},{"declaration":"CBaseToggle@ opCast()","documentation":"Explicitly casts to sub type."},{"declaration":"CBaseAnimating@ opCast()","documentation":"Explicitly casts to sub type."},{"declaration":"void DelayThink()","documentation":"Think function. Used internally."},{"declaration":"void SUB_UseTargets(CBaseEntity@ pActivator, USE_TYPE useType, float flValue)","documentation":"Causes this entity to trigger its targets with an optional delay."},{"declaration":"void ClearUserData()","documentation":"Clears the user data on this entity. WARNING: clears all data.<br/>Only map scripts can use this."},{"declaration":"dictionaryValue& GetUserData(const string& in szKey)","documentation":"Gets the user data stored under the specified key on this entity.<br/>Do not keep references to this data, the object might be removed from this entity.<br/>Only map scripts can use this."},{"declaration":"dictionary@ GetUserData()","documentation":"Gets the user data on this entity. Do not keep references to this data, the object might be removed from this entity.<br/>Only map scripts can use this."},{"declaration":"void EndRevive(float flTimeUntilRevive)","documentation":"Called when this entity should be revived. flTimeUntilRevive is the time until the revival should start."},{"declaration":"void BeginRevive(float flTimeUntilRevive)","documentation":"Prepares this entity for revival. flTimeUntilRevive is the time until the revive action completes."},{"declaration":"bool IsRevivable()","documentation":"Returns whether this entity is revivable at this time."},{"declaration":"void OnDestroy()","documentation":"Entity destructor."},{"declaration":"void OnCreate()","documentation":"Entity constructor."},{"declaration":"void GetDamagePoints(entvars_t@ pevAttacker, entvars_t@ pevInflictor, float flDamage)","documentation":"Adds damage points to the inflicting entity."},{"declaration":"float GetPointsForDamage(float flDamage)","documentation":"Returns the points received for damage done."},{"declaration":"bool IsFacing(entvars_t@ pevTest, float flDotProduct = VIEW_FIELD_ULTRA_NARROW)","documentation":"Returns whether this entity is facing the given entity, within the given view field."},{"declaration":"bool FVisible(const Vector& in vecOrigin)","documentation":"Returns whether this entity is visible from the given origin."},{"declaration":"bool FVisible(CBaseEntity@ pEntity, bool fIgnoreGlass)","documentation":"Returns whether this entity is visible to the given entity."},{"declaration":"int Illumination()","documentation":"Returns this entity's illumination."},{"declaration":"Vector BodyTarget(const Vector& in posSrc)","documentation":"Returns this entity's body target for shooting."},{"declaration":"Vector EarPosition()","documentation":"Returns this entity's ear position."},{"declaration":"Vector EyePosition()","documentation":"Returns this entity's eye position."},{"declaration":"Vector Center()","documentation":"Returns this entity's center."},{"declaration":"bool FBecomeProne()","documentation":"Makes this entity become prone."},{"declaration":"CBaseEntity@ Respawn()","documentation":"Respawns this entity."},{"declaration":"void UpdateOnRemove()","documentation":"Updates this entity when removed."},{"declaration":"void Blocked(CBaseEntity@ pOther)","documentation":"Triggers this entity's blocked function."},{"declaration":"void Use(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f)","documentation":"Trigger's this entity's use function."},{"declaration":"void Touch(CBaseEntity@ pOther)","documentation":"Triggers this entity's touch function."},{"declaration":"void Think()","documentation":"Makes this entity think. Do not call directly."},{"declaration":"CBaseEntity@ GetNextTarget()","documentation":"Gets the next target to trigger."},{"declaration":"bool CriticalRemove()","documentation":"Removes this entity in critical situations."},{"declaration":"bool IsMachine()","documentation":"Returns whether this is a machine."},{"declaration":"bool IsPointEnt()","documentation":"Returns whether this is a point entity."},{"declaration":"bool IsNetClient()","documentation":"Returns whether this is a net client."},{"declaration":"bool IsPlayer()","documentation":"Returns whether this entity is a player."},{"declaration":"bool IsMonster()","documentation":"Returns whether this entity is a monster."},{"declaration":"bool IsInWorld()","documentation":"Returns whether this entity is in the world."},{"declaration":"bool ReflectGauss()","documentation":"Returns whether this entity reflects gauss shots."},{"declaration":"bool IsBSPModel()","documentation":"Returns whether this entity is a BSP model."},{"declaration":"bool IsAlive()","documentation":"Returns whether this entity is alive."},{"declaration":"bool IsSneaking()","documentation":"Returns whether this entity is sneaking."},{"declaration":"bool OnControls(entvars_t@ pev)","documentation":"Reacts to controls set on the pev."},{"declaration":"void StopSneaking()","documentation":"Stops sneaking."},{"declaration":"void StartSneaking()","documentation":"Starts sneaking."},{"declaration":"void SetToggleState(int state)","documentation":"Sets this entity's toggle state."},{"declaration":"int DamageDecal(int bitsDamageType)","documentation":"Returns the damage decal<br/>See decal_e."},{"declaration":"void OverrideReset()","documentation":"Resets this entity."},{"declaration":"bool IsMoving()","documentation":"Returns whether this entity is moving."},{"declaration":"float GetDelay()","documentation":"Gets this entity's trigger delay."},{"declaration":"bool RemovePlayerItem(CBasePlayerItem@ pItem)","documentation":"Removes the given player item to this entity."},{"declaration":"AddPlayerItemResult AddPlayerItem(CBasePlayerItem@ pItem)","documentation":"Adds the given player item to this entity."},{"declaration":"void AddPointsToTeam(int score, const bool bAllowNegativeScore)","documentation":"Adds points to this entity's team."},{"declaration":"void AddPoints(int score, const bool bAllowNegativeScore)","documentation":"Adds points to this entity."},{"declaration":"int GetToggleState()","documentation":"Gets the toggle state.<br/>See the TOGGLE_STATE enum."},{"declaration":"bool SetupModel()","documentation":"Sets up the model."},{"declaration":"int entindex()","documentation":"Returns this entity's index."},{"declaration":"edict_t@ edict()","documentation":"Returns this entity's edict."},{"declaration":"bool IsLockedByMaster()","documentation":"Returns whether this entity is locked by its master."},{"declaration":"bool IsDormant()","documentation":"Returns whether this entity is dormant."},{"declaration":"void MakeDormant()","documentation":"Makes this entity dormant."},{"declaration":"bool Intersects(CBaseEntity@ pOther)","documentation":"Returns whether this entity intersects with the given entity."},{"declaration":"void FireBullets(uint cShots, Vector vecSrc, Vector vecDirShooting, Vector vecSpread,float flDistance, Bullet iBulletType, int iTracerFreq = 4, int iDamage = 0, entvars_t@ pevAttacker = null, FireBulletsDrawMode fDraw = FBDM_DRAW)","documentation":"Fires bullets. Must call CMath::MakeAimVectors with an angle vector first."},{"declaration":"bool ShouldToggle(USE_TYPE useType, const bool currentState)","documentation":"Returns whether this entity should toggle."},{"declaration":"void SUB_CallUseToggle()","documentation":"Think function. Calls use toggle on this entity."},{"declaration":"void SUB_FadeOut()","documentation":"Think function. Fades this entity."},{"declaration":"void SUB_StartFadeOut()","documentation":"Think function. Starts fading this entity."},{"declaration":"void SUB_DoNothing()","documentation":"Think function. Explicitly does nothing."},{"declaration":"void SUB_Remove()","documentation":"Think function. Delay-removes this entity."},{"declaration":"bool BlockedByEntity(CBaseEntity@ pOther, float flDamage)","documentation":"Returns true if you should be blocked by the entity, false otherwise. Also deals blocking damage to the entity, if applicable."},{"declaration":"CustomKeyvalues@ GetCustomKeyvalues()","documentation":"Gets this entity's custom keyvalues."},{"declaration":"CBaseMonster@ MyMonsterPointer()","documentation":"Returns this entity as its monster entity, if it is a monster."},{"declaration":"bool IsTriggered(CBaseEntity@ pActivator)","documentation":"Returns whether this entity is triggered by the given entity."},{"declaration":"int BloodColor()","documentation":"Returns the blood color. See the BLOOD_COLOR enum."},{"declaration":"void Killed(entvars_t@pevAtttacker, int iGibbed)","documentation":"Tells this entity it's been killed. See the GIB enum for possible values."},{"declaration":"bool TakeArmor(float flArmor, int bitsDamageType, int armor_cap = 0)","documentation":"Takes armor from this entity. Note: flArmor is added to entity armor. Use negative values to subtract.If armor_cap is non-zero, won't add more than armor_cap. Returns 1 if it took damage, 0 otherwise."},{"declaration":"bool TakeHealth(float flHealth, int bitsDamageType, int health_cap = 0)","documentation":"Takes health from this entity. Note: flHealth is added to entity health. Use negative values to subtract.If health_cap is non-zero, won't add more than health_cap. Returns true if it took damage, false otherwise."},{"declaration":"int TakeDamage(entvars_t@ pevInflictor, entvars_t@ pevAttacker, float flDamage, int bitsDamageType)","documentation":"Causes this entity to take damage. Returns 1 if it took damage, 0 otherwise."},{"declaration":"int Classify()","documentation":"Gets this entity's classification."},{"declaration":"int IRelationshipByClass(CLASS iClass)","documentation":"Gets the relationship between this entity and the given entity classification. See the RELATIONSHIP enum."},{"declaration":"int IRelationship(CBaseEntity@ other)","documentation":"Gets the relationship between this entity and the given entity. See the RELATIONSHIP enum."},{"declaration":"void ClearClassification()","documentation":"Clears this entity's classification override."},{"declaration":"void SetClassificationFromEntity(CBaseEntity@ pEntity)","documentation":"Sets this entity's classification override to the classification override set on the given entity. Can override the entity's player ally setting."},{"declaration":"void SetClassification(int cl)","documentation":"Sets this entity's classification override. Can override the entity's player ally setting."},{"declaration":"int GetClassification(int cl)","documentation":"Gets this entity's classification. Returns the given value if none is set. See the CLASSIFICATION enum."},{"declaration":"void SetObjectCollisionBox()","documentation":"Sets up the object collision box."},{"declaration":"int ObjectCaps()","documentation":"Gets this entity's objects caps. See the FCAP enum."},{"declaration":"void Precache()","documentation":"Precaches the entity. Do not call directly."},{"declaration":"bool opEquals(CBaseEntity@ pOther)","documentation":"Compares 2 entities for equality."},{"declaration":"void SetPlayerAllyDirect(bool fState)","documentation":"Sets this entity's player ally status.</br>Use this only if you need the setting to be exactly what you give it (e.g. when copying from another monster)"},{"declaration":"void SetPlayerAlly(bool fState)","documentation":"Sets this entity's player ally status."},{"declaration":"bool IsPlayerAlly() const","documentation":"Returns whether this entity is allied to players."},{"declaration":"int FindMonstersInWorld(array<CBaseEntity@>@ pArray, int flagMask)","documentation":"Finds monsters in the world"},{"declaration":"string SOUNDREPLACEMENT_Find(const string& in szFilename)","documentation":"Find sound replacement for the given file."},{"declaration":"bool FVisibleFromPos(const Vector& in vecTarget, const Vector& in vecStart)","documentation":"Returns whether this entity is visible from the given position."},{"declaration":"string GetTargetname() const","documentation":"Returns this entity's target name."},{"declaration":"string GetClassname() const","documentation":"Returns this entity's class name."},{"declaration":"string TeamID()","documentation":"Returns this entity's team ID."},{"declaration":"bool HasTarget(const string& in szTarget)","documentation":"Returns whether this entity has the given target."},{"declaration":"int GiveAmmo(int iAmount, const string& in szName, int iMax, const bool fFromWeapon = true)","documentation":"Gives ammo to this entity."},{"declaration":"void TraceBleed(float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)","documentation":"Traces entity bleed event."},{"declaration":"void TraceAttack(entvars_t@ pevAttacker, float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)","documentation":"Traces an attack by the given entity to this entity."},{"declaration":"bool KeyValue(const string& in szKeyName, const string& in szValue)","documentation":"Sets keyvalue data on this entity"},{"declaration":"void SetOrigin(const Vector& in vecOrigin)","documentation":"Sets this entity's (absolute) origin"},{"declaration":"const Vector& GetOrigin() const","documentation":"Gets the entity's (absolute) origin."},{"declaration":"CBaseEntity@ opImplCast()","documentation":"Implicitly casts to base type."}],"properties":[{"namespace":"","declaration":"string_t m_iszKillTarget","documentation":"The name of the kill target, if any."},{"namespace":"","declaration":"float m_flDelay","documentation":"Delay before fire."},{"namespace":"","declaration":"Vector m_vecOriginalRenderColor","documentation":"Original render color."},{"namespace":"","declaration":"float m_flOriginalRenderAmount","documentation":"Original render amount."},{"namespace":"","declaration":"int m_iOriginalRenderFX","documentation":"Original render FX."},{"namespace":"","declaration":"int m_iOriginalRenderMode","documentation":"Original render model."},{"namespace":"","declaration":"string_t classnameInFilterType","documentation":"Class name in filter type."},{"namespace":"","declaration":"string_t targetnameInFilterType","documentation":"Target name in filter type."},{"namespace":"","declaration":"string_t classnameOutFilterType","documentation":"Class name out filter type."},{"namespace":"","declaration":"string_t targetnameOutFilterType","documentation":"Target name out filter type."},{"namespace":"","declaration":"Vector m_vecLastOrigin","documentation":"Last origin vector"},{"namespace":"","declaration":"bool m_fCustomModel","documentation":"Whether a custom model is used."},{"namespace":"","declaration":"bool m_fCanFadeStart","documentation":"Whether fading can start."},{"namespace":"","declaration":"float m_flMaximumFadeWaitB","documentation":"Maximum fade wait time B."},{"namespace":"","declaration":"float m_flMaximumFadeWait","documentation":"Maximum fade wait time."},{"namespace":"","declaration":"int m_iClassSelection","documentation":"The overridden classification."},{"namespace":"","declaration":"bool m_fOverrideClass","documentation":"Whether this entity overrides the classification."},{"namespace":"","declaration":"entvars_t@ pev","documentation":"Entity variables"}],"className":"CBaseDelay","documentation":"All entities that can trigger with a delay derive from this","namespace":""},{"flags":262145,"methods":[{"declaration":"CGib@ opCast()","documentation":"Explicitly casts to sub type."},{"declaration":"CBaseDoor@ opCast()","documentation":"Explicitly casts to sub type."},{"declaration":"CBaseButton@ opCast()","documentation":"Explicitly casts to sub type."},{"declaration":"CItem@ opCast()","documentation":"Explicitly casts to sub type."},{"declaration":"CBasePlayerAmmo@ opCast()","documentation":"Explicitly casts to sub type."},{"declaration":"CBaseTank@ opCast()","documentation":"Explicitly casts to sub type."},{"declaration":"CLaser@ opCast()","documentation":"Explicitly casts to sub type."},{"declaration":"CBeam@ opCast()","documentation":"Explicitly casts to sub type."},{"declaration":"CPathTrack@ opCast()","documentation":"Explicitly casts to sub type."},{"declaration":"CBasePlayerWeapon@ opCast()","documentation":"Explicitly casts to sub type."},{"declaration":"CSprite@ opCast()","documentation":"Explicitly casts to sub type."},{"declaration":"CGrenade@ opCast()","documentation":"Explicitly casts to sub type."},{"declaration":"CBasePlayer@ opCast()","documentation":"Explicitly casts to sub type."},{"declaration":"CCineMonster@ opCast()","documentation":"Explicitly casts to sub type."},{"declaration":"CBaseMonster@ opCast()","documentation":"Explicitly casts to sub type."},{"declaration":"CBasePlayerItem@ opCast()","documentation":"Explicitly casts to sub type."},{"declaration":"CBaseToggle@ opCast()","documentation":"Explicitly casts to sub type."},{"declaration":"CBaseAnimating@ opCast()","documentation":"Explicitly casts to sub type."},{"declaration":"CBaseDelay@ opCast()","documentation":"Explicitly casts to sub type."},{"declaration":"void ClearUserData()","documentation":"Clears the user data on this entity. WARNING: clears all data.<br/>Only map scripts can use this."},{"declaration":"dictionaryValue& GetUserData(const string& in szKey)","documentation":"Gets the user data stored under the specified key on this entity.<br/>Do not keep references to this data, the object might be removed from this entity.<br/>Only map scripts can use this."},{"declaration":"dictionary@ GetUserData()","documentation":"Gets the user data on this entity. Do not keep references to this data, the object might be removed from this entity.<br/>Only map scripts can use this."},{"declaration":"void EndRevive(float flTimeUntilRevive)","documentation":"Called when this entity should be revived. flTimeUntilRevive is the time until the revival should start."},{"declaration":"void BeginRevive(float flTimeUntilRevive)","documentation":"Prepares this entity for revival. flTimeUntilRevive is the time until the revive action completes."},{"declaration":"bool IsRevivable()","documentation":"Returns whether this entity is revivable at this time."},{"declaration":"void OnDestroy()","documentation":"Entity destructor."},{"declaration":"void OnCreate()","documentation":"Entity constructor."},{"declaration":"void GetDamagePoints(entvars_t@ pevAttacker, entvars_t@ pevInflictor, float flDamage)","documentation":"Adds damage points to the inflicting entity."},{"declaration":"float GetPointsForDamage(float flDamage)","documentation":"Returns the points received for damage done."},{"declaration":"bool IsFacing(entvars_t@ pevTest, float flDotProduct = VIEW_FIELD_ULTRA_NARROW)","documentation":"Returns whether this entity is facing the given entity, within the given view field."},{"declaration":"bool FVisible(const Vector& in vecOrigin)","documentation":"Returns whether this entity is visible from the given origin."},{"declaration":"bool FVisible(CBaseEntity@ pEntity, bool fIgnoreGlass)","documentation":"Returns whether this entity is visible to the given entity."},{"declaration":"int Illumination()","documentation":"Returns this entity's illumination."},{"declaration":"Vector BodyTarget(const Vector& in posSrc)","documentation":"Returns this entity's body target for shooting."},{"declaration":"Vector EarPosition()","documentation":"Returns this entity's ear position."},{"declaration":"Vector EyePosition()","documentation":"Returns this entity's eye position."},{"declaration":"Vector Center()","documentation":"Returns this entity's center."},{"declaration":"bool FBecomeProne()","documentation":"Makes this entity become prone."},{"declaration":"CBaseEntity@ Respawn()","documentation":"Respawns this entity."},{"declaration":"void UpdateOnRemove()","documentation":"Updates this entity when removed."},{"declaration":"void Blocked(CBaseEntity@ pOther)","documentation":"Triggers this entity's blocked function."},{"declaration":"void Use(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f)","documentation":"Trigger's this entity's use function."},{"declaration":"void Touch(CBaseEntity@ pOther)","documentation":"Triggers this entity's touch function."},{"declaration":"void Think()","documentation":"Makes this entity think. Do not call directly."},{"declaration":"CBaseEntity@ GetNextTarget()","documentation":"Gets the next target to trigger."},{"declaration":"bool CriticalRemove()","documentation":"Removes this entity in critical situations."},{"declaration":"bool IsMachine()","documentation":"Returns whether this is a machine."},{"declaration":"bool IsPointEnt()","documentation":"Returns whether this is a point entity."},{"declaration":"bool IsNetClient()","documentation":"Returns whether this is a net client."},{"declaration":"bool IsPlayer()","documentation":"Returns whether this entity is a player."},{"declaration":"bool IsMonster()","documentation":"Returns whether this entity is a monster."},{"declaration":"bool IsInWorld()","documentation":"Returns whether this entity is in the world."},{"declaration":"bool ReflectGauss()","documentation":"Returns whether this entity reflects gauss shots."},{"declaration":"bool IsBSPModel()","documentation":"Returns whether this entity is a BSP model."},{"declaration":"bool IsAlive()","documentation":"Returns whether this entity is alive."},{"declaration":"bool IsSneaking()","documentation":"Returns whether this entity is sneaking."},{"declaration":"bool OnControls(entvars_t@ pev)","documentation":"Reacts to controls set on the pev."},{"declaration":"void StopSneaking()","documentation":"Stops sneaking."},{"declaration":"void StartSneaking()","documentation":"Starts sneaking."},{"declaration":"void SetToggleState(int state)","documentation":"Sets this entity's toggle state."},{"declaration":"int DamageDecal(int bitsDamageType)","documentation":"Returns the damage decal<br/>See decal_e."},{"declaration":"void OverrideReset()","documentation":"Resets this entity."},{"declaration":"bool IsMoving()","documentation":"Returns whether this entity is moving."},{"declaration":"float GetDelay()","documentation":"Gets this entity's trigger delay."},{"declaration":"bool RemovePlayerItem(CBasePlayerItem@ pItem)","documentation":"Removes the given player item to this entity."},{"declaration":"AddPlayerItemResult AddPlayerItem(CBasePlayerItem@ pItem)","documentation":"Adds the given player item to this entity."},{"declaration":"void AddPointsToTeam(int score, const bool bAllowNegativeScore)","documentation":"Adds points to this entity's team."},{"declaration":"void AddPoints(int score, const bool bAllowNegativeScore)","documentation":"Adds points to this entity."},{"declaration":"int GetToggleState()","documentation":"Gets the toggle state.<br/>See the TOGGLE_STATE enum."},{"declaration":"bool SetupModel()","documentation":"Sets up the model."},{"declaration":"int entindex()","documentation":"Returns this entity's index."},{"declaration":"edict_t@ edict()","documentation":"Returns this entity's edict."},{"declaration":"bool IsLockedByMaster()","documentation":"Returns whether this entity is locked by its master."},{"declaration":"bool IsDormant()","documentation":"Returns whether this entity is dormant."},{"declaration":"void MakeDormant()","documentation":"Makes this entity dormant."},{"declaration":"bool Intersects(CBaseEntity@ pOther)","documentation":"Returns whether this entity intersects with the given entity."},{"declaration":"void SUB_UseTargets(CBaseEntity@ pActivator, USE_TYPE useType, float flValue)","documentation":"Calls use on targets."},{"declaration":"void FireBullets(uint cShots, Vector vecSrc, Vector vecDirShooting, Vector vecSpread,float flDistance, Bullet iBulletType, int iTracerFreq = 4, int iDamage = 0, entvars_t@ pevAttacker = null, FireBulletsDrawMode fDraw = FBDM_DRAW)","documentation":"Fires bullets. Must call CMath::MakeAimVectors with an angle vector first."},{"declaration":"bool ShouldToggle(USE_TYPE useType, const bool currentState)","documentation":"Returns whether this entity should toggle."},{"declaration":"void SUB_CallUseToggle()","documentation":"Think function. Calls use toggle on this entity."},{"declaration":"void SUB_FadeOut()","documentation":"Think function. Fades this entity."},{"declaration":"void SUB_StartFadeOut()","documentation":"Think function. Starts fading this entity."},{"declaration":"void SUB_DoNothing()","documentation":"Think function. Explicitly does nothing."},{"declaration":"void SUB_Remove()","documentation":"Think function. Delay-removes this entity."},{"declaration":"bool BlockedByEntity(CBaseEntity@ pOther, float flDamage)","documentation":"Returns true if you should be blocked by the entity, false otherwise. Also deals blocking damage to the entity, if applicable."},{"declaration":"CustomKeyvalues@ GetCustomKeyvalues()","documentation":"Gets this entity's custom keyvalues."},{"declaration":"CBaseMonster@ MyMonsterPointer()","documentation":"Returns this entity as its monster entity, if it is a monster."},{"declaration":"bool IsTriggered(CBaseEntity@ pActivator)","documentation":"Returns whether this entity is triggered by the given entity."},{"declaration":"int BloodColor()","documentation":"Returns the blood color. See the BLOOD_COLOR enum."},{"declaration":"void Killed(entvars_t@pevAtttacker, int iGibbed)","documentation":"Tells this entity it's been killed. See the GIB enum for possible values."},{"declaration":"bool TakeArmor(float flArmor, int bitsDamageType, int armor_cap = 0)","documentation":"Takes armor from this entity. Note: flArmor is added to entity armor. Use negative values to subtract.If armor_cap is non-zero, won't add more than armor_cap. Returns 1 if it took damage, 0 otherwise."},{"declaration":"bool TakeHealth(float flHealth, int bitsDamageType, int health_cap = 0)","documentation":"Takes health from this entity. Note: flHealth is added to entity health. Use negative values to subtract.If health_cap is non-zero, won't add more than health_cap. Returns true if it took damage, false otherwise."},{"declaration":"int TakeDamage(entvars_t@ pevInflictor, entvars_t@ pevAttacker, float flDamage, int bitsDamageType)","documentation":"Causes this entity to take damage. Returns 1 if it took damage, 0 otherwise."},{"declaration":"int Classify()","documentation":"Gets this entity's classification."},{"declaration":"int IRelationshipByClass(CLASS iClass)","documentation":"Gets the relationship between this entity and the given entity classification. See the RELATIONSHIP enum."},{"declaration":"int IRelationship(CBaseEntity@ other)","documentation":"Gets the relationship between this entity and the given entity. See the RELATIONSHIP enum."},{"declaration":"void ClearClassification()","documentation":"Clears this entity's classification override."},{"declaration":"void SetClassificationFromEntity(CBaseEntity@ pEntity)","documentation":"Sets this entity's classification override to the classification override set on the given entity. Can override the entity's player ally setting."},{"declaration":"void SetClassification(int cl)","documentation":"Sets this entity's classification override. Can override the entity's player ally setting."},{"declaration":"int GetClassification(int cl)","documentation":"Gets this entity's classification. Returns the given value if none is set. See the CLASSIFICATION enum."},{"declaration":"void SetObjectCollisionBox()","documentation":"Sets up the object collision box."},{"declaration":"int ObjectCaps()","documentation":"Gets this entity's objects caps. See the FCAP enum."},{"declaration":"void Precache()","documentation":"Precaches the entity. Do not call directly."},{"declaration":"bool opEquals(CBaseEntity@ pOther)","documentation":"Compares 2 entities for equality."},{"declaration":"void SetPlayerAllyDirect(bool fState)","documentation":"Sets this entity's player ally status.</br>Use this only if you need the setting to be exactly what you give it (e.g. when copying from another monster)"},{"declaration":"void SetPlayerAlly(bool fState)","documentation":"Sets this entity's player ally status."},{"declaration":"bool IsPlayerAlly() const","documentation":"Returns whether this entity is allied to players."},{"declaration":"int FindMonstersInWorld(array<CBaseEntity@>@ pArray, int flagMask)","documentation":"Finds monsters in the world"},{"declaration":"string SOUNDREPLACEMENT_Find(const string& in szFilename)","documentation":"Find sound replacement for the given file."},{"declaration":"bool FVisibleFromPos(const Vector& in vecTarget, const Vector& in vecStart)","documentation":"Returns whether this entity is visible from the given position."},{"declaration":"string GetTargetname() const","documentation":"Returns this entity's target name."},{"declaration":"string GetClassname() const","documentation":"Returns this entity's class name."},{"declaration":"string TeamID()","documentation":"Returns this entity's team ID."},{"declaration":"bool HasTarget(const string& in szTarget)","documentation":"Returns whether this entity has the given target."},{"declaration":"int GiveAmmo(int iAmount, const string& in szName, int iMax, const bool fFromWeapon = true)","documentation":"Gives ammo to this entity."},{"declaration":"void TraceBleed(float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)","documentation":"Traces entity bleed event."},{"declaration":"void TraceAttack(entvars_t@ pevAttacker, float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)","documentation":"Traces an attack by the given entity to this entity."},{"declaration":"bool KeyValue(const string& in szKeyName, const string& in szValue)","documentation":"Sets keyvalue data on this entity"},{"declaration":"void SetOrigin(const Vector& in vecOrigin)","documentation":"Sets this entity's (absolute) origin"},{"declaration":"const Vector& GetOrigin() const","documentation":"Gets the entity's (absolute) origin."},{"declaration":"CItemInventory@ opCast()","documentation":"Explicitly casts to sub type."}],"properties":[{"namespace":"","declaration":"Vector m_vecOriginalRenderColor","documentation":"Original render color."},{"namespace":"","declaration":"float m_flOriginalRenderAmount","documentation":"Original render amount."},{"namespace":"","declaration":"int m_iOriginalRenderFX","documentation":"Original render FX."},{"namespace":"","declaration":"int m_iOriginalRenderMode","documentation":"Original render model."},{"namespace":"","declaration":"string_t classnameInFilterType","documentation":"Class name in filter type."},{"namespace":"","declaration":"string_t targetnameInFilterType","documentation":"Target name in filter type."},{"namespace":"","declaration":"string_t classnameOutFilterType","documentation":"Class name out filter type."},{"namespace":"","declaration":"string_t targetnameOutFilterType","documentation":"Target name out filter type."},{"namespace":"","declaration":"Vector m_vecLastOrigin","documentation":"Last origin vector"},{"namespace":"","declaration":"bool m_fCustomModel","documentation":"Whether a custom model is used."},{"namespace":"","declaration":"bool m_fCanFadeStart","documentation":"Whether fading can start."},{"namespace":"","declaration":"float m_flMaximumFadeWaitB","documentation":"Maximum fade wait time B."},{"namespace":"","declaration":"float m_flMaximumFadeWait","documentation":"Maximum fade wait time."},{"namespace":"","declaration":"int m_iClassSelection","documentation":"The overridden classification."},{"namespace":"","declaration":"bool m_fOverrideClass","documentation":"Whether this entity overrides the classification."},{"namespace":"","declaration":"entvars_t@ pev","documentation":"Entity variables"}],"className":"CBaseEntity","documentation":"All entities derive from this","namespace":""},{"flags":262145,"methods":[{"declaration":"string GetIndex(decal_e decal) const","documentation":"Gets the texture frame index of the given decal."},{"declaration":"string GetName(decal_e decal) const","documentation":"Gets the name of the texture representing the given decal."}],"properties":[],"className":"CDecals","documentation":"Dynamic decal manager","namespace":""},{"flags":262145,"methods":[{"declaration":"edict_t@ get_pContainingEntity() const","documentation":"Entity containing entity. pContainingEntity.vars equals this entvars instance."},{"declaration":"bool FlagBitSet(int iFlags)","documentation":"Returns whether the given flag(s) are set on the entvars flags variable"},{"declaration":"bool SpawnFlagBitSet(int iFlags)","documentation":"Returns whether the given flag(s) are set on the entvars spawnflags variable"},{"declaration":"void set_blending(uint, int8)","documentation":"Set entity blending by index (0..1, 0..255). Used by entities with models to set x or y axis blending."},{"declaration":"int8 get_blending(uint)","documentation":"Get entity blending by index (0..1). Used by entities with models to get x or y axis blending."},{"declaration":"void set_controller(uint, int8)","documentation":"Set entity controller by index (0..3, 0..255) Used by entities with studio models to set bone controller settings."},{"declaration":"int8 get_controller(uint)","documentation":"Get entity controller by index (0..3). Used by entities with studio models to get bone controller settings."},{"declaration":"bool ClassNameIs(const string& in szClassName)","documentation":"Returns whether the given class name is this entity's class name"}],"properties":[{"namespace":"","declaration":"edict_t@ euser4","documentation":"User variable 4 (Edict)"},{"namespace":"","declaration":"edict_t@ euser3","documentation":"User variable 3 (Edict)"},{"namespace":"","declaration":"edict_t@ euser2","documentation":"User variable 2 (Edict)"},{"namespace":"","declaration":"edict_t@ euser1","documentation":"User variable 1 (Edict)"},{"namespace":"","declaration":"Vector vuser4","documentation":"User variable 4 (Vector)"},{"namespace":"","declaration":"Vector vuser3","documentation":"User variable 3 (Vector)"},{"namespace":"","declaration":"Vector vuser2","documentation":"User variable 2 (Vector)"},{"namespace":"","declaration":"Vector vuser1","documentation":"User variable 1 (Vector)"},{"namespace":"","declaration":"float fuser4","documentation":"User variable 4 (float)"},{"namespace":"","declaration":"float fuser3","documentation":"User variable 3 (float)"},{"namespace":"","declaration":"float fuser2","documentation":"User variable 2 (float)"},{"namespace":"","declaration":"float fuser1","documentation":"User variable 1 (float)"},{"namespace":"","declaration":"int iuser4","documentation":"User variable 4 (integer)"},{"namespace":"","declaration":"int iuser3","documentation":"User variable 3 (integer)"},{"namespace":"","declaration":"int iuser2","documentation":"User variable 2 (integer)"},{"namespace":"","declaration":"int iuser1","documentation":"User variable 1 (integer)"},{"namespace":"","declaration":"int groupinfo","documentation":"Entity group info. Used for internal operations."},{"namespace":"","declaration":"int oldbuttons","documentation":"Player old buttons. Previous frame's contents of buttons."},{"namespace":"","declaration":"int gamestate","documentation":"Entity gamestate. Reserved for future use."},{"namespace":"","declaration":"float flFallVelocity","documentation":"Player fall velocity."},{"namespace":"","declaration":"int iStepLeft","documentation":"Entity step left flag. Used for internal operations."},{"namespace":"","declaration":"int flDuckTime","documentation":"Entity duck time. Used for internal operations."},{"namespace":"","declaration":"int flSwimTime","documentation":"Entity swim time. Used for internal operations."},{"namespace":"","declaration":"int flTimeStepSound","documentation":"Entity time of step sound. Used for internal operations."},{"namespace":"","declaration":"int bInDuck","documentation":"Entity ducking flag. Used for internal operations."},{"namespace":"","declaration":"int pushmsec","documentation":"Entity push milliseconds. Used for internal operations."},{"namespace":"","declaration":"int weaponanim","documentation":"Player weapon animation"},{"namespace":"","declaration":"float fov","documentation":"Player field of view"},{"namespace":"","declaration":"float maxspeed","documentation":"Entity maximum speed"},{"namespace":"","declaration":"int playerclass","documentation":"Entity player class. Reserved for future use."},{"namespace":"","declaration":"float radsuit_finished","documentation":"Entity radiation suit finished. Reserved for future use."},{"namespace":"","declaration":"float pain_finished","documentation":"Player pain finished. Time at which the player can take damage again while drowning."},{"namespace":"","declaration":"float air_finished","documentation":"Player air finished. Time at which the player runs out of air when underwater."},{"namespace":"","declaration":"float speed","documentation":"Entity speed"},{"namespace":"","declaration":"string_t noise3","documentation":"Entity noise 3. Usually used to store a sound name."},{"namespace":"","declaration":"string_t noise2","documentation":"Entity noise 2. Usually used to store a sound name."},{"namespace":"","declaration":"string_t noise1","documentation":"Entity noise 1. Usually used to store a sound name."},{"namespace":"","declaration":"string_t noise","documentation":"Entity noise. Usually used to store a sound name."},{"namespace":"","declaration":"float dmgtime","documentation":"Entity damage time. Time at which this entity last took damage. Usually used to limit damage effects from being shown too often."},{"namespace":"","declaration":"float dmg","documentation":"Entity damage. Usually stores how much damage this entity can do to other entities."},{"namespace":"","declaration":"float dmg_save","documentation":"Entity damage save. Used for internal operations."},{"namespace":"","declaration":"float dmg_take","documentation":"Entity damage take. Used for internal operations."},{"namespace":"","declaration":"string_t message","documentation":"The entity message. Used for various things."},{"namespace":"","declaration":"string_t netname","documentation":"The entity net name. Used for various things, such as the player's name."},{"namespace":"","declaration":"string_t targetname","documentation":"The entity target name"},{"namespace":"","declaration":"string_t target","documentation":"The entity target. If set, is the name of one or more targets to trigger. Otherwise, is empty."},{"namespace":"","declaration":"int watertype","documentation":"Player only. Contains the type of water contents the player is currently in. See CONTENTS enum."},{"namespace":"","declaration":"int waterlevel","documentation":"Entity water level<br/>See WATERLEVEL enum."},{"namespace":"","declaration":"float armorvalue","documentation":"Entity armor value"},{"namespace":"","declaration":"float armortype","documentation":"Entity armor type. Represents maximum armor (similar to max_health)."},{"namespace":"","declaration":"float teleport_time","documentation":"Entity teleport time. Intended for internal operations."},{"namespace":"","declaration":"float max_health","documentation":"Entity maximum health"},{"namespace":"","declaration":"int team","documentation":"Entity team. Reserved for future use."},{"namespace":"","declaration":"int colormap","documentation":"Entity color map. Used for player model colors."},{"namespace":"","declaration":"int flags","documentation":"Entity flags<br/>See EdictFlags enum."},{"namespace":"","declaration":"int spawnflags","documentation":"Entity spawn flags"},{"namespace":"","declaration":"edict_t@ groundentity","documentation":"Entity ground entity"},{"namespace":"","declaration":"edict_t@ owner","documentation":"Entity owner"},{"namespace":"","declaration":"edict_t@ aiment","documentation":"Entity pointer when MOVETYPE_FOLLOW"},{"namespace":"","declaration":"edict_t@ enemy","documentation":"Entity enemy"},{"namespace":"","declaration":"edict_t@ dmg_inflictor","documentation":"Entity damage inflictor"},{"namespace":"","declaration":"edict_t@ chain","documentation":"Entity pointer when linked into a linked list. Used for temporary lists."},{"namespace":"","declaration":"int impulse","documentation":"Entity impulse bit vector. Used for various internal operations."},{"namespace":"","declaration":"int button","documentation":"Entity button bit vector. Usually used to track which buttons the player is currently pressing."},{"namespace":"","declaration":"Vector view_ofs","documentation":"Entity view offset. Used to set an eye offset."},{"namespace":"","declaration":"int deadflag","documentation":"Entity dead flag<br/>See DEAD enum."},{"namespace":"","declaration":"float takedamage","documentation":"Entity take damage flag<br/>See DAMAGE enum."},{"namespace":"","declaration":"int weapons","documentation":"Entity weapons bit vector. Largely used by monsters to track which weapons they have, and by players for internal purposes."},{"namespace":"","declaration":"float frags","documentation":"Entity frags. Usually used for the number of kills or score."},{"namespace":"","declaration":"float health","documentation":"Entity health. Do not set directly unless you are absolutely sure you know what you are doing."},{"namespace":"","declaration":"int renderfx","documentation":"Entity render fx"},{"namespace":"","declaration":"Vector rendercolor","documentation":"Entity render color (rgb)"},{"namespace":"","declaration":"float renderamt","documentation":"Entity render amount (0..255)"},{"namespace":"","declaration":"int rendermode","documentation":"Entity render mode. See RenderModes enum."},{"namespace":"","declaration":"float scale","documentation":"Entity rendering scale (0..255). Applies to studio and sprite models."},{"namespace":"","declaration":"float framerate","documentation":"Entity framerate. used by entities with studio models to control sequence frame rate."},{"namespace":"","declaration":"float animtime","documentation":"Entity animation time. Used for internal operations."},{"namespace":"","declaration":"float frame","documentation":"Entity frame. Used by entities with studio models to set the current frame that a sequence is using. Automatically incremented.Used by brush models for animated textures: 1 for animated, 0 for off."},{"namespace":"","declaration":"int gaitsequence","documentation":"Entity gait sequence. Used by entities with studio models for walking sequences."},{"namespace":"","declaration":"int sequence","documentation":"Entity sequence. Used by entities with studio models to set which sequence to use."},{"namespace":"","declaration":"int light_level","documentation":"Player only light level. This is a single value between 0 and 255 inclusive. Use g_EngineFuncs.GetEntityIllum to retrieve this value."},{"namespace":"","declaration":"float friction","documentation":"Entity friction. Is a scalar between 0 and 1, inclusive."},{"namespace":"","declaration":"float gravity","documentation":"Entity gravity. Is a scalar between 0 and 1, inclusive."},{"namespace":"","declaration":"int effects","documentation":"Entity effects<br/>See EFFECTS enum."},{"namespace":"","declaration":"int body","documentation":"Entity body index. Used by entities with studio models to set which body to use."},{"namespace":"","declaration":"int skin","documentation":"Entity skin index. Used by entities with studio models to set which skin to use."},{"namespace":"","declaration":"int solid","documentation":"Entity solid flag<br/>See SOLID enum."},{"namespace":"","declaration":"int movetype","documentation":"Entity movetype<br/>See MOVETYPE enum."},{"namespace":"","declaration":"float nextthink","documentation":"Entity next think time. The next time this entity will execute its think function, as an absolute time value. Otherwise, is 0."},{"namespace":"","declaration":"float ltime","documentation":"Entity ltime. The last time this entity has executed its think function. Otherwise, is 0."},{"namespace":"","declaration":"Vector size","documentation":"Entity size. Equivalent to maxs - mins"},{"namespace":"","declaration":"Vector maxs","documentation":"Entity maximum size. Relative to the player's origin."},{"namespace":"","declaration":"Vector mins","documentation":"Entity minimum size. Relative to the player's origin."},{"namespace":"","declaration":"Vector absmax","documentation":"Entity absolute maximum size. Is an absolute position in the world. Automatically updated by the engine."},{"namespace":"","declaration":"Vector absmin","documentation":"Entity absolute minimum size. Is an absolute position in the world. Automatically updated by the engine."},{"namespace":"","declaration":"string_t weaponmodel","documentation":"Entity weapon model index. If this player has a visible weapon, is the name of that third person (p_) model. Otherwise, is an empty string."},{"namespace":"","declaration":"string_t viewmodel","documentation":"Player view model index. If this player has a visible weapon, is the name of that view (v_) model. Otherwise, is an empty string."},{"namespace":"","declaration":"string_t model","documentation":"The entity model name. If this entity has a model, is the name of that model. Otherwise, is an empty string.Use g_EntityFuncs.SetModel to set this variable."},{"namespace":"","declaration":"const int modelindex","documentation":"Entity model index. If this entity has a model, is the unique index of the model. Otherwise, is 0."},{"namespace":"","declaration":"float yaw_speed","documentation":"Entity yaw speed. See ideal_yaw."},{"namespace":"","declaration":"float ideal_yaw","documentation":"Entity ideal yaw. Used in conjunction with yaw_speed to interpolate the entity's current yaw angle to this value."},{"namespace":"","declaration":"float pitch_speed","documentation":"Entity pitch speed. See idealpitch."},{"namespace":"","declaration":"float idealpitch","documentation":"Entity ideal pitch. Used in conjunction with pitch_speed to interpolate the entity's current pitch angle to this value."},{"namespace":"","declaration":"int fixangle","documentation":"Entity fix angle. Engine uses this value to change player view angles, and then resets it to FAM_NOTHING. See FixAngleMode enum."},{"namespace":"","declaration":"float starttime","documentation":"Entity start time. Reserved for future use."},{"namespace":"","declaration":"float impacttime","documentation":"Entity impact time. Reserved for future use."},{"namespace":"","declaration":"Vector startpos","documentation":"Entity start position. Reserved for future use."},{"namespace":"","declaration":"Vector endpos","documentation":"Entity end position. Reserved for future use."},{"namespace":"","declaration":"Vector v_angle","documentation":"Player view angle. These are the angles used for the player's view, and differ from the regular angles variable."},{"namespace":"","declaration":"Vector punchangle","documentation":"Player punch angle. These angles are applied to players when they are 'punched'.These angles are automatically interpolated back to the null vector over time."},{"namespace":"","declaration":"Vector avelocity","documentation":"Entity angular velocity, in degrees/sec. Applied to the entity's angles."},{"namespace":"","declaration":"Vector angles","documentation":"Entity angles, in degrees."},{"namespace":"","declaration":"Vector movedir","documentation":"Entity move direction. Used by some entities for movement directions, but some entities use it for other purposes."},{"namespace":"","declaration":"Vector basevelocity","documentation":"Entity base velocity. Used when standing on another entity that applies velocity to entities standing on it, for instance conveyors."},{"namespace":"","declaration":"Vector velocity","documentation":"Entity velocity"},{"namespace":"","declaration":"Vector oldorigin","documentation":"Old entity origin. Used by some entities to store off their original origin before moving to a different location."},{"namespace":"","declaration":"Vector origin","documentation":"Entity origin. Must be set using g_EntityFuncs.SetOrigin."},{"namespace":"","declaration":"string_t globalname","documentation":"The entity global name"},{"namespace":"","declaration":"const string_t classname","documentation":"The entity class name"}],"className":"entvars_t","documentation":"Networked entity variables","namespace":""},{"flags":262145,"methods":[{"declaration":"int16 get_leafnums(uint)","documentation":"get leafnums"}],"properties":[{"namespace":"","declaration":"entvars_t vars","documentation":"Entity variables instance"},{"namespace":"","declaration":"const float freetime","documentation":"When this edict was last freed"},{"namespace":"","declaration":"const int num_leafs","documentation":"Number of leafs"},{"namespace":"","declaration":"const int headnode","documentation":"Head node"},{"namespace":"","declaration":"const int serialnumber","documentation":"Serial number"},{"namespace":"","declaration":"const int free","documentation":"Flag telling whether this edict is free"}],"className":"edict_t","documentation":"Entity dictionary structure","namespace":""},{"flags":262145,"methods":[{"declaration":"bool Compare(double flLhs, double flRhs, double flEpsilon) const","documentation":"Compares the given floating point variables and returns whether they are equal, considering certain variance (epsilon) between them."},{"declaration":"bool Compare(float flLhs, float flRhs, float flEpsilon) const","documentation":"Compares the given floating point variables and returns whether they are equal, considering certain variance (epsilon) between them."},{"declaration":"float RadiansToDegrees(float flRadians) const","documentation":"Returns the given value in radians as degrees"},{"declaration":"float DegreesToRadians(float flDegrees) const","documentation":"Returns the given value in degrees as radians"},{"declaration":"float Ceil(float flValue) const","documentation":"Returns the float value, rounded up to the nearest whole number"},{"declaration":"float Floor(float flValue) const","documentation":"Returns the float value, rounded down to the nearest whole number"},{"declaration":"float clamp(float min, float max, float value) const","documentation":"Clamps a value between a range"},{"declaration":"int clamp(int min, int max, int value) const","documentation":"Clamps a value between a range"},{"declaration":"float max(float lhs, float rhs) const","documentation":"Returns the larger of the two values"},{"declaration":"int64 max(int64 lhs, int64 rhs) const","documentation":"Returns the larger of the two values"},{"declaration":"uint64 max(uint64 lhs, uint64 rhs) const","documentation":"Returns the larger of the two values"},{"declaration":"float min(float lhs, float rhs) const","documentation":"Returns the smaller of the two values"},{"declaration":"int64 min(int64 lhs, int64 rhs) const","documentation":"Returns the smaller of the two values"},{"declaration":"uint64 min(uint64 lhs, uint64 rhs) const","documentation":"Returns the smaller of the two values"},{"declaration":"float AngleDistance(float flNext, float flCur)","documentation":"Returns the distance between 2 angles"},{"declaration":"float ApproachAngle(float target, float value, float speed)","documentation":"Given a target and current angle value, and a rotation speed, all in degrees, returns a new angle that is either between value and target, or target, depending on whether the speed is high enough to reach that angle."},{"declaration":"float AngleDiff(float flDestAngle, float flSrcAngle)","documentation":"Returns the difference between 2 angles"},{"declaration":"float AngleMod(float flAngle)","documentation":"Clamps the given angle between 0 and 360"},{"declaration":"Vector VecToAngles(const Vector& in vec)","documentation":"Transforms a vector to an angle"},{"declaration":"float VecToYaw(const Vector& in vec)","documentation":"Transforms a vector to a yaw value"},{"declaration":"void MakeInvVectors(const Vector& in vecAngles)","documentation":"Make inverted vectors"},{"declaration":"void MakeAimVectors(const Vector& in vecAngles)","documentation":"Make aim vectors"},{"declaration":"Vector RotateVector(Vector& in vecToRotate,const Vector& in vecAngles, const Vector& in vecOffset)","documentation":"Rotate vector"},{"declaration":"void MakeVectors(const Vector& in vecAngles)","documentation":"Makes vectors"},{"declaration":"float RandomFloat(float low, float high)","documentation":"Returns a random float between low and high"},{"declaration":"int32 RandomLong(int32 low, int32 high)","documentation":"Returns a random integer between low and high"}],"properties":[{"namespace":"","declaration":"const double PI","documentation":"PI"},{"namespace":"","declaration":"const double DOUBLE_MAX","documentation":"Double maximum positive value"},{"namespace":"","declaration":"const float FLOAT_MAX","documentation":"Float maximum positive value"},{"namespace":"","declaration":"const double DOUBLE_MIN","documentation":"Double minimum positive value"},{"namespace":"","declaration":"const float FLOAT_MIN","documentation":"Float minimum positive value"},{"namespace":"","declaration":"const size_t SIZE_MAX","documentation":"Size_t maximum value"},{"namespace":"","declaration":"const uint64 UINT64_MAX","documentation":"Uint64 maximum value"},{"namespace":"","declaration":"const uint32 UINT32_MAX","documentation":"Uint32 maximum value"},{"namespace":"","declaration":"const uint16 UINT16_MAX","documentation":"Uint16 maximum value"},{"namespace":"","declaration":"const uint8 UINT8_MAX","documentation":"Uint8 maximum value"},{"namespace":"","declaration":"const int64 INT64_MAX","documentation":"Int64 maximum value"},{"namespace":"","declaration":"const int32 INT32_MAX","documentation":"Int32 maximum value"},{"namespace":"","declaration":"const int16 INT16_MAX","documentation":"Int16 maximum value"},{"namespace":"","declaration":"const int8 INT8_MAX","documentation":"Int8 maximum value"},{"namespace":"","declaration":"const int64 INT64_MIN","documentation":"Int64 minimum value"},{"namespace":"","declaration":"const int32 INT32_MIN","documentation":"Int32 minimum value"},{"namespace":"","declaration":"const int16 INT16_MIN","documentation":"Int16 minimum value"},{"namespace":"","declaration":"const int8 INT8_MIN","documentation":"Int8 minimum value"}],"className":"CMath","documentation":"Math functions","namespace":""},{"flags":135938,"methods":[{"declaration":"string ToString() const","documentation":"Returns a string representation of this vector"},{"declaration":"Vector2D Make2D() const","documentation":"Returns the 2D form of this vector"},{"declaration":"Vector Normalize() const","documentation":"Returns the normalized form of this vector"},{"declaration":"float Length2D() const","documentation":"Gets the length of this vector in 2D"},{"declaration":"float Length() const","documentation":"Gets the length of this vector"},{"declaration":"Vector opDiv(const Vector& in other) const","documentation":"Divide vectors"},{"declaration":"Vector opMul(const Vector& in other) const","documentation":"Multiply vectors"},{"declaration":"bool opEquals(const Vector& in other) const","documentation":"Compare vectors"},{"declaration":"float opIndex(size_t uiIndex) const","documentation":"Index operator"},{"declaration":"float& opIndex(size_t uiIndex)","documentation":"Index operator"},{"declaration":"Vector opDiv_r(float fl) const","documentation":"Divide vector by value"},{"declaration":"Vector opDiv(float fl) const","documentation":"Divide vector by value"},{"declaration":"Vector opMul_r(float fl) const","documentation":"Multiply vector by value"},{"declaration":"Vector opMul(float fl) const","documentation":"Multiply vector by value"},{"declaration":"Vector opSub(const Vector& in other) const","documentation":"Subtract vectors"},{"declaration":"Vector opAdd(const Vector& in other) const","documentation":"Add vectors"},{"declaration":"Vector opNeg() const","documentation":"Negate vector"},{"declaration":"Vector& opAssign(const Vector& in other)","documentation":"Assign vector"},{"declaration":"void DestructVector()","documentation":"Vector destructor"},{"declaration":"void Vector(float x, float y, float z)","documentation":"Constructs a 3D vector from 3 floats"},{"declaration":"void Vector(const Vector& in vec)","documentation":"Copy constructs a 3D vector"},{"declaration":"void Vector()","documentation":"Default constructs a 3D vector (0, 0, 0)"}],"properties":[{"namespace":"","declaration":"float z","documentation":"Vector z variable"},{"namespace":"","declaration":"float y","documentation":"Vector y variable"},{"namespace":"","declaration":"float x","documentation":"Vector x variable"}],"className":"Vector","documentation":"3D Vector","namespace":""},{"flags":131842,"methods":[{"declaration":"string ToString() const","documentation":"Returns a string representation of this vector"},{"declaration":"Vector2D Normalize() const","documentation":"Returns the normalized form of this vector"},{"declaration":"float Length() const","documentation":"Gets the length of this vector"},{"declaration":"bool opEquals(const Vector2D& in other) const","documentation":"Compare vectors"},{"declaration":"Vector2D opDiv_r(float fl) const","documentation":"Divide vector by a value"},{"declaration":"Vector2D opDiv(float fl) const","documentation":"Divide vector by a value"},{"declaration":"Vector2D opMul_r(float fl) const","documentation":"Multiply vector by a value"},{"declaration":"Vector2D opMul(float fl) const","documentation":"Multiply vector by a value"},{"declaration":"Vector2D opSub(const Vector2D& in other) const","documentation":"Subtract vectors"},{"declaration":"Vector2D opAdd(const Vector2D& in other) const","documentation":"Add vectors"},{"declaration":"Vector2D& opAssign(const Vector2D& in other)","documentation":"Assign vector"},{"declaration":"void DestructVector2D()","documentation":"Vector2D destructor"},{"declaration":"void Vector2D(float x, float y)","documentation":"Constructs a 2D vector from 2 floats"},{"declaration":"void Vector2D(const Vector2D& in other)","documentation":"Copy constructs a 2D vector"},{"declaration":"void Vector2D()","documentation":"Default constructs a 2D vector (0, 0)"}],"properties":[{"namespace":"","declaration":"float y","documentation":"Vector2D y variable"},{"namespace":"","declaration":"float x","documentation":"Vector2D x variable"}],"className":"Vector2D","documentation":"2D Vector","namespace":""},{"flags":262145,"methods":[{"declaration":"void OutputStatistics()","documentation":"Output statistics."},{"declaration":"void OutputMembers()","documentation":"Output member variables."},{"declaration":"void OutputGlobals()","documentation":"Output global variables."},{"declaration":"void OutputLocals()","documentation":"Output local variables."},{"declaration":"uint32 GetCurrentStackLevel() const","documentation":"Gets the current stack level."}],"properties":[],"className":"CDebugger","documentation":"Debugger","namespace":""},{"flags":262145,"methods":[{"declaration":"void ClearTimerList()","documentation":"Removes all queued functions from the list of functions to call."},{"declaration":"CScheduledFunction@ GetCurrentFunction() const","documentation":"Returns the function currently being executed, if any."},{"declaration":"void RemoveTimer(CScheduledFunction@ pFunction)","documentation":"Removes the given function from the list of functions to call."},{"declaration":"CScheduledFunction@ SetInterval(?& in thisObject, const string& in szFunction, float flRepeatTime, int iRepeatCount, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in)","documentation":"Adds a timer that calls the given function every flRepeatTime seconds,<br/>for iRepeatCount times (or infinite times if REPEAT_INFINITE_TIMES).<br/> Calls object methods."},{"declaration":"CScheduledFunction@ SetInterval(?& in thisObject, const string& in szFunction, float flRepeatTime, int iRepeatCount, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in)","documentation":"Adds a timer that calls the given function every flRepeatTime seconds,<br/>for iRepeatCount times (or infinite times if REPEAT_INFINITE_TIMES).<br/> Calls object methods."},{"declaration":"CScheduledFunction@ SetInterval(?& in thisObject, const string& in szFunction, float flRepeatTime, int iRepeatCount, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in)","documentation":"Adds a timer that calls the given function every flRepeatTime seconds,<br/>for iRepeatCount times (or infinite times if REPEAT_INFINITE_TIMES).<br/> Calls object methods."},{"declaration":"CScheduledFunction@ SetInterval(?& in thisObject, const string& in szFunction, float flRepeatTime, int iRepeatCount, ?& in, ?& in, ?& in, ?& in, ?& in)","documentation":"Adds a timer that calls the given function every flRepeatTime seconds,<br/>for iRepeatCount times (or infinite times if REPEAT_INFINITE_TIMES).<br/> Calls object methods."},{"declaration":"CScheduledFunction@ SetInterval(?& in thisObject, const string& in szFunction, float flRepeatTime, int iRepeatCount, ?& in, ?& in, ?& in, ?& in)","documentation":"Adds a timer that calls the given function every flRepeatTime seconds,<br/>for iRepeatCount times (or infinite times if REPEAT_INFINITE_TIMES).<br/> Calls object methods."},{"declaration":"CScheduledFunction@ SetInterval(?& in thisObject, const string& in szFunction, float flRepeatTime, int iRepeatCount, ?& in, ?& in, ?& in)","documentation":"Adds a timer that calls the given function every flRepeatTime seconds,<br/>for iRepeatCount times (or infinite times if REPEAT_INFINITE_TIMES).<br/> Calls object methods."},{"declaration":"CScheduledFunction@ SetInterval(?& in thisObject, const string& in szFunction, float flRepeatTime, int iRepeatCount, ?& in, ?& in)","documentation":"Adds a timer that calls the given function every flRepeatTime seconds,<br/>for iRepeatCount times (or infinite times if REPEAT_INFINITE_TIMES).<br/> Calls object methods."},{"declaration":"CScheduledFunction@ SetInterval(?& in thisObject, const string& in szFunction, float flRepeatTime, int iRepeatCount, ?& in)","documentation":"Adds a timer that calls the given function every flRepeatTime seconds,<br/>for iRepeatCount times (or infinite times if REPEAT_INFINITE_TIMES).<br/> Calls object methods."},{"declaration":"CScheduledFunction@ SetInterval(?& in thisObject, const string& in szFunction, float flRepeatTime, int iRepeatCount)","documentation":"Adds a timer that calls the given function every flRepeatTime seconds,<br/>for iRepeatCount times (or infinite times if REPEAT_INFINITE_TIMES).<br/> Calls object methods."},{"declaration":"CScheduledFunction@ SetInterval(const string& in szFunction, float flRepeatTime, int iRepeatCount, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in)","documentation":"Adds a timer that calls the given function every flRepeatTime seconds,<br/>for iRepeatCount times (or infinite times if REPEAT_INFINITE_TIMES)."},{"declaration":"CScheduledFunction@ SetInterval(const string& in szFunction, float flRepeatTime, int iRepeatCount, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in)","documentation":"Adds a timer that calls the given function every flRepeatTime seconds,<br/>for iRepeatCount times (or infinite times if REPEAT_INFINITE_TIMES)."},{"declaration":"CScheduledFunction@ SetInterval(const string& in szFunction, float flRepeatTime, int iRepeatCount, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in)","documentation":"Adds a timer that calls the given function every flRepeatTime seconds,<br/>for iRepeatCount times (or infinite times if REPEAT_INFINITE_TIMES)."},{"declaration":"CScheduledFunction@ SetInterval(const string& in szFunction, float flRepeatTime, int iRepeatCount, ?& in, ?& in, ?& in, ?& in, ?& in)","documentation":"Adds a timer that calls the given function every flRepeatTime seconds,<br/>for iRepeatCount times (or infinite times if REPEAT_INFINITE_TIMES)."},{"declaration":"CScheduledFunction@ SetInterval(const string& in szFunction, float flRepeatTime, int iRepeatCount, ?& in, ?& in, ?& in, ?& in)","documentation":"Adds a timer that calls the given function every flRepeatTime seconds,<br/>for iRepeatCount times (or infinite times if REPEAT_INFINITE_TIMES)."},{"declaration":"CScheduledFunction@ SetInterval(const string& in szFunction, float flRepeatTime, int iRepeatCount, ?& in, ?& in, ?& in)","documentation":"Adds a timer that calls the given function every flRepeatTime seconds,<br/>for iRepeatCount times (or infinite times if REPEAT_INFINITE_TIMES)."},{"declaration":"CScheduledFunction@ SetInterval(const string& in szFunction, float flRepeatTime, int iRepeatCount, ?& in, ?& in)","documentation":"Adds a timer that calls the given function every flRepeatTime seconds,<br/>for iRepeatCount times (or infinite times if REPEAT_INFINITE_TIMES)."},{"declaration":"CScheduledFunction@ SetInterval(const string& in szFunction, float flRepeatTime, int iRepeatCount, ?& in)","documentation":"Adds a timer that calls the given function every flRepeatTime seconds,<br/>for iRepeatCount times (or infinite times if REPEAT_INFINITE_TIMES)."},{"declaration":"CScheduledFunction@ SetInterval(const string& in szFunction, float flRepeatTime, int iRepeatCount)","documentation":"Adds a timer that calls the given function every flRepeatTime seconds,<br/>for iRepeatCount times (or infinite times if REPEAT_INFINITE_TIMES)."},{"declaration":"CScheduledFunction@ SetInterval(?& in thisObject, const string& in szFunction, float flRepeatTime)","documentation":"Adds a timer that calls the given function every flRepeatTime seconds,<br/>for iRepeatCount times (or infinite times if REPEAT_INFINITE_TIMES).<br/>The given function is called an infinite number of times.<br/> Calls object methods."},{"declaration":"CScheduledFunction@ SetInterval(const string& in szFunction, float flRepeatTime)","documentation":"Adds a timer that calls the given function every flRepeatTime seconds,<br/>for iRepeatCount times (or infinite times if REPEAT_INFINITE_TIMES).<br/>The given function is called an infinite number of times."},{"declaration":"CScheduledFunction@ SetTimeout(?& in thisObject, const string& in szFunction, float flDelay, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in)","documentation":"Adds a timer that calls the given function after flDelay seconds. Calls object methods."},{"declaration":"CScheduledFunction@ SetTimeout(?& in thisObject, const string& in szFunction, float flDelay, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in)","documentation":"Adds a timer that calls the given function after flDelay seconds. Calls object methods."},{"declaration":"CScheduledFunction@ SetTimeout(?& in thisObject, const string& in szFunction, float flDelay, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in)","documentation":"Adds a timer that calls the given function after flDelay seconds. Calls object methods."},{"declaration":"CScheduledFunction@ SetTimeout(?& in thisObject, const string& in szFunction, float flDelay, ?& in, ?& in, ?& in, ?& in, ?& in)","documentation":"Adds a timer that calls the given function after flDelay seconds. Calls object methods."},{"declaration":"CScheduledFunction@ SetTimeout(?& in thisObject, const string& in szFunction, float flDelay, ?& in, ?& in, ?& in, ?& in)","documentation":"Adds a timer that calls the given function after flDelay seconds. Calls object methods."},{"declaration":"CScheduledFunction@ SetTimeout(?& in thisObject, const string& in szFunction, float flDelay, ?& in, ?& in, ?& in)","documentation":"Adds a timer that calls the given function after flDelay seconds. Calls object methods."},{"declaration":"CScheduledFunction@ SetTimeout(?& in thisObject, const string& in szFunction, float flDelay, ?& in, ?& in)","documentation":"Adds a timer that calls the given function after flDelay seconds. Calls object methods."},{"declaration":"CScheduledFunction@ SetTimeout(?& in thisObject, const string& in szFunction, float flDelay, ?& in)","documentation":"Adds a timer that calls the given function after flDelay seconds. Calls object methods."},{"declaration":"CScheduledFunction@ SetTimeout(?& in thisObject, const string& in szFunction, float flDelay)","documentation":"Adds a timer that calls the given function after flDelay seconds. Calls object methods."},{"declaration":"CScheduledFunction@ SetTimeout(const string& in szFunction, float flDelay, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in)","documentation":"Adds a timer that calls the given function after flDelay seconds."},{"declaration":"CScheduledFunction@ SetTimeout(const string& in szFunction, float flDelay, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in)","documentation":"Adds a timer that calls the given function after flDelay seconds."},{"declaration":"CScheduledFunction@ SetTimeout(const string& in szFunction, float flDelay, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in)","documentation":"Adds a timer that calls the given function after flDelay seconds."},{"declaration":"CScheduledFunction@ SetTimeout(const string& in szFunction, float flDelay, ?& in, ?& in, ?& in, ?& in, ?& in)","documentation":"Adds a timer that calls the given function after flDelay seconds."},{"declaration":"CScheduledFunction@ SetTimeout(const string& in szFunction, float flDelay, ?& in, ?& in, ?& in, ?& in)","documentation":"Adds a timer that calls the given function after flDelay seconds."},{"declaration":"CScheduledFunction@ SetTimeout(const string& in szFunction, float flDelay, ?& in, ?& in, ?& in)","documentation":"Adds a timer that calls the given function after flDelay seconds."},{"declaration":"CScheduledFunction@ SetTimeout(const string& in szFunction, float flDelay, ?& in, ?& in)","documentation":"Adds a timer that calls the given function after flDelay seconds."},{"declaration":"CScheduledFunction@ SetTimeout(const string& in szFunction, float flDelay, ?& in)","documentation":"Adds a timer that calls the given function after flDelay seconds."},{"declaration":"CScheduledFunction@ SetTimeout(const string& in szFunction, float flDelay)","documentation":"Adds a timer that calls the given function after flDelay seconds."}],"properties":[{"namespace":"","declaration":"const int REPEAT_INFINITE_TIMES","documentation":"If passed to AddTimer, causes the given function to be called infinite times"}],"className":"CScheduler","documentation":"Scheduler for calling functions.<br/>Supports up to 8 parameters for function or method calls.","namespace":""},{"flags":1,"methods":[{"declaration":"bool HasBeenRemoved() const","documentation":"Returns whether this function has been removed from the scheduler or not"},{"declaration":"void MakeInfiniteRepeat()","documentation":"Makes this an infinite repeat function"},{"declaration":"void SetRepeatCount(const int iRepeatCount)","documentation":"Sets the repeat count. Must be a positive value (may be zero) or REPEAT_INFINITE_TIMES"},{"declaration":"bool IsInfiniteRepeat() const","documentation":"Returns whether this function repeats infinitely"},{"declaration":"int GetRepeatCount() const","documentation":"Gets the repeat count"},{"declaration":"void SetRepeatTime(const float flRepeatTime)","documentation":"Sets the repeat time, in seconds. Must be a positive value (may be zero)"},{"declaration":"float GetRepeatTime() const","documentation":"Gets the repeat time, in seconds"},{"declaration":"void SetNextCallTime(const float flNextCallTime)","documentation":"Sets the next call time, in seconds. Is an absolute value (g_Engine.time + RepeatTime by default).Times in the past will result in a call on the next frame."},{"declaration":"float GetNextCallTime() const","documentation":"Gets the next call time, in seconds"}],"properties":[],"className":"CScheduledFunction","documentation":"Handle to a scheduled function","namespace":""},{"flags":262145,"methods":[{"declaration":"void RemoveFile(const string& in szFilename)","documentation":"Removes a file."},{"declaration":"File@ OpenFile(const string& in szFilename, const OpenFileFlags_t uiOpenFlags)","documentation":"Opens a file. Returns nullptr if the file could not be opened."},{"declaration":"const FileQuota@ GetFileQuota() const","documentation":"Gets the file system quota object. Do not store a handle to this object, as it may be replaced at any time."}],"properties":[],"className":"CVirtualFileSystem","documentation":"Virtual File System","namespace":""},{"flags":1,"methods":[{"declaration":"size_t SizeLeftAfterWrite(size_t uiSizeInBytes) const","documentation":"Returns the size that is left after the given amount of bytes have been written."},{"declaration":"bool CanWriteAmount(size_t uiSizeInBytes) const","documentation":"Returns whether the given amount of bytes can be written."},{"declaration":"size_t GetSizeLeft() const","documentation":"Gets the amount of size, in bytes, left that can be written to."},{"declaration":"size_t GetSizeInUse() const","documentation":"Gets the size, in bytes, that is in use."},{"declaration":"size_t GetTotalSize() const","documentation":"Gets the total size, in bytes, that is allowed to be used by filesystems using this quota object."}],"properties":[],"className":"FileQuota","documentation":"Represents a quota that filesystems adhere to when handling write operations.","namespace":""},{"flags":1,"methods":[{"declaration":"void Write(const BLOB@ pBlob)","documentation":"Writes a blob to the file"},{"declaration":"void Write(const string& in szString)","documentation":"Writes a string to the file"},{"declaration":"BLOB@ ReadBlob()","documentation":"Reads as much as possible data into a BLOB."},{"declaration":"BLOB@ ReadBlob(size_t uiSizeInBytes, bool fCanResize = true)","documentation":"Reads a number of bytes into a BLOB."},{"declaration":"bool Read(BLOB@ pBlob)","documentation":"Reads as much as possible data into the given BLOB."},{"declaration":"bool Read(BLOB@ pBlob, size_t uiSizeInBytes)","documentation":"Reads a number of bytes into the given BLOB."},{"declaration":"void ReadLine(string& out szOutLine, const string& in szDelim = '\n')","documentation":"Reads a line from the file"},{"declaration":"string ReadCharacter()","documentation":"Reads a single character"},{"declaration":"bool EOFReached() const","documentation":"Returns whether end of file was reached"},{"declaration":"size_t Tell() const","documentation":"Tells the positon of the read/write pointer."},{"declaration":"size_t GetSize() const","documentation":"Returns the size of the file."},{"declaration":"void Remove()","documentation":"Removes the file. The file must be open, and you must have write access."},{"declaration":"void Close()","documentation":"Closes the file if it is open"},{"declaration":"bool IsOpen() const","documentation":"Returns whether the file was successfully opened"}],"properties":[],"className":"File","documentation":"File class.<br/>Is used to read from/write to files in disk.","namespace":""},{"flags":1,"methods":[{"declaration":"void Clear()","documentation":"Clears this BLOB of all data and allocated memory. All flags are reset to their default values."},{"declaration":"void ShrinkToFit()","documentation":"Shrinks this BLOB to fit the data that was written to it."},{"declaration":"void Reserve(size_t uiMinimumSize)","documentation":"Reserves the given amount of space, if needed."},{"declaration":"void Resize(size_t uiNewSize)","documentation":"Resizes this BLOB. Data may be lost because of this."},{"declaration":"bool Write(const string& in szString)","documentation":"Writes a variable length string to this BLOB. Returns true if the write succeeded."},{"declaration":"bool Write(const string& in szString, size_t uiSizeInBytes)","documentation":"Writes a fixed length string to this BLOB. Returns true if the write succeeded."},{"declaration":"bool Write(double data)","documentation":"Writes a double to this BLOB. Returns true if the write succeeded."},{"declaration":"bool Write(float data)","documentation":"Writes a float to this BLOB. Returns true if the write succeeded."},{"declaration":"bool Write(uint64 data)","documentation":"Writes a uint64 to this BLOB. Returns true if the write succeeded."},{"declaration":"bool Write(uint32 data)","documentation":"Writes a uint32 to this BLOB. Returns true if the write succeeded."},{"declaration":"bool Write(uint16 data)","documentation":"Writes a uint16 to this BLOB. Returns true if the write succeeded."},{"declaration":"bool Write(uint8 data)","documentation":"Writes a uint8 to this BLOB. Returns true if the write succeeded."},{"declaration":"bool Write(int64 data)","documentation":"Writes an int64 to this BLOB. Returns true if the write succeeded."},{"declaration":"bool Write(int32 data)","documentation":"Writes an int32 to this BLOB. Returns true if the write succeeded."},{"declaration":"bool Write(int16 data)","documentation":"Writes an int16 to this BLOB. Returns true if the write succeeded."},{"declaration":"bool Write(int8 data)","documentation":"Writes an int8 to this BLOB. Returns true if the write succeeded."},{"declaration":"bool WriteBytesUntil(size_t uiEndOffset, int iValue = 0)","documentation":"Writes a given value until the given end offset to this BLOB. Returns true if the write succeeded."},{"declaration":"bool WriteBytes(size_t uiSizeInBytes, int iValue = 0)","documentation":"Writes a given value a number of bytes to this BLOB. Returns true if the write succeeded."},{"declaration":"string ReadString()","documentation":"Reads a variable length string from this BLOB."},{"declaration":"string ReadString(bool& out fSuccess)","documentation":"Reads a variable length string from this BLOB. fSuccess is true if the read succeeded."},{"declaration":"string ReadString(size_t uiSizeInBytes, bool& out fSuccess)","documentation":"Reads a fixed length string from this BLOB. fSuccess is true if the read succeeded."},{"declaration":"string ReadString(size_t uiSizeInBytes)","documentation":"Reads a fixed length string from this BLOB."},{"declaration":"double ReadDouble(bool& out fSuccess)","documentation":"Reads a double from this BLOB. fSuccess is true if the read succeeded."},{"declaration":"float ReadFloat(bool& out fSuccess)","documentation":"Reads a float from this BLOB. fSuccess is true if the read succeeded."},{"declaration":"int64 ReadUInt64(bool& out fSuccess)","documentation":"Reads a uint64 from this BLOB. fSuccess is true if the read succeeded."},{"declaration":"int32 ReadUInt32(bool& out fSuccess)","documentation":"Reads a uint32 from this BLOB. fSuccess is true if the read succeeded."},{"declaration":"int16 ReadUInt16(bool& out fSuccess)","documentation":"Reads a uint16 from this BLOB. fSuccess is true if the read succeeded."},{"declaration":"uint8 ReadUInt8(bool& out fSuccess)","documentation":"Reads a uint8 from this BLOB. fSuccess is true if the read succeeded."},{"declaration":"int64 ReadInt64(bool& out fSuccess)","documentation":"Reads an int64 from this BLOB. fSuccess is true if the read succeeded."},{"declaration":"int32 ReadInt32(bool& out fSuccess)","documentation":"Reads an int32 from this BLOB. fSuccess is true if the read succeeded."},{"declaration":"int16 ReadInt16(bool& out fSuccess)","documentation":"Reads an int16 from this BLOB. fSuccess is true if the read succeeded."},{"declaration":"int8 ReadInt8(bool& out fSuccess)","documentation":"Reads an int8 from this BLOB. fSuccess is true if the read succeeded."},{"declaration":"double ReadDouble()","documentation":"Reads a double from this BLOB."},{"declaration":"float ReadFloat()","documentation":"Reads a float from this BLOB."},{"declaration":"int64 ReadUInt64()","documentation":"Reads a uint64 from this BLOB."},{"declaration":"int32 ReadUInt32()","documentation":"Reads a uint32 from this BLOB."},{"declaration":"int16 ReadUInt16()","documentation":"Reads a uint16 from this BLOB."},{"declaration":"uint8 ReadUInt8()","documentation":"Reads a uint8 from this BLOB."},{"declaration":"int64 ReadInt64()","documentation":"Reads an int64 from this BLOB."},{"declaration":"int32 ReadInt32()","documentation":"Reads an int32 from this BLOB."},{"declaration":"int16 ReadInt16()","documentation":"Reads an int16 from this BLOB."},{"declaration":"int8 ReadInt8()","documentation":"Reads an int8 from this BLOB."},{"declaration":"void SetCanResize(bool fState)","documentation":"Sets whether this BLOB is allowed to resize its buffer."},{"declaration":"bool CanResize() const","documentation":"Returns whether this BLOB is allowed to resize its buffer."},{"declaration":"size_t GetWriteBytesLeft() const","documentation":"Gets the number of bytes left that can be written to. This may change if a write operation causes the buffer to be resized."},{"declaration":"bool CanWriteSize(size_t uiSizeInBytes) const","documentation":"Returns whether the given amount of bytes can be written to this BLOB."},{"declaration":"size_t GetWriteOffset() const","documentation":"Gets the write offset, in bytes. This is the number of bytes written to this buffer."},{"declaration":"bool ReadSizeValid(size_t uiSizeInBytes) const","documentation":"Returns whether the given amount of bytes can be read from this BLOB."},{"declaration":"bool ReadReachedEnd() const","documentation":"Returns whether the last read operation reached the end of data that was written to this BLOB."},{"declaration":"size_t GetReadOffset() const","documentation":"Gets the read offset, in bytes."},{"declaration":"size_t GetSizeInBytes() const","documentation":"Gets the size of this BLOB, in bytes."},{"declaration":"bool HasAllocatedBuffer() const","documentation":"Returns whether this instance has allocated a buffer."}],"properties":[],"className":"BLOB","documentation":"Binary Large OBject class used for storing arbitrary amounts of binary data.","namespace":""},{"flags":1,"methods":[{"declaration":"void Swap(MatchResults@ other)","documentation":"Swaps these match results with the given results."},{"declaration":"string Format(const string& in szFormat, MatchFlagType flags = Regex::match_default) const","documentation":"Gets the length of the given submatch"},{"declaration":"string GetString(size_t uiIndex = 0) const","documentation":"Gets the given submatch as a string"},{"declaration":"int GetPosition(size_t uiIndex = 0) const","documentation":"Gets the position of the given submatch"},{"declaration":"int GetLength(size_t uiIndex = 0) const","documentation":"Gets the length of the given submatch"},{"declaration":"SubMatch GetSuffix() const","documentation":"Gets the suffix submatch"},{"declaration":"SubMatch GetPrefix() const","documentation":"Gets the prefix submatch"},{"declaration":"SubMatch opIndex(size_t uiIndex) const","documentation":"Returns the sub match object at the given index"},{"declaration":"size_t GetMaxSize() const","documentation":"Returns the maximum size"},{"declaration":"size_t GetSize() const","documentation":"Returns the number of matches"},{"declaration":"bool IsEmpty() const","documentation":"Returns whether this match results object is empty or not"},{"declaration":"MatchResults@ MatchResults(const MatchResults@ pOther)","documentation":"Copy constructor"},{"declaration":"MatchResults@ MatchResults()","documentation":"Constructor"}],"properties":[],"className":"MatchResults","documentation":"Regular expression match results","namespace":"Regex"},{"flags":5378,"methods":[{"declaration":"int Compare(const string& in szString) const","documentation":"Compares this submatch to a string"},{"declaration":"int Compare(const SubMatch& in other) const","documentation":"Compares this submatch to another"},{"declaration":"string GetString() const","documentation":"Gets this submatch as a string"},{"declaration":"int GetLength() const","documentation":"Gets the length of the submatch"},{"declaration":"void DestructSubMatch()","documentation":"Destructor"},{"declaration":"void SubMatch(const SubMatch& in other)","documentation":"Copy constructor"},{"declaration":"void SubMatch()","documentation":"Constructor. Do not use."}],"properties":[],"className":"SubMatch","documentation":"Regular expression submatch","namespace":"Regex"},{"flags":1,"methods":[{"declaration":"void Swap(Regex@ other)","documentation":"Swaps this regular expression's contents with the given expression"},{"declaration":"FlagType GetFlags() const","documentation":"Gets this regex's flags"},{"declaration":"uint GetMarkCount() const","documentation":"Gets the mark count"},{"declaration":"Regex& Assign(const string& in szExpression, FlagType flags = Regex::ECMAScript)","documentation":"Assigns the given regular expression to this one."},{"declaration":"Regex& Assign(const Regex@ pOther)","documentation":"Assigns the given regular expression to this one."},{"declaration":"Regex@ Regex(const string& in szExpression, FlagType flags = Regex::ECMAScript)","documentation":"Initialization Constructor"},{"declaration":"Regex@ Regex(const Regex@ pOther)","documentation":"Copy Constructor"},{"declaration":"Regex@ Regex()","documentation":"Default Constructor"}],"properties":[],"className":"Regex","documentation":"Represents a regular expression","namespace":"Regex"},{"flags":262145,"methods":[],"properties":[{"namespace":"","declaration":"IReflectionGroup Module","documentation":"Module group."},{"namespace":"","declaration":"IReflectionGroup Engine","documentation":"Engine group."}],"className":"CReflection","documentation":"Reflection global used for generial purpose needs.","namespace":"Reflection"},{"flags":262145,"methods":[{"declaration":"ObjectType@ GetObjectTypeByIndex(uint uiIndex) const","documentation":"Gets the object type at the given index."},{"declaration":"uint GetObjectTypeCount() const","documentation":"Gets the number of object types."},{"declaration":"ObjectType@ FindObjectType(const string& in szName, bool fSearchByDecl = false)","documentation":"Finds an object type. Searches by name by default, searches by declaration if fSearchByDecl is set to true."},{"declaration":"Function@ GetGlobalFunctionByIndex(uint uiIndex)","documentation":"Gets the global function at the given index."},{"declaration":"uint GetGlobalFunctionCount() const","documentation":"Gets the number of global functions."},{"declaration":"Function@ FindGlobalFunction(const string& in szName, bool fSearchByDecl = false)","documentation":"Finds a global function. Searches by name by default, searches by declaration if fSearchByDecl is set to true."}],"properties":[],"className":"IReflectionGroup","documentation":"Reflection group. Represents a group of reflectable objects.","namespace":"Reflection"},{"flags":1,"methods":[{"declaration":"bool DerivesFrom(const ObjectType@ pObjectType) const","documentation":"Returns whether this object derives from the given type"},{"declaration":"bool DerivesFrom(const string& in szName) const","documentation":"Returns whether this object derives from the given type"},{"declaration":"bool IsCompatible(const ObjectType@ pObjectType) const","documentation":"Returns whether the given object type is compatible with this one."},{"declaration":"bool Equals(const ObjectType@ pObjectType) const","documentation":"Returns whether the given object type is identical to this one."},{"declaration":"bool MethodExists(const string& in szFunctionSignature)","documentation":"Gets a method by declaration"},{"declaration":"Method@ GetMethod(const string& in szFunctionSignature)","documentation":"Gets a method by declaration"},{"declaration":"Method@ GetMethodByIndex(uint uiIndex) const","documentation":"Gets the method at the given index"},{"declaration":"uint GetMethodCount() const","documentation":"Gets the number of methods this object type has"}],"properties":[],"className":"ObjectType","documentation":"Represents an object type","namespace":"Reflection"},{"flags":1,"methods":[{"declaration":"ReturnValue@ Call(?& in thisObject, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in)","documentation":"Calls this method."},{"declaration":"ReturnValue@ Call(?& in thisObject, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in)","documentation":"Calls this method."},{"declaration":"ReturnValue@ Call(?& in thisObject, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in)","documentation":"Calls this method."},{"declaration":"ReturnValue@ Call(?& in thisObject, ?& in, ?& in, ?& in, ?& in, ?& in)","documentation":"Calls this method."},{"declaration":"ReturnValue@ Call(?& in thisObject, ?& in, ?& in, ?& in, ?& in)","documentation":"Calls this method."},{"declaration":"ReturnValue@ Call(?& in thisObject, ?& in, ?& in, ?& in)","documentation":"Calls this method."},{"declaration":"ReturnValue@ Call(?& in thisObject, ?& in, ?& in)","documentation":"Calls this method."},{"declaration":"ReturnValue@ Call(?& in thisObject, ?& in)","documentation":"Calls this method."},{"declaration":"ReturnValue@ Call(?& in thisObject)","documentation":"Calls this method."},{"declaration":"ReturnValue@ Call(?& in thisObject, Arguments@ pArguments)","documentation":"Calls this method. pArguments must be valid."},{"declaration":"bool IsCompatible(const Callable@ pCallable) const","documentation":"Returns whether the given object type is compatible with this one."},{"declaration":"bool Equals(const Callable@ pCallable) const","documentation":"Returns whether the given callable type is identical to this one."},{"declaration":"string GetName() const","documentation":"Gets this instance's name"},{"declaration":"string GetNamespace() const","documentation":"Gets this instance's namespace"},{"declaration":"Callable@ opImplCast()","documentation":"Implicitly casts to base type."}],"properties":[],"className":"Method","documentation":"Reflection method class. Can be used to call object methods.","namespace":"Reflection"},{"flags":1,"methods":[{"declaration":"ReturnValue@ Call(?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in)","documentation":"Calls this function."},{"declaration":"ReturnValue@ Call(?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in)","documentation":"Calls this function."},{"declaration":"ReturnValue@ Call(?& in, ?& in, ?& in, ?& in, ?& in, ?& in)","documentation":"Calls this function."},{"declaration":"ReturnValue@ Call(?& in, ?& in, ?& in, ?& in, ?& in)","documentation":"Calls this function."},{"declaration":"ReturnValue@ Call(?& in, ?& in, ?& in, ?& in)","documentation":"Calls this function."},{"declaration":"ReturnValue@ Call(?& in, ?& in, ?& in)","documentation":"Calls this function."},{"declaration":"ReturnValue@ Call(?& in, ?& in)","documentation":"Calls this function."},{"declaration":"ReturnValue@ Call(?& in)","documentation":"Calls this function."},{"declaration":"ReturnValue@ Call()","documentation":"Calls this function."},{"declaration":"ReturnValue@ Call(Arguments@ pArguments)","documentation":"Calls this function. pArguments must be valid."},{"declaration":"bool IsCompatible(const Callable@ pCallable) const","documentation":"Returns whether the given object type is compatible with this one."},{"declaration":"bool Equals(const Callable@ pCallable) const","documentation":"Returns whether the given callable type is identical to this one."},{"declaration":"string GetName() const","documentation":"Gets this instance's name"},{"declaration":"string GetNamespace() const","documentation":"Gets this instance's namespace"},{"declaration":"Callable@ opImplCast()","documentation":"Implicitly casts to base type."}],"properties":[],"className":"Function","documentation":"Reflection function class. Can be used to call global functions.","namespace":"Reflection"},{"flags":1,"methods":[{"declaration":"Method@ opCast()","documentation":"Explicitly casts to sub type."},{"declaration":"Function@ opCast()","documentation":"Explicitly casts to sub type."},{"declaration":"bool IsCompatible(const Callable@ pCallable) const","documentation":"Returns whether the given object type is compatible with this one."},{"declaration":"bool Equals(const Callable@ pCallable) const","documentation":"Returns whether the given callable type is identical to this one."},{"declaration":"string GetName() const","documentation":"Gets this instance's name"},{"declaration":"string GetNamespace() const","documentation":"Gets this instance's namespace"}],"properties":[],"className":"Callable","documentation":"Reflection base class for callable objects.","namespace":"Reflection"},{"flags":1,"methods":[{"declaration":"any@ ToAny() const","documentation":"Returns the return value as an any instance, if there was a return value."},{"declaration":"bool HasReturnValue() const","documentation":"Returns whether there is a return value or not."}],"properties":[],"className":"ReturnValue","documentation":"Reflection return value.","namespace":"Reflection"},{"flags":1,"methods":[{"declaration":"bool SetArguments(?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in)","documentation":"Sets the arguments this instance contains."},{"declaration":"bool SetArguments(?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in)","documentation":"Sets the arguments this instance contains."},{"declaration":"bool SetArguments(?& in, ?& in, ?& in, ?& in, ?& in, ?& in)","documentation":"Sets the arguments this instance contains."},{"declaration":"bool SetArguments(?& in, ?& in, ?& in, ?& in, ?& in)","documentation":"Sets the arguments this instance contains."},{"declaration":"bool SetArguments(?& in, ?& in, ?& in, ?& in)","documentation":"Sets the arguments this instance contains."},{"declaration":"bool SetArguments(?& in, ?& in, ?& in)","documentation":"Sets the arguments this instance contains."},{"declaration":"bool SetArguments(?& in, ?& in)","documentation":"Sets the arguments this instance contains."},{"declaration":"bool SetArguments(?& in)","documentation":"Sets the arguments this instance contains."},{"declaration":"bool SetArguments()","documentation":"Sets the arguments this instance contains."},{"declaration":"void Clear()","documentation":"Clears this instance's data."},{"declaration":"bool HasArguments() const","documentation":"Returns whether this instance holds any arguments."},{"declaration":"size_t GetCount() const","documentation":"Get number of arguments"},{"declaration":"Arguments& opAssign(const Arguments& in other)","documentation":"Assignment operator"},{"declaration":"Arguments@ Arguments(?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in)","documentation":"Constructs a Arguments instance with the given arguments."},{"declaration":"Arguments@ Arguments(?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in)","documentation":"Constructs a Arguments instance with the given arguments."},{"declaration":"Arguments@ Arguments(?& in, ?& in, ?& in, ?& in, ?& in, ?& in)","documentation":"Constructs a Arguments instance with the given arguments."},{"declaration":"Arguments@ Arguments(?& in, ?& in, ?& in, ?& in, ?& in)","documentation":"Constructs a Arguments instance with the given arguments."},{"declaration":"Arguments@ Arguments(?& in, ?& in, ?& in, ?& in)","documentation":"Constructs a Arguments instance with the given arguments."},{"declaration":"Arguments@ Arguments(?& in, ?& in, ?& in)","documentation":"Constructs a Arguments instance with the given arguments."},{"declaration":"Arguments@ Arguments(?& in, ?& in)","documentation":"Constructs a Arguments instance with the given arguments."},{"declaration":"Arguments@ Arguments(?& in)","documentation":"Constructs a Arguments instance with the given arguments."},{"declaration":"Arguments@ Arguments()","documentation":"Constructs a Arguments instance with the given arguments."},{"declaration":"Arguments@ Arguments(const Arguments& in other)","documentation":"Copy constructor"},{"declaration":"Arguments@ Arguments()","documentation":"Default constructor"}],"properties":[],"className":"Arguments","documentation":"This class can hold arguments for a function or method call.","namespace":"Reflection"},{"flags":10,"methods":[{"declaration":"string opImplConv() const","documentation":"Converts this string_t to a string"},{"declaration":"string_t& opAssign(const string& in str)","documentation":"Assignment operator"},{"declaration":"string_t& opAssign(const string_t& in str)","documentation":"Assignment operator"},{"declaration":"void string_t(const string& in str)","documentation":"Copy Constructor"},{"declaration":"void string_t(const string_t& in str)","documentation":"Copy Constructor"},{"declaration":"void string_t()","documentation":"Default Constructor"}],"properties":[],"className":"string_t","documentation":"Opaque handle to a pooled string.","namespace":""},{"flags":8202,"methods":[{"declaration":"bool opEquals(const string& in szString) const","documentation":"Compares this char with the given character"},{"declaration":"char opAssign(const string& in szString)","documentation":"Assigns the first character of the given string to this character"},{"declaration":"char opAssign(const char& in character)","documentation":"Assigns one character to another"},{"declaration":"void char()","documentation":"Destructor"},{"declaration":"void char(const string& in szString)","documentation":"Copy constructs a char"},{"declaration":"void char(const char& in character)","documentation":"Copy constructs a char"},{"declaration":"void char()","documentation":"Default constructs a char"}],"properties":[],"className":"char","documentation":"Char value type","namespace":""},{"flags":7938,"methods":[{"declaration":"array<string>@ Split(const string& in szDelimiter) const","documentation":"Splits this string by the given delimiter"},{"declaration":"string opAdd(char character) const","documentation":"Returns a copy of this string with the given character appended"},{"declaration":"string opAdd(bool bValue) const","documentation":"Returns a copy of this string with the given boolean appended"},{"declaration":"string opAdd(uint64 uiValue) const","documentation":"Returns a copy of this string with the given 64 bit unsigned integer appended"},{"declaration":"string opAdd(int64 iValue) const","documentation":"Returns a copy of this string with the given 64 bit integer appended"},{"declaration":"string opAdd(double flValue) const","documentation":"Returns a copy of this string with the given double appended"},{"declaration":"string opAdd(const string& in szString) const","documentation":"Returns a copy of this string with the given string appended"},{"declaration":"void Truncate(const size_t uiMaxLength)","documentation":"Truncates the string to uiMaxLength characters"},{"declaration":"string& Replace(const string& in szSubstring, const string& in szReplacement, const String::CompareType compareType = String::DEFAULT_COMPARE)","documentation":"Replaces the given substring with the given replacement string"},{"declaration":"string SubString(uint startIndex = 0, uint count = String::INVALID_INDEX) const","documentation":"Returns a substring of this string"},{"declaration":"string& ToUppercase()","documentation":"Converts this string to upper case"},{"declaration":"string& ToLowercase()","documentation":"Converts this string to lower case"},{"declaration":"uint FindLastNotOf(const string& in szString, uint startIndex = String::INVALID_INDEX, const String::CompareType compareType = String::DEFAULT_COMPARE) const","documentation":"Find the first instance of the given string, searching in reverse"},{"declaration":"uint FindFirstNotOf(const string& in szString, uint startIndex = 0, const String::CompareType compareType = String::DEFAULT_COMPARE) const","documentation":"Find the first instance of the given string"},{"declaration":"uint FindLastOf(const string& in szString, const uint startIndex = 0, const String::CompareType compareType = String::DEFAULT_COMPARE) const","documentation":"Find the last instance of any character in the given string"},{"declaration":"uint FindFirstOf(const string& in szString, const uint startIndex = 0, const String::CompareType compareType = String::DEFAULT_COMPARE) const","documentation":"Find the first instance of any character in the given string"},{"declaration":"uint RFind(const string& in szString, uint startIndex = String::INVALID_INDEX, const String::CompareType compareType = String::DEFAULT_COMPARE) const","documentation":"Find the first instance of the given string, searching in reverse"},{"declaration":"uint Find(const string& in szString, const uint startIndex = 0, const String::CompareType compareType = String::DEFAULT_COMPARE) const","documentation":"Find the first instance of the given string"},{"declaration":"bool EndsWith(const string& in szString, const String::CompareType compareType = String::DEFAULT_COMPARE) const","documentation":"Returns true if the string ends with the given string"},{"declaration":"bool StartsWith(const string& in szString, const String::CompareType compareType = String::DEFAULT_COMPARE) const","documentation":"Returns true if the string starts with the given string"},{"declaration":"void Trim(const string& in szCharacter = ' ')","documentation":"Trims leading and trailing whitespace, or a given character."},{"declaration":"bool opEquals(const string& in szString) const","documentation":"Returns whether strings are equal"},{"declaration":"int ICompareN(const string& in szString, const uint amount) const","documentation":"Compares strings up to amount characters case-insensitively"},{"declaration":"int ICompare(const string& in szString) const","documentation":"Compares strings case-insensitively"},{"declaration":"int CompareN(const string& in szString, const uint amount) const","documentation":"Compares strings up to amount characters"},{"declaration":"int Compare(const string& in szString) const","documentation":"Compares strings"},{"declaration":"int opCmp(const string& in szString) const","documentation":"Compares strings"},{"declaration":"string& opAddAssign(char character)","documentation":"Appends the given character to this string"},{"declaration":"string& opAddAssign(bool bValue)","documentation":"Appends the given boolean to this string"},{"declaration":"string& opAddAssign(uint64 uiValue)","documentation":"Appends the given 64 bit unsigned integer to this string"},{"declaration":"string& opAddAssign(int64 iValue)","documentation":"Appends the given 64 bit integer to this string"},{"declaration":"string& opAddAssign(double flValue)","documentation":"Appends the given double to this string"},{"declaration":"string& opAddAssign(const string& in szString)","documentation":"Appends the given string to this one"},{"declaration":"void SetCharAt(uint uiIndex, char character) const","documentation":"Sets a character by index"},{"declaration":"char opIndex(uint uiIndex) const","documentation":"Gets a character by index"},{"declaration":"void Clear()","documentation":"Clears the contents of this string"},{"declaration":"void Reserve(uint iMinimum, bool bKeepData = true)","documentation":"Reserves at least iMinimum characters worth of capacity. If bKeepData is true, the original string is kept."},{"declaration":"void Resize(uint uiSize, bool bKeepData = true)","documentation":"Shrinks this string to uiSize. If bKeepData is true, the original string is kept."},{"declaration":"bool IsEmpty() const","documentation":"Returns whether this string is empty"},{"declaration":"uint Length() const","documentation":"Gets the length of this string"},{"declaration":"string& opAssign(char character)","documentation":"Assigns a character to this string"},{"declaration":"string& opAssign(bool bValue)","documentation":"Assigns a boolean to this string"},{"declaration":"string& opAssign(uint64 uiValue)","documentation":"Assigns a 64 bit unsigned int to this string"},{"declaration":"string& opAssign(int64 iValue)","documentation":"Assigns a 64 bit integer to this string"},{"declaration":"string& opAssign(double flValue)","documentation":"Assigns a double to this string"},{"declaration":"string& opAssign(const string& in szString)","documentation":"Assigns a string to this one"},{"declaration":"string& Assign(const string& in szString, uint uiBegin, uint uiCount)","documentation":"Assigns a string to this, copying up to uiCount characters"},{"declaration":"void Destructstring()","documentation":"Destructor"},{"declaration":"void string(char character)","documentation":"Construct a string from a char"},{"declaration":"void string(bool bValue)","documentation":"Construct a string from a boolean"},{"declaration":"void string(uint64 uiValue)","documentation":"Construct a string from a 64 bit unsigned integer"},{"declaration":"void string(int64 iValue)","documentation":"Construct a string from a 64 bit integer"},{"declaration":"void string(double flValue)","documentation":"Construct a string from a double"},{"declaration":"void string(const string& in szString)","documentation":"Copy constructs a string"},{"declaration":"void string()","documentation":"Default constructs a string"}],"properties":[],"className":"string","documentation":"String type","namespace":""}],"enums":[{"documentation":"Hook function return codes.","name":"HookReturnCode","namespace":"","values":[{"documentation":"Returned when a hook function has handled the call","name":"HOOK_HANDLED"},{"documentation":"Returned when a hook function has not handled the call","name":"HOOK_CONTINUE"}]},{"documentation":"Type of say the client used","name":"ClientSayType","namespace":"","values":[{"documentation":"Say team","name":"CLIENTSAY_SAYTEAM"},{"documentation":"Say","name":"CLIENTSAY_SAY"}]},{"documentation":"Console command flags","name":"ConCommandFlag","namespace":"ConCommandFlag","values":[{"documentation":"If set, the invoking player (if any) must have cheat access.","name":"Cheat"},{"documentation":"If set, the invoking player (if any) must have admin access.","name":"AdminOnly"},{"documentation":"No flags to set","name":"None"}]},{"documentation":"Console command kind.","name":"Type","namespace":"ConCommandKind","values":[{"documentation":"This console command is a cvar","name":"CVar"},{"documentation":"This console command is a client command","name":"ClientCommand"},{"documentation":"This console command is a command","name":"ConCommand"}]},{"documentation":"Network message types","name":"NetworkMessageType","namespace":"NetworkMessages","values":[{"documentation":"User message","name":"ViewMode"},{"documentation":"User message","name":"InvRemove"},{"documentation":"User message","name":"InvAdd"},{"documentation":"User message","name":"PrintKB"},{"documentation":"User message","name":"Fog"},{"documentation":"User message","name":"CameraMouse"},{"documentation":"User message","name":"WeatherFX"},{"documentation":"User message","name":"ServerBuild"},{"documentation":"User message","name":"ServerVer"},{"documentation":"User message","name":"TeamNames"},{"documentation":"User message","name":"ServerName"},{"documentation":"User message","name":"VGUIMenu"},{"documentation":"User message","name":"Playlist"},{"documentation":"User message","name":"ShieldRic"},{"documentation":"User message","name":"RampSprite"},{"documentation":"User message","name":"SRPrimedOff"},{"documentation":"User message","name":"SRPrimed"},{"documentation":"User message","name":"SRDetonate"},{"documentation":"User message","name":"TracerDecal"},{"documentation":"User message","name":"SporeTrail"},{"documentation":"User message","name":"GargSplash"},{"documentation":"User message","name":"CreateBlood"},{"documentation":"User message","name":"ShkFlash"},{"documentation":"User message","name":"ToxicCloud"},{"documentation":"User message","name":"SoundList"},{"documentation":"User message","name":"StartSound"},{"documentation":"User message","name":"NextMap"},{"documentation":"User message","name":"VoteMenu"},{"documentation":"User message","name":"EndVote"},{"documentation":"User message","name":"CbElec"},{"documentation":"User message","name":"MapList"},{"documentation":"User message","name":"TimeEnd"},{"documentation":"User message","name":"Speaksent"},{"documentation":"User message","name":"TE_CUSTOM"},{"documentation":"User message","name":"Spectator"},{"documentation":"User message","name":"Gib"},{"documentation":"User message","name":"AmmoX"},{"documentation":"User message","name":"ScreenFade"},{"documentation":"User message","name":"ScreenShake"},{"documentation":"User message","name":"ShowMenu"},{"documentation":"User message","name":"SetFOV"},{"documentation":"User message","name":"HideWeapon"},{"documentation":"User message","name":"ItemPickup"},{"documentation":"User message","name":"WeapPickup"},{"documentation":"User message","name":"AmmoPickup"},{"documentation":"User message","name":"MOTD"},{"documentation":"User message","name":"GameMode"},{"documentation":"User message","name":"TeamScore"},{"documentation":"User message","name":"TeamInfo"},{"documentation":"User message","name":"ScoreInfo"},{"documentation":"User message","name":"DeathMsg"},{"documentation":"User message","name":"GameTitle"},{"documentation":"User message","name":"CdAudio"},{"documentation":"User message","name":"InitHUD"},{"documentation":"User message","name":"ResetHUD"},{"documentation":"User message","name":"CustWeapon"},{"documentation":"User message","name":"WeaponList"},{"documentation":"User message","name":"TextMsg"},{"documentation":"User message","name":"SayText"},{"documentation":"User message","name":"HudText"},{"documentation":"User message","name":"Train"},{"documentation":"User message","name":"Battery"},{"documentation":"User message","name":"Damage"},{"documentation":"User message","name":"Health"},{"documentation":"User message","name":"FlashBat"},{"documentation":"User message","name":"Flashlight"},{"documentation":"User message","name":"Geiger"},{"documentation":"User message","name":"CurWeapon"},{"documentation":"User message","name":"SelAmmo"},{"documentation":"Enables intermission for clients.","name":"SVC_INTERMISSION"},{"documentation":"Creates temporary entities on the client side.","name":"SVC_TEMPENTITY"}]},{"documentation":"Temporary entity types. Used in network messages of type SVC_TEMPENTITY.","name":"TempEntityType","namespace":"","values":[{"documentation":"Larger message than the standard tracer, but allows some customization.","name":"TE_USERTRACER"},{"documentation":"Much more compact shotgun message","name":"TE_MULTIGUNSHOT"},{"documentation":"Will expire all TENTS attached to a player.","name":"TE_KILLPLAYERATTACHMENTS"},{"documentation":"Attaches a TENT to a player (this is a high-priority tent)","name":"TE_PLAYERATTACHMENT"},{"documentation":"Makes a field of fire.","name":"TE_FIREFIELD"},{"documentation":"Very similar to lavasplash.","name":"TE_PARTICLEBURST"},{"documentation":"Sprites emit from a player's bounding box (ONLY use for players!)","name":"TE_PLAYERSPRITES"},{"documentation":"Throws a shower of sprites or models","name":"TE_SPRAY"},{"documentation":"Makes a projectile (like a nail) (this is a high-priority tent)","name":"TE_PROJECTILE"},{"documentation":"Same as TE_DECAL, but the texture index was greater than 256","name":"TE_DECALHIGH"},{"documentation":"Decal (with texture index > 256) applied to world brush","name":"TE_WORLDDECALHIGH"},{"documentation":"Decal applied to the world brush","name":"TE_WORLDDECAL"},{"documentation":"Spray of opaque sprite1's that fall, single sprite2 for 1..2 secs (this is a high-priority tent)","name":"TE_BLOODSPRITE"},{"documentation":"Create alpha sprites along a line, float upwards","name":"TE_BUBBLETRAIL"},{"documentation":"Create alpha sprites inside of box, float upwards","name":"TE_BUBBLES"},{"documentation":"Draw a player decal (spray paint)","name":"TE_PLAYERDECAL"},{"documentation":"Quick spark sprite, client ricochet sound. ","name":"TE_ARMOR_RICOCHET"},{"documentation":"Spray of alpha sprites","name":"TE_SPRITE_SPRAY"},{"documentation":"Decal and ricochet sound","name":"TE_GUNSHOTDECAL"},{"documentation":"Box of models or sprites","name":"TE_BREAKMODEL"},{"documentation":"Spherical shower of models, picks from sets","name":"TE_EXPLODEMODEL"},{"documentation":"Create a moving model that bounces and makes a sound when it hits","name":"TE_MODEL"},{"documentation":"Create alpha sprites inside of entity, float upwards","name":"TE_FIZZ"},{"documentation":"Decal applied to a brush entity (not the world)","name":"TE_DECAL"},{"documentation":"Particle spray","name":"TE_BLOOD"},{"documentation":"Line of particles every 5 units, dies in 30 seconds","name":"TE_SHOWLINE"},{"documentation":"Particle spray","name":"TE_BLOODSTREAM"},{"documentation":"Creates a large funnel","name":"TE_LARGEFUNNEL"},{"documentation":"Kill all beams attached to entity","name":"TE_KILLBEAM"},{"documentation":"Draws a box","name":"TE_BOX"},{"documentation":"Draws a line","name":"TE_LINE"},{"documentation":"Text message","name":"TE_TEXTMESSAGE"},{"documentation":"Point entity light, no world effect","name":"TE_ELIGHT"},{"documentation":"Dynamic light effect","name":"TE_DLIGHT"},{"documentation":"Oriented shower of tracers","name":"TE_STREAK_SPLASH"},{"documentation":"Connect a beam ring to two entities","name":"TE_BEAMRING"},{"documentation":"Glowing sprite","name":"TE_GLOWSPRITE"},{"documentation":"Create a line of decaying beam segments until entity stops moving","name":"TE_BEAMFOLLOW"},{"documentation":"Cylinder that expands to max radius over lifetime","name":"TE_BEAMCYLINDER"},{"documentation":"Disk that expands to max radius over lifetime","name":"TE_BEAMDISK"},{"documentation":"Screen aligned beam ring, expands to max radius over lifetime","name":"TE_BEAMTORUS"},{"documentation":"A beam with a sprite at the end","name":"TE_BEAMSPRITE"},{"documentation":"Additive sprite, plays 1 cycle","name":"TE_SPRITE"},{"documentation":"Line of moving glow sprites with gravity, fadeout, and collisions","name":"TE_SPRITETRAIL"},{"documentation":"Tracers moving toward a point","name":"TE_IMPLOSION"},{"documentation":"Decal from the .BSP file ","name":"TE_BSPDECAL"},{"documentation":"Explosion effect","name":"TE_EXPLOSION2"},{"documentation":"Teleport effect","name":"TE_TELEPORT"},{"documentation":"Lava splash effect","name":"TE_LAVASPLASH"},{"documentation":"Spark effect","name":"TE_SPARKS"},{"documentation":"Beam effect between two entities","name":"TE_BEAMENTS"},{"documentation":"TE_BEAMPOINTS with simplified parameters","name":"TE_LIGHTNING"},{"documentation":"Tracer effect from point to point","name":"TE_TRACER"},{"documentation":"Alphablend sprite, move vertically 30 pps","name":"TE_SMOKE"},{"documentation":"Quake1 \"tarbaby\" explosion with sound","name":"TE_TAREXPLOSION"},{"documentation":"Additive sprite, 2 dynamic lights, flickering particles, explosion sound, move vertically 8 pps","name":"TE_EXPLOSION"},{"documentation":"Particle effect plus ricochet sound","name":"TE_GUNSHOT"},{"documentation":"Beam effect between point and entity","name":"TE_BEAMENTPOINT"},{"documentation":"Beam effect between two points","name":"TE_BEAMPOINTS"}]},{"documentation":"TE_FIREFIELD flags","name":"TE_FireFieldFlag","namespace":"","values":[{"documentation":"If set, sprite is rendered non-opaque with additive","name":"TEFIRE_FLAG_ADDITIVE"},{"documentation":"If set, all fire sprites have same initial Z instead of randomly filling a cube. ","name":"TEFIRE_FLAG_PLANAR"},{"documentation":"If set, sprite is rendered alpha blended at 50% else, opaque","name":"TEFIRE_FLAG_ALPHA"},{"documentation":"If set, sprite plays at 15 fps, otherwise plays at whatever rate stretches the animation over the sprite's duration.","name":"TEFIRE_FLAG_LOOP"},{"documentation":"Some of the sprites will drift upwards. (50% chance)","name":"TEFIRE_FLAG_SOMEFLOAT"},{"documentation":"All sprites will drift upwards as they animate","name":"TEFIRE_FLAG_ALLFLOAT"}]},{"documentation":"TE_EXPLOSION flags","name":"TE_ExplosionFlag","namespace":"","values":[{"documentation":"Do not draw particles","name":"TE_EXPLFLAG_NOPARTICLES"},{"documentation":"Do not play client explosion sound","name":"TE_EXPLFLAG_NOSOUND"},{"documentation":"Do not render dynamic lights","name":"TE_EXPLFLAG_NODLIGHTS"},{"documentation":"Sprite will be drawn opaque (ensure that the sprite you send is a non-additive sprite)","name":"TE_EXPLFLAG_NOADDITIVE"},{"documentation":"All flags clear makes default Half-Life explosion","name":"TE_EXPLFLAG_NONE"}]},{"documentation":"Network message destination types.","name":"NetworkMessageDest","namespace":"","values":[{"documentation":"Sends to all spectator proxies","name":"MSG_SPEC"},{"documentation":"Send to one client, but don't put in reliable stream, put in unreliable datagram ( could be dropped )","name":"MSG_ONE_UNRELIABLE"},{"documentation":"Reliable to PAS","name":"MSG_PAS_R"},{"documentation":"Reliable to PVS","name":"MSG_PVS_R"},{"documentation":"Ents in PAS of org","name":"MSG_PAS"},{"documentation":"Ents in PVS of org","name":"MSG_PVS"},{"documentation":"write to the init string","name":"MSG_INIT"},{"documentation":"reliable to all","name":"MSG_ALL"},{"documentation":"reliable to one (msg_entity)","name":"MSG_ONE"},{"documentation":"unreliable to all","name":"MSG_BROADCAST"}]},{"documentation":"Global state values","name":"GLOBALESTATE","namespace":"","values":[{"documentation":"Global state when removed","name":"GLOBAL_DEAD"},{"documentation":"Global state when on","name":"GLOBAL_ON"},{"documentation":"Global state when off","name":"GLOBAL_OFF"}]},{"documentation":"Used to dictate where client print commands print the given text.","name":"HUD","namespace":"","values":[{"documentation":"Print to center of screen","name":"HUD_PRINTCENTER"},{"documentation":"Print to chat","name":"HUD_PRINTTALK"},{"documentation":"Print to console","name":"HUD_PRINTCONSOLE"},{"documentation":"Print notify","name":"HUD_PRINTNOTIFY"}]},{"documentation":"Fade flags for CPlayerFuncs::ScreenFade and ScreenFadeAll","name":"FFADE","namespace":"","values":[{"documentation":"ignores the duration, stays faded out until new ScreenFade message received","name":"FFADE_STAYOUT"},{"documentation":"Modulate (don't blend)","name":"FFADE_MODULATE"},{"documentation":"Fade out (not in)","name":"FFADE_OUT"},{"documentation":"Just here so we don't pass 0 into the function","name":"FFADE_IN"}]},{"documentation":"Admin levels","name":"AdminLevel_t","namespace":"","values":[{"documentation":"Server owner (applies to a listenserver host player)","name":"ADMIN_OWNER"},{"documentation":"Server administrator","name":"ADMIN_YES"},{"documentation":"Not an administrator","name":"ADMIN_NO"},{"documentation":"Level on connect, tells functions not to use cached level","name":"ADMIN_INIT"}]},{"documentation":"Pitch values","name":"PITCH","namespace":"","values":[{"documentation":"","name":"PITCH_HIGH"},{"documentation":"other values are possible - 0-255, where 255 is very high","name":"PITCH_LOW"},{"documentation":"non-pitch shifted","name":"PITCH_NORM"}]},{"documentation":"Audio channels","name":"SOUND_CHANNEL","namespace":"","values":[{"documentation":"","name":"CHAN_NETWORKVOICE_END"},{"documentation":"voice data coming across the network. Network voice data reserves slots (CHAN_NETWORKVOICE_BASE through CHAN_NETWORKVOICE_END).","name":"CHAN_NETWORKVOICE_BASE"},{"documentation":"allocate channel from the static area","name":"CHAN_STATIC"},{"documentation":"allocate stream channel from the static or dynamic area","name":"CHAN_STREAM"},{"documentation":"","name":"CHAN_BODY"},{"documentation":"","name":"CHAN_ITEM"},{"documentation":"","name":"CHAN_VOICE"},{"documentation":"","name":"CHAN_WEAPON"},{"documentation":"Automatically selects a channel for use. You cannot stop sounds while using this channel with StopSound, or in conjunction with the SND_STOP flag.","name":"CHAN_AUTO"}]},{"documentation":"Sound flags","name":"SoundFlag","namespace":"","values":[{"documentation":"Skip Origin and use entity flag","name":"SND_SKIP_ORIGIN_USE_ENT"},{"documentation":"Linear flag","name":"SND_LINEAR"},{"documentation":"Force loop flag","name":"SND_FORCE_LOOP"},{"documentation":"Force single flag","name":"SND_FORCE_SINGLE"},{"documentation":"Refresh flag","name":"SND_REFRESH"},{"documentation":"Sentence flag","name":"SND_SENTENCE"},{"documentation":"Change pitch flag","name":"SND_CHANGE_PITCH"},{"documentation":"Change volume flag","name":"SND_CHANGE_VOL"},{"documentation":"Stop flag","name":"SND_STOP"},{"documentation":"Entity flag","name":"SND_ENT"},{"documentation":"Origin flag","name":"SND_ORIGIN"},{"documentation":"Attenuation flag","name":"SND_ATTENUATION"},{"documentation":"Pitch flag","name":"SND_PITCH"},{"documentation":"Volume flag","name":"SND_VOLUME"}]},{"documentation":"Alert type for console messages","name":"ALERT_TYPE","namespace":"","values":[{"documentation":"Server print to console (only in multiplayer games)","name":"at_logged"},{"documentation":"Prints 'Error: <message>'","name":"at_error"},{"documentation":"Prints 'Warning: <message>'","name":"at_warning"},{"documentation":"Only shown if developer is 2 or larger","name":"at_aiconsole"},{"documentation":"Outputs text to the console only if developer is larger than 0","name":"at_console"},{"documentation":"Prints 'NOTICE: <message>'","name":"at_notice"}]},{"documentation":"Ignore glass options.<br/>Flag for certain trace functions.","name":"HULL_NUMBER","namespace":"","values":[{"documentation":"Head hull.","name":"head_hull"},{"documentation":"Large hull.","name":"large_hull"},{"documentation":"Human sized hull.","name":"human_hull"},{"documentation":"Point hull. No size.","name":"point_hull"}]},{"documentation":"Ignore glass options.<br/>Flag for certain trace functions.","name":"IGNORE_GLASS","namespace":"","values":[{"documentation":"Don't ignore glass","name":"dont_ignore_glass"},{"documentation":"Ignore glass","name":"ignore_glass"}]},{"documentation":"Ignore monsters options.<br/>Flag for certain trace functions.","name":"IGNORE_MONSTERS","namespace":"","values":[{"documentation":"Object doing the trace is a missile","name":"missile"},{"documentation":"Don't ignore monsters","name":"dont_ignore_monsters"},{"documentation":"Ignore monsters","name":"ignore_monsters"}]},{"documentation":"func_tank spawn flags","name":"TankFlags","namespace":"","values":[{"documentation":"If set, controlling player can't fire this tank.","name":"SF_TANK_PLAYERCANTFIRE"},{"documentation":"If set, uses the relationship specified when dealing with player targets. Otherwise, defaults to always attacking monsters.","name":"SF_TANK_USERELATIONS"},{"documentation":"Whether this func_tank is controllable or not","name":"SF_TANK_CANCONTROL"},{"documentation":"Whether to only attack if the tank has a direct line of sight of its target or continue firing.","name":"SF_TANK_LINEOFSIGHT"},{"documentation":"Whether the tank is active or not","name":"SF_TANK_ACTIVE"}]},{"documentation":"func_tank bullet types","name":"TANKBULLET","namespace":"","values":[{"documentation":"12 mm rounds","name":"TANK_BULLET_12MM"},{"documentation":"MP5 rounds","name":"TANK_BULLET_MP5"},{"documentation":"9mm rounds","name":"TANK_BULLET_9MM"},{"documentation":"No bullet. Nothing is fired when this is set","name":"TANK_BULLET_NONE"}]},{"documentation":"CBeam spawn flags","name":"CBeamSpawnflags","namespace":"","values":[{"documentation":"Whether the beam is a temporary entity","name":"SF_BEAM_TEMPORARY"},{"documentation":"Whether to fade the beam out at its end point","name":"SF_BEAM_SHADEOUT"},{"documentation":"Whether to fade the beam in at its start point","name":"SF_BEAM_SHADEIN"},{"documentation":"Whether to create decals when the beam does damage to BSP models","name":"SF_BEAM_DECALS"},{"documentation":"Whether to allow creation of sparks at the beam's end point","name":"SF_BEAM_SPARKEND"},{"documentation":"Whether to allow creation of sparks at the beam's start point","name":"SF_BEAM_SPARKSTART"},{"documentation":"Whether this beam is a ring between 2 points","name":"SF_BEAM_RING"},{"documentation":"Whether beams are created to a randomly selected entity with the given target name","name":"SF_BEAM_RANDOM"},{"documentation":"Whether the beam should be togglable by triggering it","name":"SF_BEAM_TOGGLE"},{"documentation":"Whether the beam should start on","name":"SF_BEAM_STARTON"}]},{"documentation":"Beam flags used by CBeam::SetFlags","name":"BeamFlags","namespace":"","values":[{"documentation":"Beam fades out at its end point","name":"BEAM_FSHADEOUT"},{"documentation":"Beam fades in at its start point","name":"BEAM_FSHADEIN"},{"documentation":"Beam is a solid shape","name":"BEAM_FSOLID"},{"documentation":"Beam shape follows a sinus shape","name":"BEAM_FSINE"}]},{"documentation":"Beam types used by CBeam::SetType","name":"BeamType","namespace":"","values":[{"documentation":"I don't even know what this does","name":"BEAM_HOSE"},{"documentation":"Beam is a beam between entities","name":"BEAM_ENTS"},{"documentation":"Beam is a beam between point and entity","name":"BEAM_ENTPOINT"},{"documentation":"Beam is a beam between 2 points","name":"BEAM_POINTS"}]},{"documentation":"path_track spawnflags","name":"PathTrackSpawnFlags","namespace":"","values":[{"documentation":"","name":"SF_PATH_ALTERNATE"},{"documentation":"","name":"SF_PATH_DISABLE_TRAIN"},{"documentation":"","name":"SF_PATH_ALTREVERSE"},{"documentation":"","name":"SF_PATH_FIREONCE"},{"documentation":"","name":"SF_PATH_DISABLED"}]},{"documentation":"Weapon id values","name":"WeaponIds","namespace":"","values":[{"documentation":"Maximum number of weapons that the game supports","name":"MAX_WEAPONS"},{"documentation":"","name":"WEAPON_DISPLACER"},{"documentation":"","name":"WEAPON_SHOCKRIFLE"},{"documentation":"","name":"WEAPON_DESERT_EAGLE"},{"documentation":"","name":"WEAPON_SPORELAUNCHER"},{"documentation":"","name":"WEAPON_M16"},{"documentation":"","name":"WEAPON_M249"},{"documentation":"","name":"WEAPON_SNIPERRIFLE"},{"documentation":"","name":"WEAPON_GRAPPLE"},{"documentation":"","name":"WEAPON_MINIGUN"},{"documentation":"","name":"WEAPON_PIPEWRENCH"},{"documentation":"","name":"WEAPON_CROWBAR_ELECTRIC"},{"documentation":"","name":"WEAPON_MEDKIT"},{"documentation":"","name":"WEAPON_UZI"},{"documentation":"","name":"WEAPON_SNARK"},{"documentation":"","name":"WEAPON_SATCHEL"},{"documentation":"","name":"WEAPON_TRIPMINE"},{"documentation":"","name":"WEAPON_HANDGRENADE"},{"documentation":"","name":"WEAPON_HORNETGUN"},{"documentation":"","name":"WEAPON_EGON"},{"documentation":"","name":"WEAPON_GAUSS"},{"documentation":"","name":"WEAPON_RPG"},{"documentation":"","name":"WEAPON_SHOTGUN"},{"documentation":"","name":"WEAPON_CROSSBOW"},{"documentation":"","name":"WEAPON_CHAINGUN"},{"documentation":"","name":"WEAPON_MP5"},{"documentation":"","name":"WEAPON_PYTHON"},{"documentation":"","name":"WEAPON_GLOCK"},{"documentation":"","name":"WEAPON_CROWBAR"},{"documentation":"Weapon id used for invalid weapon ids.","name":"WEAPON_NONE"}]},{"documentation":"Item flags used by ItemInfo::iFlags","name":"ItemFlag","namespace":"","values":[{"documentation":"A player can totally exhaust their ammo supply and lose this weapon","name":"ITEM_FLAG_EXHAUSTIBLE"},{"documentation":"If there are few entity slots left, this item will not respawn","name":"ITEM_FLAG_LIMITINWORLD"},{"documentation":"Don't automatically switch away from this weapon when it runs out of ammo","name":"ITEM_FLAG_NOAUTOSWITCHEMPTY"},{"documentation":"Don't automatically reload this weapon","name":"ITEM_FLAG_NOAUTORELOAD"},{"documentation":"Allow this weapon to be selected if it has no ammo","name":"ITEM_FLAG_SELECTONEMPTY"}]},{"documentation":"Sound flags for monster schedules.","name":"bits_SOUND","namespace":"","values":[{"documentation":"All sound flags","name":"bits_ALL_SOUNDS"},{"documentation":"a bullet just hit at this location","name":"bits_SOUND_BULLETHIT"},{"documentation":"trash cans, banana peels, old fast food bags.","name":"bits_SOUND_GARBAGE"},{"documentation":"pending danger. Grenade that is about to explode, explosive barrel that is damaged, falling crate","name":"bits_SOUND_DANGER"},{"documentation":"gib or pork chop","name":"bits_SOUND_MEAT"},{"documentation":"dead body","name":"bits_SOUND_CARCASS"},{"documentation":"all noises generated by player. walking, shooting, falling, splashing","name":"bits_SOUND_PLAYER"},{"documentation":"door opening/closing, glass breaking","name":"bits_SOUND_WORLD"},{"documentation":"gunshots, explosions","name":"bits_SOUND_COMBAT"},{"documentation":"","name":"bits_SOUND_NONE"}]},{"documentation":"Print type","name":"PRINT_TYPE","namespace":"","values":[{"documentation":"Print to chat. Note: does not work. Use CPlayerFuncs::ClientPrint with HUD_PRINTTALK instead.","name":"print_chat"},{"documentation":"Print to the center of the screen","name":"print_center"},{"documentation":"Print to the console","name":"print_console"}]},{"documentation":"Console variable flags.","name":"FCVAR","namespace":"","values":[{"documentation":"If this is a FCVAR_SERVER, don't log changes to the log file / console if we are creating a log","name":"FCVAR_UNLOGGED"},{"documentation":"This cvar's string cannot contain unprintable characters (e.g. used for player name etc)","name":"FCVAR_PRINTABLEONLY"},{"documentation":"This cvar cannot be changed by clients connected to a multiplayer server.","name":"FCVAR_SPONLY"},{"documentation":"It's a server cvar, but we don't send the data since it's a password, etc.","name":"FCVAR_PROTECTED"},{"documentation":"Defined by the client dll.","name":"FCVAR_CLIENTDLL"},{"documentation":"Defined by external dll.","name":"FCVAR_EXTDLL"},{"documentation":"Notifies players when changed.","name":"FCVAR_SERVER"},{"documentation":"Changes the client's info string.","name":"FCVAR_USERINFO"},{"documentation":"Save this cvar.","name":"FCVAR_ARCHIVE"}]},{"documentation":"Contents of a spot in the world","name":"CONTENTS","namespace":"","values":[{"documentation":"","name":"CONTENTS_LADDER"},{"documentation":"","name":"CONTENTS_SKY"},{"documentation":"","name":"CONTENTS_LAVA"},{"documentation":"","name":"CONTENTS_SLIME"},{"documentation":"","name":"CONTENTS_WATER"},{"documentation":"","name":"CONTENTS_SOLID"},{"documentation":"","name":"CONTENTS_EMPTY"}]},{"documentation":"Walk move types","name":"WALKMOVE","namespace":"","values":[{"documentation":"move, but don't touch triggers","name":"WALKMOVE_CHECKONLY"},{"documentation":"doesn't hit ANY entities, no matter what the solid type","name":"WALKMOVE_WORLDONLY"},{"documentation":"normal walkmove","name":"WALKMOVE_NORMAL"}]},{"documentation":"Door flags.","name":"DoorFlag","namespace":"","values":[{"documentation":"Don't make sure the doors are in-sync.","name":"SF_DOOR_NO_LINK_CHECKING"},{"documentation":"","name":"SF_DOOR_SILENT"},{"documentation":"Monster can't open","name":"SF_DOOR_NOMONSTERS"},{"documentation":"door must be opened by player's use button.","name":"SF_DOOR_USE_ONLY"},{"documentation":"","name":"SF_DOOR_ROTATE_X"},{"documentation":"","name":"SF_DOOR_ROTATE_Z"},{"documentation":"","name":"SF_DOOR_NO_AUTO_RETURN"},{"documentation":"","name":"SF_DOOR_ONEWAY"},{"documentation":"","name":"SF_DOOR_PASSABLE"},{"documentation":"","name":"SF_DOOR_ROTATE_BACKWARDS"},{"documentation":"","name":"SF_DOOR_START_OPEN"},{"documentation":"","name":"SF_DOOR_ROTATE_Y"}]},{"documentation":"Button codes used by CBaseButton","name":"ButtonCode","namespace":"","values":[{"documentation":"Return the button to its default state","name":"BUTTON_RETURN"},{"documentation":"Activate the button","name":"BUTTON_ACTIVATE"},{"documentation":"Do nothing","name":"BUTTON_NOTHING"}]},{"documentation":"Satchel codes","name":"SATCHELCODE","namespace":"","values":[{"documentation":"Release all satches charges owner by a player from their owner","name":"SATCHEL_RELEASE"},{"documentation":"Detonates all satchel charges owned by a player","name":"SATCHEL_DETONATE"}]},{"documentation":"Player hook flags. Used to skip execution of code when a hook performs an action that overrides built-in behavior.","name":"PlayerHookFlag","namespace":"","values":[{"documentation":"Don't run +use checks","name":"PlrHook_SkipUse"},{"documentation":"Don't run vehicle checks","name":"PlrHook_SkipVehicles"}]},{"documentation":"Player view mode.","name":"PlayerViewMode","namespace":"","values":[{"documentation":"","name":"ViewMode_ThirdPerson"},{"documentation":"","name":"ViewMode_FirstPerson"}]},{"documentation":"Player animations, set using CBasePlayer::SetAnimation.","name":"PLAYER_ANIM","namespace":"","values":[{"documentation":"","name":"PLAYER_BARNACLE_CHEW"},{"documentation":"","name":"PLAYER_BARNACLE_CHOMP"},{"documentation":"","name":"PLAYER_BARNACLE_PULL"},{"documentation":"","name":"PLAYER_BARNACLE_HIT"},{"documentation":"","name":"PLAYER_DEPLOY"},{"documentation":"","name":"PLAYER_RELOAD"},{"documentation":"","name":"PLAYER_ATTACK1"},{"documentation":"","name":"PLAYER_DIE"},{"documentation":"","name":"PLAYER_SUPERJUMP"},{"documentation":"","name":"PLAYER_JUMP"},{"documentation":"","name":"PLAYER_WALK"},{"documentation":"","name":"PLAYER_IDLE"}]},{"documentation":"Player physics flags used in CBasePlayer::m_afPhysicsFlags","name":"PFLAG","namespace":"","values":[{"documentation":"Looking through a trigger_camera","name":"PFLAG_CAMERA"},{"documentation":"Toggle grapple use","name":"PFLAG_GRAPPLE"},{"documentation":"player is locked in stationary cam mode. Spectators can move, observers can't.","name":"PFLAG_OBSERVER"},{"documentation":"Using a continuous entity","name":"PFLAG_USING"},{"documentation":"In the process of ducking, but totally squatted yet","name":"PFLAG_DUCKING"},{"documentation":"","name":"PFLAG_ONBARNACLE"},{"documentation":"","name":"PFLAG_ONTRAIN"},{"documentation":"","name":"PFLAG_ONSWING"},{"documentation":"","name":"PFLAG_ONLADDER"}]},{"documentation":"Train modes used by CBasePlayer::m_iTrain","name":"Train","namespace":"","values":[{"documentation":"","name":"TRAIN_BACK"},{"documentation":"","name":"TRAIN_FAST"},{"documentation":"","name":"TRAIN_MEDIUM"},{"documentation":"","name":"TRAIN_SLOW"},{"documentation":"","name":"TRAIN_NEUTRAL"},{"documentation":"","name":"TRAIN_OFF"},{"documentation":"","name":"TRAIN_NEW"},{"documentation":"","name":"TRAIN_ACTIVE"}]},{"documentation":"Bit field values for entvars_t.buttons.<br/>Used by players to determine which buttons have been pressed","name":"In_Buttons","namespace":"","values":[{"documentation":"Used by client.dll for when scoreboard is held down","name":"IN_SCORE"},{"documentation":"Tertiary attack","name":"IN_ALT1"},{"documentation":"Reload","name":"IN_RELOAD"},{"documentation":"Run/Walk","name":"IN_RUN"},{"documentation":"Secondary attack","name":"IN_ATTACK2"},{"documentation":"Move right","name":"IN_MOVERIGHT"},{"documentation":"Move left","name":"IN_MOVELEFT"},{"documentation":"","name":"IN_RIGHT"},{"documentation":"","name":"IN_LEFT"},{"documentation":"","name":"IN_CANCEL"},{"documentation":"Use","name":"IN_USE"},{"documentation":"Move backward","name":"IN_BACK"},{"documentation":"Move forward","name":"IN_FORWARD"},{"documentation":"Duck","name":"IN_DUCK"},{"documentation":"Jump","name":"IN_JUMP"},{"documentation":"Primary attack","name":"IN_ATTACK"}]},{"documentation":"Observer modes","name":"ObserverMode","namespace":"","values":[{"documentation":"Roaming","name":"OBS_ROAMING"},{"documentation":"Free movement","name":"OBS_CHASE_FREE"},{"documentation":"Chase locked","name":"OBS_CHASE_LOCKED"},{"documentation":"Player not in observer mode","name":"OBS_NONE"},{"documentation":"Player in the process of entering observer mode","name":"OBS_ENTERING"}]},{"documentation":"Hit Group standards","name":"HITGROUP","namespace":"","values":[{"documentation":"","name":"HITGROUP_RIGHTLEG"},{"documentation":"","name":"HITGROUP_LEFTLEG"},{"documentation":"","name":"HITGROUP_RIGHTARM"},{"documentation":"","name":"HITGROUP_LEFTARM"},{"documentation":"","name":"HITGROUP_STOMACH"},{"documentation":"","name":"HITGROUP_CHEST"},{"documentation":"","name":"HITGROUP_HEAD"},{"documentation":"","name":"HITGROUP_GENERIC"}]},{"documentation":"Tells us what a monster can do.<br/>See MonsterEntity::m_afCapability","name":"bits_CAPABILITY","namespace":"","values":[{"documentation":"Combination of bits_CAP_USE, bits_CAP_AUTO_DOORS, and bits_CAP_OPEN_DOORS","name":"bits_CAP_DOORS_GROUP"},{"documentation":"can take fall damage","name":"bits_CAP_FALL_DAMAGE"},{"documentation":"can use func_tanks","name":"bits_CAP_USE_TANK"},{"documentation":"can fly, move all around","name":"bits_CAP_FLY"},{"documentation":"can do a melee attack 2","name":"bits_CAP_MELEE_ATTACK2"},{"documentation":"can do a melee attack 1","name":"bits_CAP_MELEE_ATTACK1"},{"documentation":"can do a range attack 2","name":"bits_CAP_RANGE_ATTACK2"},{"documentation":"can do a range attack 1","name":"bits_CAP_RANGE_ATTACK1"},{"documentation":"can turn head, always bone controller 0","name":"bits_CAP_TURN_HEAD"},{"documentation":"can open manual doors","name":"bits_CAP_OPEN_DOORS"},{"documentation":"can trigger auto doors","name":"bits_CAP_AUTO_DOORS"},{"documentation":"can hear forced sounds","name":"bits_CAP_HEAR"},{"documentation":"open doors/push buttons/pull levers","name":"bits_CAP_USE"},{"documentation":"climb ladders/ropes","name":"bits_CAP_CLIMB"},{"documentation":"proficiently navigate in water","name":"bits_CAP_SWIM"},{"documentation":"can form squads","name":"bits_CAP_SQUAD"},{"documentation":"strafe ( walk/run sideways)","name":"bits_CAP_STRAFE"},{"documentation":"jump/leap","name":"bits_CAP_JUMP"},{"documentation":"crouch","name":"bits_CAP_DUCK"}]},{"documentation":"Monster event types","name":"MonsterEventType","namespace":"","values":[{"documentation":"","name":"MONSTER_EVENT_SWISHSOUND"},{"documentation":"","name":"MONSTER_EVENT_FOOTSTEP"},{"documentation":"","name":"MONSTER_EVENT_BODYDROP_HEAVY"},{"documentation":"","name":"MONSTER_EVENT_BODYDROP_LIGHT"},{"documentation":"","name":"EVENT_CLIENT"},{"documentation":"","name":"EVENT_SHARED"},{"documentation":"","name":"EVENT_SCRIPTED"},{"documentation":"","name":"EVENT_SPECIFIC"}]},{"documentation":"Task types for the monster AI","name":"TASK_TYPE","namespace":"","values":[{"documentation":"","name":"LAST_COMMON_TASK"},{"documentation":"","name":"TASK_PATH_WAYPOINT_DEPARTURE"},{"documentation":"","name":"TASK_PATH_WAYPOINT_WAIT"},{"documentation":"","name":"TASK_PATH_WAYPOINT_ARRIVAL"},{"documentation":"","name":"TASK_PATH_WAYPOINT_ANGLES"},{"documentation":"","name":"TASK_PATH_WAYPOINT_MOVEMENT"},{"documentation":"","name":"TASK_PATH_WAYPOINT_INITIALIZE"},{"documentation":"","name":"TASK_MOVE_TO_ENEMY"},{"documentation":"","name":"TASK_GET_PATH_TO_BESTCOMBATSOUND"},{"documentation":"","name":"TASK_FIND_COVER_DISTANCE_FROM_ENEMY"},{"documentation":"","name":"TASK_RUN_TO_TANK"},{"documentation":"","name":"TASK_USE_TANK"},{"documentation":"","name":"TASK_PLAY_SEQUENCE_COWER"},{"documentation":"","name":"TASK_MOVE_TO_TARGET_RANGE_FORCE"},{"documentation":"","name":"TASK_WAIT_FOR_MOVEMENT_GRENADE"},{"documentation":"","name":"TASK_FIND_ATTACKPOINT_TO_ENEMY"},{"documentation":"","name":"TASK_WAIT_AT_TANK"},{"documentation":"","name":"TASK_GET_PATH_TO_TANK"},{"documentation":"","name":"TASK_FIND_TANK"},{"documentation":"","name":"TASK_MOVE_AWAY_PLAYERPATH"},{"documentation":"","name":"TASK_WALK_PLAYERPATH_FOR_UNITS"},{"documentation":"","name":"TASK_WAIT_FOR_MOVEMENT_ENEMY_OCCLUDED"},{"documentation":"","name":"TASK_WAIT_FOR_MOVEMENT_AP"},{"documentation":"","name":"TASK_WAIT_FOR_MOVEMENT"},{"documentation":"","name":"TASK_FORGET"},{"documentation":"","name":"TASK_REMEMBER"},{"documentation":"","name":"TASK_TURN_RIGHT"},{"documentation":"","name":"TASK_TURN_LEFT"},{"documentation":"","name":"TASK_STOP_MOVING"},{"documentation":"","name":"TASK_WAIT_INDEFINITE"},{"documentation":"","name":"TASK_WAIT_RANDOM"},{"documentation":"","name":"TASK_FACE_SCRIPT"},{"documentation":"","name":"TASK_PLANT_ON_SCRIPT"},{"documentation":"","name":"TASK_ENABLE_SCRIPT"},{"documentation":"","name":"TASK_PLAY_SCRIPT"},{"documentation":"","name":"TASK_WAIT_FOR_SCRIPT"},{"documentation":"","name":"TASK_DIE"},{"documentation":"","name":"TASK_EAT"},{"documentation":"","name":"TASK_FIND_COVER_FROM_ORIGIN"},{"documentation":"","name":"TASK_FIND_FAR_NODE_COVER_FROM_ENEMY"},{"documentation":"","name":"TASK_FIND_NEAR_NODE_COVER_FROM_ENEMY"},{"documentation":"","name":"TASK_FIND_NODE_COVER_FROM_ENEMY"},{"documentation":"","name":"TASK_FIND_LATERAL_COVER_FROM_ENEMY"},{"documentation":"","name":"TASK_FIND_COVER_FROM_ENEMY"},{"documentation":"","name":"TASK_FIND_COVER_FROM_BEST_SOUND"},{"documentation":"","name":"TASK_SOUND_DIE"},{"documentation":"","name":"TASK_SOUND_PAIN"},{"documentation":"","name":"TASK_SOUND_WAKE"},{"documentation":"","name":"TASK_SOUND_IDLE"},{"documentation":"","name":"TASK_PLAY_SEQUENCE_FACE_TARGET"},{"documentation":"","name":"TASK_PLAY_SEQUENCE_FACE_ENEMY"},{"documentation":"","name":"TASK_PLAY_SEQUENCE"},{"documentation":"","name":"TASK_CLEAR_FAIL_SCHEDULE"},{"documentation":"","name":"TASK_SET_FAIL_SCHEDULE"},{"documentation":"","name":"TASK_SET_SCHEDULE"},{"documentation":"","name":"TASK_SET_ACTIVITY"},{"documentation":"","name":"TASK_SOUND_DEATH"},{"documentation":"","name":"TASK_SOUND_ANGRY"},{"documentation":"","name":"TASK_DODGE_RIGHT"},{"documentation":"","name":"TASK_DODGE_LEFT"},{"documentation":"","name":"TASK_STEP_BACK"},{"documentation":"","name":"TASK_STEP_FORWARD"},{"documentation":"","name":"TASK_STEP_RIGHT"},{"documentation":"","name":"TASK_STEP_LEFT"},{"documentation":"","name":"TASK_GUARD"},{"documentation":"","name":"TASK_STAND"},{"documentation":"","name":"TASK_CROUCH"},{"documentation":"","name":"TASK_SPECIAL_ATTACK2"},{"documentation":"","name":"TASK_SPECIAL_ATTACK1"},{"documentation":"","name":"TASK_RELOAD_NOTURN"},{"documentation":"","name":"TASK_MELEE_ATTACK2_NOTURN"},{"documentation":"","name":"TASK_MELEE_ATTACK1_NOTURN"},{"documentation":"","name":"TASK_RANGE_ATTACK2_NOTURN"},{"documentation":"","name":"TASK_RANGE_ATTACK1_NOTURN"},{"documentation":"","name":"TASK_RELOAD"},{"documentation":"","name":"TASK_MELEE_ATTACK2"},{"documentation":"","name":"TASK_MELEE_ATTACK1"},{"documentation":"","name":"TASK_RANGE_ATTACK2"},{"documentation":"","name":"TASK_RANGE_ATTACK1"},{"documentation":"","name":"TASK_FACE_LASTPOSITION"},{"documentation":"","name":"TASK_FACE_TARGET"},{"documentation":"","name":"TASK_FACE_HINTNODE"},{"documentation":"","name":"TASK_FACE_ENEMY"},{"documentation":"","name":"TASK_FACE_ROUTE"},{"documentation":"","name":"TASK_FACE_IDEAL"},{"documentation":"","name":"TASK_SMALL_FLINCH"},{"documentation":"","name":"TASK_CLEAR_HINTNODE"},{"documentation":"","name":"TASK_FIND_HINTNODE"},{"documentation":"","name":"TASK_PLAY_ACTIVE_IDLE"},{"documentation":"","name":"TASK_CLEAR_LASTPOSITION"},{"documentation":"","name":"TASK_STORE_LASTPOSITION"},{"documentation":"","name":"TASK_CLEAR_MOVE_WAIT"},{"documentation":"","name":"TASK_STRAFE_PATH"},{"documentation":"","name":"TASK_WALK_PATH"},{"documentation":"","name":"TASK_RUN_PATH"},{"documentation":"","name":"TASK_GET_PATH_TO_BESTSCENT"},{"documentation":"","name":"TASK_GET_PATH_TO_BESTSOUND"},{"documentation":"","name":"TASK_GET_PATH_TO_LASTPOSITION"},{"documentation":"","name":"TASK_GET_PATH_TO_HINTNODE"},{"documentation":"","name":"TASK_GET_PATH_TO_TARGET"},{"documentation":"","name":"TASK_GET_PATH_TO_SPOT"},{"documentation":"","name":"TASK_GET_PATH_TO_LEADER"},{"documentation":"","name":"TASK_GET_PATH_TO_ENEMY_CORPSE"},{"documentation":"","name":"TASK_GET_PATH_TO_ENEMY_LKP"},{"documentation":"","name":"TASK_GET_PATH_TO_ENEMY"},{"documentation":"","name":"TASK_MOVE_TO_TARGET_RANGE"},{"documentation":"","name":"TASK_RUN_TO_TARGET"},{"documentation":"","name":"TASK_WALK_TO_TARGET"},{"documentation":"","name":"TASK_SUGGEST_STATE"},{"documentation":"","name":"TASK_WAIT_PVS"},{"documentation":"","name":"TASK_WAIT_FACE_ENEMY"},{"documentation":"","name":"TASK_WAIT"},{"documentation":"","name":"TASK_INVALID"}]},{"documentation":"Schedule types for monster AI","name":"SCHEDULE_TYPE","namespace":"","values":[{"documentation":"","name":"LAST_COMMON_SCHEDULE"},{"documentation":"","name":"SCHED_PATH_WAYPOINT"},{"documentation":"","name":"SCHED_GUARD_POINT"},{"documentation":"","name":"SCHED_TELEPORT_FALL"},{"documentation":"","name":"SCHED_SMALL_FLINCH_SPECIAL"},{"documentation":"","name":"SCHED_RANGE_ATTACK1_DEFAULT"},{"documentation":"","name":"SCHED_LOSE_ENEMY"},{"documentation":"","name":"SCHED_FIND_ATTACK_POINT"},{"documentation":"","name":"SCHED_WAIT_AT_TANK"},{"documentation":"","name":"SCHED_MOVE_TO_TANK"},{"documentation":"","name":"SCHED_MOVE_AWAY_PLAYERFOLLOW"},{"documentation":"","name":"SCHED_TARGET_PLAYERCHASE_FORCE"},{"documentation":"","name":"SCHED_TARGET_PLAYERCHASE"},{"documentation":"","name":"SCHED_TARGET_PLAYERFACE"},{"documentation":"","name":"SCHED_FAIL"},{"documentation":"","name":"SCHED_AISCRIPT"},{"documentation":"","name":"SCHED_BARNACLE_VICTIM_CHOMP"},{"documentation":"","name":"SCHED_BARNACLE_VICTIM_GRAB"},{"documentation":"","name":"SCHED_WAKE"},{"documentation":"","name":"SCHED_SLEEP"},{"documentation":"","name":"SCHED_FOLLOW"},{"documentation":"","name":"SCHED_WAIT_TILL_SEEN"},{"documentation":"","name":"SCHED_WAIT_TRIGGER"},{"documentation":"","name":"SCHED_DIE"},{"documentation":"","name":"SCHED_AMBUSH"},{"documentation":"","name":"SCHED_GUARD"},{"documentation":"","name":"SCHED_RELOAD"},{"documentation":"","name":"SCHED_ARM_WEAPON"},{"documentation":"","name":"SCHED_STANDOFF"},{"documentation":"","name":"SCHED_SPECIAL_ATTACK2"},{"documentation":"","name":"SCHED_SPECIAL_ATTACK1"},{"documentation":"","name":"SCHED_RANGE_ATTACK2"},{"documentation":"","name":"SCHED_RANGE_ATTACK1"},{"documentation":"","name":"SCHED_MELEE_ATTACK2"},{"documentation":"","name":"SCHED_MELEE_ATTACK1"},{"documentation":"","name":"SCHED_COWER"},{"documentation":"","name":"SCHED_TAKE_COVER_FROM_ORIGIN"},{"documentation":"","name":"SCHED_TAKE_COVER_FROM_BEST_SOUND"},{"documentation":"","name":"SCHED_TAKE_COVER_FROM_ENEMY"},{"documentation":"","name":"SCHED_SMALL_FLINCH"},{"documentation":"","name":"SCHED_TARGET_CHASE"},{"documentation":"","name":"SCHED_TARGET_FACE"},{"documentation":"","name":"SCHED_VICTORY_DANCE"},{"documentation":"","name":"SCHED_CHASE_ENEMY_FAILED"},{"documentation":"","name":"SCHED_CHASE_ENEMY"},{"documentation":"","name":"SCHED_COMBAT_STAND"},{"documentation":"","name":"SCHED_COMBAT_FACE"},{"documentation":"","name":"SCHED_INVESTIGATE_COMBAT"},{"documentation":"","name":"SCHED_INVESTIGATE_SOUND"},{"documentation":"","name":"SCHED_ALERT_STAND"},{"documentation":"","name":"SCHED_ALERT_BIG_FLINCH"},{"documentation":"","name":"SCHED_ALERT_SMALL_FLINCH"},{"documentation":"","name":"SCHED_ALERT_FACE"},{"documentation":"","name":"SCHED_WAKE_CALLED"},{"documentation":"","name":"SCHED_WAKE_ANGRY"},{"documentation":"","name":"SCHED_IDLE_WALK"},{"documentation":"","name":"SCHED_IDLE_STAND"},{"documentation":"","name":"SCHED_NONE"}]},{"documentation":"trigger conditions for scripted AI","name":"AITRIGGER","namespace":"","values":[{"documentation":"See Player, Not In Combat","name":"AITRIGGER_SEEPLAYER_NOT_IN_COMBAT"},{"documentation":"See Player Unconditional","name":"AITRIGGER_SEEPLAYER_UNCONDITIONAL"},{"documentation":"Hear Combat","name":"AITRIGGER_HEARCOMBAT"},{"documentation":"Hear Player","name":"AITRIGGER_HEARPLAYER"},{"documentation":"Hear World","name":"AITRIGGER_HEARWORLD"},{"documentation":"Squad Leader Dead","name":"AITRIGGER_SQUADLEADERDIE"},{"documentation":"Squad Member Dead","name":"AITRIGGER_SQUADMEMBERDIE"},{"documentation":"Death","name":"AITRIGGER_DEATH"},{"documentation":"50% Health Remaining","name":"AITRIGGER_HALFHEALTH"},{"documentation":"Take Damage","name":"AITRIGGER_TAKEDAMAGE"},{"documentation":"See Player","name":"AITRIGGER_SEEPLAYER_ANGRY_AT_PLAYER"},{"documentation":"No Trigger","name":"AITRIGGER_NONE"}]},{"documentation":"these bits represent the monster's memory","name":"MonsterMemory","namespace":"","values":[{"documentation":"Monster-specific memory","name":"bits_MEMORY_CUSTOM1"},{"documentation":"Monster-specific memory","name":"bits_MEMORY_CUSTOM2"},{"documentation":"Monster-specific memory","name":"bits_MEMORY_CUSTOM3"},{"documentation":"Monster-specific memory","name":"bits_MEMORY_CUSTOM4"},{"documentation":"Can only get there within radius","name":"bits_MEMORY_MOVE_RADIUS_ONLY"},{"documentation":"HACKHACK -- remember that I've already called my Killed()","name":"bits_MEMORY_KILLED"},{"documentation":"Has already flinched","name":"bits_MEMORY_FLINCHED"},{"documentation":"Movement has already failed","name":"bits_MEMORY_MOVE_FAILED"},{"documentation":"Moving on a path","name":"bits_MEMORY_ON_PATH"},{"documentation":"Finished monster path (just used by big momma for now)","name":"bits_MEMORY_PATH_FINISHED"},{"documentation":"Ally is suspicious of the player, and will move to provoked more easily","name":"bits_MEMORY_SUSPICIOUS"},{"documentation":"monster knows it is in a covered position.","name":"bits_MEMORY_INCOVER"},{"documentation":"right now only used for houndeyes.","name":"bits_MEMORY_PROVOKED"},{"documentation":"No memory.","name":"MEMORY_CLEAR"}]},{"documentation":"Damage over time types.","name":"CDMG","namespace":"","values":[{"documentation":"Number of damage over time types","name":"CDMG_TIMEBASED"},{"documentation":"","name":"itbd_SlowFreeze"},{"documentation":"","name":"itbd_SlowBurn"},{"documentation":"","name":"itbd_Acid"},{"documentation":"","name":"itbd_DrownRecover"},{"documentation":"","name":"itbd_Radiation"},{"documentation":"","name":"itbd_Poison"},{"documentation":"","name":"itbd_NerveGas"},{"documentation":"","name":"itbd_Paralyze"}]},{"documentation":"these bits represent conditions that may befall the monster, of which some are allowed<br/>to interrupt certain schedules. ","name":"MonsterCondition","namespace":"","values":[{"documentation":"","name":"bits_COND_CAN_ATTACK"},{"documentation":"","name":"bits_COND_ALL_SPECIAL"},{"documentation":"This monster can use a func_tank now","name":"bits_COND_CAN_USE_TANK"},{"documentation":"","name":"bits_COND_SCHEDULE_DONE"},{"documentation":"","name":"bits_COND_TASK_FAILED"},{"documentation":"Defined by individual monster","name":"bits_COND_SPECIAL2"},{"documentation":"Defined by individual monster","name":"bits_COND_SPECIAL1"},{"documentation":"","name":"bits_COND_CAN_MELEE_ATTACK2_MOVING"},{"documentation":"","name":"bits_COND_CAN_RANGE_ATTACK2_MOVING"},{"documentation":"","name":"bits_COND_CAN_MELEE_ATTACK1_MOVING"},{"documentation":"","name":"bits_COND_CAN_RANGE_ATTACK1_MOVING"},{"documentation":"see my nemesis","name":"bits_COND_SEE_NEMESIS"},{"documentation":"see a client","name":"bits_COND_SEE_CLIENT"},{"documentation":"enemy was killed. If you get this in combat, try to find another enemy. If you get it in alert, victory dance.","name":"bits_COND_ENEMY_DEAD"},{"documentation":"enemy is facing me","name":"bits_COND_ENEMY_FACING_ME"},{"documentation":"there is an interesting scent","name":"bits_COND_SMELL"},{"documentation":"there is an interesting sound","name":"bits_COND_HEAR_SOUND"},{"documentation":"","name":"bits_COND_NEW_ENEMY"},{"documentation":"","name":"bits_COND_PROVOKED"},{"documentation":"","name":"bits_COND_CAN_MELEE_ATTACK2"},{"documentation":"","name":"bits_COND_CAN_RANGE_ATTACK2"},{"documentation":"","name":"bits_COND_CAN_MELEE_ATTACK1"},{"documentation":"","name":"bits_COND_CAN_RANGE_ATTACK1"},{"documentation":"hurt a lot","name":"bits_COND_HEAVY_DAMAGE"},{"documentation":"hurt a little","name":"bits_COND_LIGHT_DAMAGE"},{"documentation":"","name":"bits_COND_ENEMY_TOOFAR"},{"documentation":"","name":"bits_COND_SMELL_FOOD"},{"documentation":"target entity occluded by the world","name":"bits_COND_ENEMY_OCCLUDED"},{"documentation":"target entity is in full view.","name":"bits_COND_SEE_ENEMY"},{"documentation":"see something that you dislike","name":"bits_COND_SEE_DISLIKE"},{"documentation":"see something that you are afraid of","name":"bits_COND_SEE_FEAR"},{"documentation":"see something that you hate","name":"bits_COND_SEE_HATE"},{"documentation":"weapon needs to be reloaded!","name":"bits_COND_NO_AMMO_LOADED"}]},{"documentation":"these MoveFlag values are assigned to a WayPoint's TYPE in order to demonstrate the<br/>type of movement the monster should use to get there.","name":"MoveFlag","namespace":"","values":[{"documentation":"Elevator","name":"bits_MF_TO_ELEVATOR"},{"documentation":"Ladder...","name":"bits_MF_TO_LADDER"},{"documentation":"Jumping...","name":"bits_MF_TO_JUMP"},{"documentation":"Don't let the route code simplify this waypoint","name":"bits_MF_DONT_SIMPLIFY"},{"documentation":"this waypoint is the goal of the whole move.","name":"bits_MF_IS_GOAL"},{"documentation":"local move to an arbitrary point","name":"bits_MF_TO_LOCATION"},{"documentation":"local move to a node","name":"bits_MF_TO_NODE"},{"documentation":"local move to a path corner","name":"bits_MF_TO_PATHCORNER"},{"documentation":"local move to detour point.","name":"bits_MF_TO_DETOUR"},{"documentation":"local move to a hiding place","name":"bits_MF_TO_COVER"},{"documentation":"local move to enemy","name":"bits_MF_TO_ENEMY"},{"documentation":"local move to targetent.","name":"bits_MF_TO_TARGETENT"}]},{"documentation":"These go in the flData member of TASK_WALK_TO_TARGET, TASK_RUN_TO_TARGET","name":"TaskData","namespace":"","values":[{"documentation":"Move scripted","name":"TARGET_MOVE_SCRIPTED"},{"documentation":"Move normally","name":"TARGET_MOVE_NORMAL"}]},{"documentation":"Current state of a monster","name":"MONSTERSTATE","namespace":"","values":[{"documentation":"","name":"MONSTERSTATE_DEAD"},{"documentation":"","name":"MONSTERSTATE_PLAYDEAD"},{"documentation":"","name":"MONSTERSTATE_SCRIPT"},{"documentation":"","name":"MONSTERSTATE_PRONE"},{"documentation":"","name":"MONSTERSTATE_HUNT"},{"documentation":"","name":"MONSTERSTATE_ALERT"},{"documentation":"","name":"MONSTERSTATE_COMBAT"},{"documentation":"","name":"MONSTERSTATE_IDLE"},{"documentation":"","name":"MONSTERSTATE_NONE"}]},{"documentation":"Activity currently being played by a monster","name":"Activity","namespace":"","values":[{"documentation":"","name":"ACT_FLINCH_RIGHTLEG"},{"documentation":"","name":"ACT_FLINCH_LEFTLEG"},{"documentation":"","name":"ACT_FLINCH_RIGHTARM"},{"documentation":"","name":"ACT_FLINCH_LEFTARM"},{"documentation":"","name":"ACT_FLINCH_STOMACH"},{"documentation":"","name":"ACT_FLINCH_CHEST"},{"documentation":"","name":"ACT_FLINCH_HEAD"},{"documentation":"die, hit in back","name":"ACT_DIE_BACKSHOT"},{"documentation":"die, hit in gut","name":"ACT_DIE_GUTSHOT"},{"documentation":"die, hit in chest","name":"ACT_DIE_CHESTSHOT"},{"documentation":"die, hit in head. ","name":"ACT_DIE_HEADSHOT"},{"documentation":"killed a player, do a victory dance.","name":"ACT_VICTORY_DANCE"},{"documentation":"","name":"ACT_RUN_SCARED"},{"documentation":"","name":"ACT_WALK_SCARED"},{"documentation":"agitated idle.","name":"ACT_COMBAT_IDLE"},{"documentation":"","name":"ACT_SPECIAL_ATTACK2"},{"documentation":"very monster specific special attacks.","name":"ACT_SPECIAL_ATTACK1"},{"documentation":"for some reason, monster is excited. Sees something he really likes to eat, or whatever.","name":"ACT_EXCITED"},{"documentation":"monster just saw something that it is afraid of","name":"ACT_FEAR_DISPLAY"},{"documentation":"without attacking, monster demonstrates that it is angry. (Yell, stick out chest, etc )","name":"ACT_THREAT_DISPLAY"},{"documentation":"some large monsters can eat small things in one bite. This plays one time, EAT loops.","name":"ACT_BITE"},{"documentation":"this is the act of actually sniffing an item in front of the monster","name":"ACT_SNIFF"},{"documentation":"this means the monster smells a scent carried by the air","name":"ACT_DETECT_SCENT"},{"documentation":"Turn right in flight","name":"ACT_FLY_RIGHT"},{"documentation":"Turn left in flight","name":"ACT_FLY_LEFT"},{"documentation":"Fly (don't flap)","name":"ACT_GLIDE"},{"documentation":"Idle while in flight","name":"ACT_HOVER"},{"documentation":"limp  (loop)","name":"ACT_RUN_HURT"},{"documentation":"limp  (loop)","name":"ACT_WALK_HURT"},{"documentation":"alternate idle animation in which the monster is clearly agitated. (loop)","name":"ACT_IDLE_ANGRY"},{"documentation":"for active idles, look at something directly ahead of you ( doesn't HAVE to be a wall or on a wall )","name":"ACT_INSPECT_WALL"},{"documentation":"for active idles, look at something on or near the floor","name":"ACT_INSPECT_FLOOR"},{"documentation":"","name":"ACT_SLEEP"},{"documentation":"barnacle is holding the monster in its mouth ( loop )","name":"ACT_BARNACLE_CHEW"},{"documentation":"barnacle latches on to the monster","name":"ACT_BARNACLE_CHOMP"},{"documentation":"barnacle is lifting the monster ( loop )","name":"ACT_BARNACLE_PULL"},{"documentation":"barnacle tongue hits a monster","name":"ACT_BARNACLE_HIT"},{"documentation":"","name":"ACT_DIEVIOLENT"},{"documentation":"","name":"ACT_DIEFORWARD"},{"documentation":"","name":"ACT_DIEBACKWARD"},{"documentation":"","name":"ACT_DIESIMPLE"},{"documentation":"monster chowing on a large food item (loop)","name":"ACT_EAT"},{"documentation":"reholster gun","name":"ACT_DISARM"},{"documentation":"pull out gun, for instance","name":"ACT_ARM"},{"documentation":"","name":"ACT_RELOAD"},{"documentation":"","name":"ACT_MELEE_ATTACK2"},{"documentation":"","name":"ACT_MELEE_ATTACK1"},{"documentation":"","name":"ACT_RANGE_ATTACK2"},{"documentation":"","name":"ACT_RANGE_ATTACK1"},{"documentation":"","name":"ACT_BIG_FLINCH"},{"documentation":"","name":"ACT_SMALL_FLINCH"},{"documentation":"","name":"ACT_COWER"},{"documentation":"","name":"ACT_TWITCH"},{"documentation":"","name":"ACT_SIGNAL3"},{"documentation":"","name":"ACT_SIGNAL2"},{"documentation":"","name":"ACT_SIGNAL1"},{"documentation":"","name":"ACT_USE"},{"documentation":"the act of standing from a crouched position","name":"ACT_STAND"},{"documentation":"holding body in crouched position (loops)","name":"ACT_CROUCHIDLE"},{"documentation":"the act of crouching down from a standing position","name":"ACT_CROUCH"},{"documentation":"turn quickly right (stationary)","name":"ACT_TURN_RIGHT"},{"documentation":"turn quickly left (stationary)","name":"ACT_TURN_LEFT"},{"documentation":"tuck and roll, right","name":"ACT_ROLL_RIGHT"},{"documentation":"tuck and roll, left","name":"ACT_ROLL_LEFT"},{"documentation":"","name":"ACT_STRAFE_RIGHT"},{"documentation":"","name":"ACT_STRAFE_LEFT"},{"documentation":"","name":"ACT_LAND"},{"documentation":"","name":"ACT_FALL"},{"documentation":"long forward jump","name":"ACT_LEAP"},{"documentation":"vertical jump","name":"ACT_HOP"},{"documentation":"","name":"ACT_SWIM"},{"documentation":"Fly (and flap if appropriate)","name":"ACT_FLY"},{"documentation":"","name":"ACT_RUN"},{"documentation":"","name":"ACT_WALK"},{"documentation":"","name":"ACT_GUARD"},{"documentation":"","name":"ACT_IDLE"},{"documentation":"Set m_Activity to this invalid value to force a reset to m_IdealActivity","name":"ACT_RESET"}]},{"documentation":"The state of a monster's script.","name":"SCRIPTSTATE","namespace":"","values":[{"documentation":"Run to mark","name":"SCRIPT_RUN_TO_MARK"},{"documentation":"Walk to mark","name":"SCRIPT_WALK_TO_MARK"},{"documentation":"Cancelling the script / cleaning up","name":"SCRIPT_CLEANUP"},{"documentation":"Waiting on everyone in the script to be ready","name":"SCRIPT_WAIT"},{"documentation":"Playing the sequence","name":"SCRIPT_PLAYING"}]},{"documentation":"Material types supported by breakables","name":"Materials","namespace":"","values":[{"documentation":"","name":"matLastMaterial"},{"documentation":"","name":"matNone"},{"documentation":"","name":"matRocks"},{"documentation":"","name":"matUnbreakableGlass"},{"documentation":"","name":"matComputer"},{"documentation":"","name":"matCeilingTile"},{"documentation":"","name":"matCinderBlock"},{"documentation":"","name":"matFlesh"},{"documentation":"","name":"matMetal"},{"documentation":"","name":"matWood"},{"documentation":"","name":"matGlass"}]},{"documentation":"Return values for CBaseEntity::AddPlayerItem","name":"AddPlayerItemResult","namespace":"","values":[{"documentation":"Player picked up this item","name":"APIR_Added"},{"documentation":"Player was able to add it as duplicate","name":"APIR_DuplicateAdd"},{"documentation":"Player could not pick up this item","name":"APIR_NotAdded"}]},{"documentation":"bullet types","name":"Bullet","namespace":"","values":[{"documentation":"","name":"DECAL_SCORCH_MARK"},{"documentation":"Monster shotgun","name":"BULLET_MONSTER_BUCKSHOT"},{"documentation":"","name":"BULLET_MONSTER_SNIPER"},{"documentation":"","name":"BULLET_MONSTER_EAGLE"},{"documentation":"","name":"BULLET_MONSTER_12MM"},{"documentation":"","name":"BULLET_MONSTER_SAW"},{"documentation":"","name":"BULLET_MONSTER_MP5"},{"documentation":"","name":"BULLET_MONSTER_9MM"},{"documentation":"normal bullet with custom damage","name":"BULLET_PLAYER_CUSTOMDAMAGE"},{"documentation":"","name":"BULLET_PLAYER_CROWBAR"},{"documentation":"Shotgun","name":"BULLET_PLAYER_BUCKSHOT"},{"documentation":"Desert eagle","name":"BULLET_PLAYER_EAGLE"},{"documentation":"Python","name":"BULLET_PLAYER_357"},{"documentation":"","name":"BULLET_PLAYER_SNIPER"},{"documentation":"","name":"BULLET_PLAYER_SAW"},{"documentation":"mp5","name":"BULLET_PLAYER_MP5"},{"documentation":"Glock","name":"BULLET_PLAYER_9MM"},{"documentation":"","name":"BULLET_NONE"}]},{"documentation":"Common entity flags used by various entities.","name":"CommonEntityFlags","namespace":"","values":[{"documentation":"Don't allow default ammo to be set. Prevents players from getting too much ammo from cross map inventory","name":"SF_NODEFAULTAMMO"},{"documentation":"This item is being given to the player -- can't fall out of map","name":"SF_GIVENITEM"},{"documentation":"this flag indicates that a player thrown weapon should deal damage to things it hits","name":"SF_DODAMAGE"},{"documentation":"this flag indicates that this entity is a weapon created for players,<br/>as opposed to being created by being placed by a mapper","name":"SF_CREATEDWEAPON"},{"documentation":"A weapon will be removed from the map after 60sec","name":"SF_DELAYREMOVE"},{"documentation":"set this bit on guns and stuff that should never respawn.","name":"SF_NORESPAWN"}]},{"documentation":"FireBullets draw mode options","name":"FireBulletsDrawMode","namespace":"","values":[{"documentation":"Draw impact decal","name":"FBDM_DRAW"},{"documentation":"Don't draw impact decal","name":"FBDM_DONTDRAW"}]},{"documentation":"Render FX modes (entvars_t::renderfx)","name":"RenderFX","namespace":"","values":[{"documentation":"Keep this sprite from getting very small (SPRITES only!)","name":"kRenderFxClampMinScale"},{"documentation":"Glowing Shell","name":"kRenderFxGlowShell"},{"documentation":"Scale up really big!","name":"kRenderFxExplode"},{"documentation":"kRenderAmt is the player index","name":"kRenderFxDeadPlayer"},{"documentation":"kRenderFxDistort + distance fade","name":"kRenderFxHologram"},{"documentation":"Distort/scale/translate flicker","name":"kRenderFxDistort"},{"documentation":"","name":"kRenderFxNoDissipation"},{"documentation":"","name":"kRenderFxFlickerFast"},{"documentation":"","name":"kRenderFxFlickerSlow"},{"documentation":"","name":"kRenderFxStrobeFaster"},{"documentation":"","name":"kRenderFxStrobeFast"},{"documentation":"","name":"kRenderFxStrobeSlow"},{"documentation":"","name":"kRenderFxSolidFast"},{"documentation":"","name":"kRenderFxSolidSlow"},{"documentation":"","name":"kRenderFxFadeFast"},{"documentation":"","name":"kRenderFxFadeSlow"},{"documentation":"","name":"kRenderFxPulseFastWide"},{"documentation":"","name":"kRenderFxPulseSlowWide"},{"documentation":"","name":"kRenderFxPulseFast"},{"documentation":"","name":"kRenderFxPulseSlow"},{"documentation":"","name":"kRenderFxNone"}]},{"documentation":"Render modes used by entities (entvars_t::rendermode)","name":"RenderModes","namespace":"","values":[{"documentation":"src*a+dest","name":"kRenderTransAdd"},{"documentation":"src*srca+dest*(1-srca)","name":"kRenderTransAlpha"},{"documentation":"src*a+dest -- No Z buffer checks","name":"kRenderGlow"},{"documentation":"src*a+dest*(1-a)","name":"kRenderTransTexture"},{"documentation":"c*a+dest*(1-a)","name":"kRenderTransColor"},{"documentation":"src","name":"kRenderNormal"}]},{"documentation":"Temp entity bounce sound types","name":"TE_BOUNCE","namespace":"","values":[{"documentation":"","name":"TE_BOUNCE_SHOTSHELL"},{"documentation":"","name":"TE_BOUNCE_SHELL"},{"documentation":"","name":"TE_BOUNCE_NULL"}]},{"documentation":"Break model defines for message SVC_TEMPENTITY::TE_BREAKMODEL","name":"BREAK","namespace":"","values":[{"documentation":"Not used","name":"BREAK_2"},{"documentation":"","name":"BREAK_CONCRETE"},{"documentation":"Model is transparent","name":"BREAK_TRANS"},{"documentation":"Adds a smoke trail","name":"BREAK_SMOKE"},{"documentation":"","name":"BREAK_WOOD"},{"documentation":"","name":"BREAK_FLESH"},{"documentation":"","name":"BREAK_METAL"},{"documentation":"","name":"BREAK_GLASS"},{"documentation":"Bit mask for all BREAK types.","name":"BREAK_TYPEMASK"}]},{"documentation":"Texture types used by the game.","name":"TextureType","namespace":"","values":[{"documentation":"Snow.","name":"CHAR_TEX_SNOW"},{"documentation":"Flesh.","name":"CHAR_TEX_FLESH"},{"documentation":"Glass.","name":"CHAR_TEX_GLASS"},{"documentation":"Computer.","name":"CHAR_TEX_COMPUTER"},{"documentation":"Wood.","name":"CHAR_TEX_WOOD"},{"documentation":"Slosh.","name":"CHAR_TEX_SLOSH"},{"documentation":"Tile.","name":"CHAR_TEX_TILE"},{"documentation":"Grate.","name":"CHAR_TEX_GRATE"},{"documentation":"Vent.","name":"CHAR_TEX_VENT"},{"documentation":"Dirt.","name":"CHAR_TEX_DIRT"},{"documentation":"Metal.","name":"CHAR_TEX_METAL"},{"documentation":"Concrete.<br/>Default.","name":"CHAR_TEX_CONCRETE"}]},{"documentation":"when calling Killed(), a value that governs gib behavior is expected to be one of these three values","name":"GIB","namespace":"","values":[{"documentation":"No penalty applied to players that died","name":"GIB_NOPENALTY"},{"documentation":"always gib ( Houndeye Shock, Barnacle Bite )","name":"GIB_ALWAYS"},{"documentation":"never gib, no matter how much death damage is done ( freezing, etc )","name":"GIB_NEVER"},{"documentation":"gib if entity was overkilled","name":"GIB_NORMAL"}]},{"documentation":"Dynamic decals used by code to place decals like scorch marks in the world","name":"decal_e","namespace":"","values":[{"documentation":"Spore splat 3","name":"DECAL_SPORESPLAT3"},{"documentation":"Spore splat 2","name":"DECAL_SPORESPLAT2"},{"documentation":"Spore splat 1","name":"DECAL_SPORESPLAT1"},{"documentation":"Opposing force scorch 3","name":"DECAL_OFSCORCH3"},{"documentation":"Opposing force scorch 2","name":"DECAL_OFSCORCH2"},{"documentation":"Opposing force scorch 1","name":"DECAL_OFSCORCH1"},{"documentation":"Big momma splat","name":"DECAL_MOMMASPLAT"},{"documentation":"Big momma birth splatter","name":"DECAL_MOMMABIRTH"},{"documentation":"Small scorch 3","name":"DECAL_SMALLSCORCH3"},{"documentation":"Small scorch 2","name":"DECAL_SMALLSCORCH2"},{"documentation":"Small scorch 1","name":"DECAL_SMALLSCORCH1"},{"documentation":"gargantua stomp crack","name":"DECAL_GARGSTOMP1"},{"documentation":"Bulletproof glass decal","name":"DECAL_BPROOF1"},{"documentation":"Spit 2","name":"DECAL_SPIT2"},{"documentation":"Spit 1","name":"DECAL_SPIT1"},{"documentation":"Big shot 5","name":"DECAL_BIGSHOT5"},{"documentation":"Big shot 4","name":"DECAL_BIGSHOT4"},{"documentation":"Big shot 3","name":"DECAL_BIGSHOT3"},{"documentation":"Big shot 2","name":"DECAL_BIGSHOT2"},{"documentation":"Big shot 1","name":"DECAL_BIGSHOT1"},{"documentation":"Glass break 3","name":"DECAL_GLASSBREAK3"},{"documentation":"Glass break 2","name":"DECAL_GLASSBREAK2"},{"documentation":"Glass break 1","name":"DECAL_GLASSBREAK1"},{"documentation":"Yellow blood 6","name":"DECAL_YBLOOD6"},{"documentation":"Yellow blood 5","name":"DECAL_YBLOOD5"},{"documentation":"Yellow blood 4","name":"DECAL_YBLOOD4"},{"documentation":"Yellow blood 3","name":"DECAL_YBLOOD3"},{"documentation":"Yellow blood 2","name":"DECAL_YBLOOD2"},{"documentation":"Yellow blood 1","name":"DECAL_YBLOOD1"},{"documentation":"(Red) Blood 6","name":"DECAL_BLOOD6"},{"documentation":"(Red) Blood 5","name":"DECAL_BLOOD5"},{"documentation":"(Red) Blood 4","name":"DECAL_BLOOD4"},{"documentation":"(Red) Blood 3","name":"DECAL_BLOOD3"},{"documentation":"(Red) Blood 2","name":"DECAL_BLOOD2"},{"documentation":"(Red) Blood 1","name":"DECAL_BLOOD1"},{"documentation":"Scorch 1","name":"DECAL_SCORCH2"},{"documentation":"Scorch 1","name":"DECAL_SCORCH1"},{"documentation":"Lambda 6","name":"DECAL_LAMBDA6"},{"documentation":"Lambda 5","name":"DECAL_LAMBDA5"},{"documentation":"Lambda 4","name":"DECAL_LAMBDA4"},{"documentation":"Lambda 3","name":"DECAL_LAMBDA3"},{"documentation":"Lambda 2","name":"DECAL_LAMBDA2"},{"documentation":"Lambda 1","name":"DECAL_LAMBDA1"},{"documentation":"Gunshot 5","name":"DECAL_GUNSHOT5"},{"documentation":"Gunshot 4","name":"DECAL_GUNSHOT4"},{"documentation":"Gunshot 3","name":"DECAL_GUNSHOT3"},{"documentation":"Gunshot 2","name":"DECAL_GUNSHOT2"},{"documentation":"Gunshot 1","name":"DECAL_GUNSHOT1"}]},{"documentation":"Blood color","name":"BLOOD_COLOR","namespace":"","values":[{"documentation":"Green blood","name":"BLOOD_COLOR_GREEN"},{"documentation":"Yellow blood","name":"BLOOD_COLOR_YELLOW"},{"documentation":"Red blood","name":"BLOOD_COLOR_RED"},{"documentation":"Don't bleed","name":"DONT_BLEED"}]},{"documentation":"Toggle state for entities that can be toggled.","name":"TOGGLE_STATE","namespace":"","values":[{"documentation":"Entity is going down","name":"TS_GOING_DOWN"},{"documentation":"Entity is going up","name":"TS_GOING_UP"},{"documentation":"Entity is at bottom","name":"TS_AT_BOTTOM"},{"documentation":"Entity is at top","name":"TS_AT_TOP"}]},{"documentation":"Damage types.","name":"DMG","namespace":"","values":[{"documentation":"Shown on HUD. These are the damage types that have clien hud art.","name":"DMG_SHOWNHUD"},{"documentation":"Gib corpse. These are the damage types that are allowed to gib corpses.","name":"DMG_GIB_CORPSE"},{"documentation":"Shock glow. Flag for shock glow effect.","name":"DMG_SHOCK_GLOW"},{"documentation":"Medkit heal. Medkit healing.","name":"DMG_MEDKITHEAL"},{"documentation":"Sniper. Hit by a Sniper.","name":"DMG_SNIPER"},{"documentation":"Mortar. Hit by air raid (done to distinguish grenade from mortar)","name":"DMG_MORTAR"},{"documentation":"Slow freeze. In a subzero freezer.","name":"DMG_SLOWFREEZE"},{"documentation":"Slow burn. In an oven.","name":"DMG_SLOWBURN"},{"documentation":"Acid. Toxic chemicals or acid burns.","name":"DMG_ACID"},{"documentation":"Drown recover. Drowning recovery.","name":"DMG_DROWNRECOVER"},{"documentation":"Radiation. Radiation exposure.","name":"DMG_RADIATION"},{"documentation":"Poison. Blood poisoning.","name":"DMG_POISON"},{"documentation":"Nerve gas. Nerve toxins, very bad.","name":"DMG_NERVEGAS"},{"documentation":"Paralyze. Slows affected creature down.","name":"DMG_PARALYZE"},{"documentation":"Mash for time-based damage.","name":"DMG_TIMEBASED"},{"documentation":"Drown. Drowning.","name":"DMG_DROWN"},{"documentation":"Launch. Launch into air.","name":"DMG_LAUNCH"},{"documentation":"Always gib. With this bit OR'd in, any damage type can be made to gib victims upon death.","name":"DMG_ALWAYSGIB"},{"documentation":"Never gib. With this bit OR'd in, no damage type will be able to gib victims upon death.","name":"DMG_NEVERGIB"},{"documentation":"Energy beam. Laser or other high energy beam.","name":"DMG_ENERGYBEAM"},{"documentation":"Sonic. Sound pulse shockwave.","name":"DMG_SONIC"},{"documentation":"Shock. Electric shock.","name":"DMG_SHOCK"},{"documentation":"Club. Crowbar, punch, headbutt.","name":"DMG_CLUB"},{"documentation":"Blast. Explosive blast damage.","name":"DMG_BLAST"},{"documentation":"Fall. Fell too far.","name":"DMG_FALL"},{"documentation":"Freeze. Frozen.","name":"DMG_FREEZE"},{"documentation":"Burn. Heat burned.","name":"DMG_BURN"},{"documentation":"Slash. Cut, clawed, stabbed.","name":"DMG_SLASH"},{"documentation":"Bullet. Shot.","name":"DMG_BULLET"},{"documentation":"Crush damage. By falling or moving object.","name":"DMG_CRUSH"},{"documentation":"Generic damage.","name":"DMG_GENERIC"}]},{"documentation":"Relationship between (monster) entities","name":"RELATIONSHIP","namespace":"","values":[{"documentation":"Fear. Will attack.","name":"R_FR"},{"documentation":"Nemesis. A monster will ALWAYS attack its nemesis, no matter what.","name":"R_NM"},{"documentation":"Hate. Will attack this character instead of any DISLIKE'd characters.","name":"R_HT"},{"documentation":"Dislike. Will attack.","name":"R_DL"},{"documentation":"No relationship. Disregard.","name":"R_NO"},{"documentation":"Ally. Good alternative to R_NO when applicable.","name":"R_AL"}]},{"documentation":"Entity classification<br/>Can be set on entities with KeyValue using key 'classify'.","name":"CLASS","namespace":"","values":[{"documentation":"Is Barnacle","name":"CLASS_BARNACLE"},{"documentation":"Is X-Race shock trooper (also Voltigores)","name":"CLASS_XRACE_SHOCK"},{"documentation":"Is X-Race pitdrone","name":"CLASS_XRACE_PITDRONE"},{"documentation":"Is alien bioweapon","name":"CLASS_ALIEN_BIOWEAPON"},{"documentation":"Is player bioweapon","name":"CLASS_PLAYER_BIOWEAPON"},{"documentation":"is player ally","name":"CLASS_PLAYER_ALLY"},{"documentation":"Is insect","name":"CLASS_INSECT"},{"documentation":"Is predator alien","name":"CLASS_ALIEN_PREDATOR"},{"documentation":"Is prey alien","name":"CLASS_ALIEN_PREY"},{"documentation":"Is monster alien","name":"CLASS_ALIEN_MONSTER"},{"documentation":"Is passive alien","name":"CLASS_ALIEN_PASSIVE"},{"documentation":"Is military alien","name":"CLASS_ALIEN_MILITARY"},{"documentation":"Is military human","name":"CLASS_HUMAN_MILITARY"},{"documentation":"Is passive human","name":"CLASS_HUMAN_PASSIVE"},{"documentation":"Is player","name":"CLASS_PLAYER"},{"documentation":"Is machine","name":"CLASS_MACHINE"},{"documentation":"No classification","name":"CLASS_NONE"},{"documentation":"Forces class override to none","name":"CLASS_FORCE_NONE"}]},{"documentation":"CBaseEntity caps (CBaseEntity::ObjectCaps())","name":"FCAP","namespace":"","values":[{"documentation":"Force transition","name":"FCAP_FORCE_TRANSITION"},{"documentation":"Is a master","name":"FCAP_MASTER"},{"documentation":"Directional use","name":"FCAP_DIRECTIONAL_USE"},{"documentation":"On/off use","name":"FCAP_ONOFF_USE"},{"documentation":"Continuous use","name":"FCAP_CONTINUOUS_USE"},{"documentation":"Impulse use","name":"FCAP_IMPULSE_USE"},{"documentation":"Don't save","name":"FCAP_DONT_SAVE"},{"documentation":"Must spawn","name":"FCAP_MUST_SPAWN"},{"documentation":"Across transition","name":"FCAP_ACROSS_TRANSITION"},{"documentation":"Custom save method","name":"FCAP_CUSTOMSAVE"}]},{"documentation":"Entity variable type","name":"Entvartype","namespace":"","values":[{"documentation":"Custom type","name":"VAR_CUSTOM"},{"documentation":"2 byte array type","name":"VAR_BYTE2"},{"documentation":"4 byte array type","name":"VAR_BYTE4"},{"documentation":"Edict type","name":"VAR_EDICT"},{"documentation":"Integer type","name":"VAR_INTEGER"},{"documentation":"Float type","name":"VAR_FLOAT"},{"documentation":"Vector type","name":"VAR_VECTOR"},{"documentation":"String type","name":"VAR_STRING"},{"documentation":"Invalid type","name":"VAR_INVALID"}]},{"documentation":"Use type for entities. Not all entities support all use types.<br/>Passed to the Use method on entities.","name":"USE_TYPE","namespace":"","values":[{"documentation":"Kills an entity","name":"USE_KILL"},{"documentation":"Toggles the state of an entity","name":"USE_TOGGLE"},{"documentation":"Sets the state of an entity (use float parameter in Use)","name":"USE_SET"},{"documentation":"Turns on an entity","name":"USE_ON"},{"documentation":"Turns off an entity","name":"USE_OFF"}]},{"documentation":"entvars_t::fixangle modes","name":"FixAngleMode","namespace":"","values":[{"documentation":"Add avelocity to player view angles","name":"FAM_ADDAVELOCITY"},{"documentation":"Force player view angles to entvars_t::angles","name":"FAM_FORCEVIEWANGLES"},{"documentation":"Do nothing","name":"FAM_NOTHING"}]},{"documentation":"entvars_t waterlevel values","name":"WATERLEVEL","namespace":"","values":[{"documentation":"Head underwater (completely submerged)","name":"WATERLEVEL_HEAD"},{"documentation":"Waist underwater","name":"WATERLEVEL_WAIST"},{"documentation":"Feet underwater","name":"WATERLEVEL_FEET"},{"documentation":"Not in water","name":"WATERLEVEL_DRY"}]},{"documentation":"entvars_t::effects constants","name":"EFFECTS","namespace":"","values":[{"documentation":"is hudentity, handled differently while applying lighting and such","name":"EF_HUDENTITY"},{"documentation":"Use the value in pev->frame to set the texture on a brush entity","name":"EF_FRAMEANIMTEXTURES"},{"documentation":"Don't animate brush entities","name":"EF_NOANIMTEXTURES"},{"documentation":"don't draw entity","name":"EF_NODRAW"},{"documentation":"rocket flare glow sprite","name":"EF_LIGHT"},{"documentation":"don't interpolate the next frame","name":"EF_NOINTERP"},{"documentation":"get lighting from ceiling","name":"EF_INVLIGHT"},{"documentation":"player flashlight","name":"EF_DIMLIGHT"},{"documentation":"DLIGHT centered at entity origin","name":"EF_BRIGHTLIGHT"},{"documentation":"single frame ELIGHT on entity attachment 0","name":"EF_MUZZLEFLASH"},{"documentation":"swirling cloud of particles","name":"EF_BRIGHTFIELD"}]},{"documentation":"entvars_t::takedamage values","name":"DAMAGE","namespace":"","values":[{"documentation":"allow auto-aim","name":"DAMAGE_AIM"},{"documentation":"Allow damage","name":"DAMAGE_YES"},{"documentation":"Don't allow damage","name":"DAMAGE_NO"}]},{"documentation":"Entity entvars_t::deadflag values","name":"DEAD","namespace":"","values":[{"documentation":"No direct use of this","name":"DEAD_DISCARDBODY"},{"documentation":"The player is in a state where they can be respawned.","name":"DEAD_RESPAWNABLE"},{"documentation":"dead. lying still.","name":"DEAD_DEAD"},{"documentation":"playing death animation or still falling off of a ledge waiting to hit ground","name":"DEAD_DYING"},{"documentation":"alive","name":"DEAD_NO"}]},{"documentation":"entvars_t::solid constants.</br>NOTE: Some movetypes will cause collisions independent of SOLID_NOT/SOLID_TRIGGER when the entity moves<br/>SOLID only effects OTHER entities colliding with this one when they move - UGH!","name":"SOLID","namespace":"","values":[{"documentation":"bsp clip, touch on edge, block","name":"SOLID_BSP"},{"documentation":"touch on edge, but not an onground","name":"SOLID_SLIDEBOX"},{"documentation":"touch on edge, block","name":"SOLID_BBOX"},{"documentation":"touch on edge, but not blocking","name":"SOLID_TRIGGER"},{"documentation":"no interaction with other objects","name":"SOLID_NOT"}]},{"documentation":"entvars_t::movetype constants","name":"MOVETYPE","namespace":"","values":[{"documentation":"BSP model that needs physics/world collisions (uses nearest hull for world collision)","name":"MOVETYPE_PUSHSTEP"},{"documentation":"track movement of aiment","name":"MOVETYPE_FOLLOW"},{"documentation":"bounce w/o gravity","name":"MOVETYPE_BOUNCEMISSILE"},{"documentation":"Just like Toss, but reflect velocity when contacting surfaces","name":"MOVETYPE_BOUNCE"},{"documentation":"extra size to monsters","name":"MOVETYPE_FLYMISSILE"},{"documentation":"No gravity, no collisions, still do velocity/avelocity","name":"MOVETYPE_NOCLIP"},{"documentation":"no clip to world, push and crush","name":"MOVETYPE_PUSH"},{"documentation":"gravity/collisions","name":"MOVETYPE_TOSS"},{"documentation":"No gravity, but still collides with stuff","name":"MOVETYPE_FLY"},{"documentation":"gravity, special edge handling -- monsters use this","name":"MOVETYPE_STEP"},{"documentation":"Player only - moving on the ground","name":"MOVETYPE_WALK"},{"documentation":"never moves","name":"MOVETYPE_NONE"}]},{"documentation":"entvars_t::flags constants","name":"EdictFlags","namespace":"","values":[{"documentation":"Entity is dormant, no updates to client","name":"FL_DORMANT"},{"documentation":"This entity is marked for death -- This allows the engine to kill ents at the appropriate time","name":"FL_KILLME"},{"documentation":"This is a custom entity","name":"FL_CUSTOMENTITY"},{"documentation":"This client is being denied weapon usage","name":"FL_NOWEAPONS"},{"documentation":"This client is a spectator, don't run touch functions, etc.","name":"FL_SPECTATOR"},{"documentation":"Not moveable/removeable brush entity (really part of the world, but represented as an entity for transparency or something)","name":"FL_WORLDBRUSH"},{"documentation":"Player is _controlling_ a train, so movement commands should be ignored on client during prediction.","name":"FL_ONTRAIN"},{"documentation":"Only collide in with monsters who have FL_MONSTERCLIP set","name":"FL_MONSTERCLIP"},{"documentation":"Base velocity has been applied this frame (used to convert base velocity into momentum)","name":"FL_BASEVELOCITY"},{"documentation":"Brush model flag -- call think every frame regardless of nextthink - ltime (for constantly changing velocity/path)","name":"FL_ALWAYSTHINK"},{"documentation":"This is a spectator proxy","name":"FL_PROXY"},{"documentation":"If set, players don't take damage from lava","name":"FL_IMMUNE_LAVA"},{"documentation":"If set, players don't take damage from slime","name":"FL_IMMUNE_SLIME"},{"documentation":"If set, players don't take drown damage","name":"FL_IMMUNE_WATER"},{"documentation":"worldgraph has this ent listed as something that blocks a connection","name":"FL_GRAPHED"},{"documentation":"Apply floating force to this entity when in water","name":"FL_FLOAT"},{"documentation":"Player flag -- Player is fully crouched","name":"FL_DUCKING"},{"documentation":"JAC: fake client, simulated server side; don't send network messages to them","name":"FL_FAKECLIENT"},{"documentation":"Player is frozen for 3rd person camera","name":"FL_FROZEN"},{"documentation":"player jumping out of water","name":"FL_WATERJUMP"},{"documentation":"not all corners are valid","name":"FL_PARTIALGROUND"},{"documentation":"At rest / on the ground","name":"FL_ONGROUND"},{"documentation":"Don't send entity to local host, it's predicting this entity itself","name":"FL_SKIPLOCALHOST"},{"documentation":"If set, this entity will not be targeted by monster AI","name":"FL_NOTARGET"},{"documentation":"If set, this entity is invincible. Only applies to players","name":"FL_GODMODE"},{"documentation":"If set, this is a monster","name":"FL_MONSTER"},{"documentation":"If set, this entity is in water. Only applies to players","name":"FL_INWATER"},{"documentation":"If set, this is a player","name":"FL_CLIENT"},{"documentation":"If set, entities standing on this entity are moved as if this were a conveyor","name":"FL_CONVEYOR"},{"documentation":"Changes the SV_Movestep() behavior to not need to be on ground (but stay in water)","name":"FL_SWIM"},{"documentation":"Changes the SV_Movestep() behavior to not need to be on ground","name":"FL_FLY"}]},{"documentation":"Flags passed to FileSystem::OpenFile","name":"OpenFile","namespace":"OpenFile","values":[{"documentation":"Open in binary mode","name":"BINARY"},{"documentation":"Open file for appending","name":"APPEND"},{"documentation":"Open file for writing","name":"WRITE"},{"documentation":"Open file for reading","name":"READ"}]},{"documentation":"Match format flags. These can be bitwise OR'd together to combine options.","name":"MatchFlagType","namespace":"Regex","values":[{"documentation":"","name":"format_first_only"},{"documentation":"","name":"format_no_copy"},{"documentation":"","name":"format_sed"},{"documentation":"","name":"format_default"},{"documentation":"","name":"match_prev_avail"},{"documentation":"","name":"match_continuous"},{"documentation":"","name":"match_not_null"},{"documentation":"","name":"match_any"},{"documentation":"","name":"match_not_eow"},{"documentation":"","name":"match_not_bow"},{"documentation":"","name":"match_not_eol"},{"documentation":"","name":"match_not_bol"},{"documentation":"","name":"match_default"}]},{"documentation":"Regular expression flags. These can be bitwise OR'd together to combine options.","name":"FlagType","namespace":"Regex","values":[{"documentation":"","name":"egrep"},{"documentation":"","name":"grep"},{"documentation":"","name":"awk"},{"documentation":"","name":"extended"},{"documentation":"","name":"basic"},{"documentation":"","name":"ECMAScript"},{"documentation":"","name":"collate"},{"documentation":"","name":"optimize"},{"documentation":"","name":"nosubs"},{"documentation":"","name":"icase"}]},{"documentation":"Which type a reflection argument is","name":"ArgumentType","namespace":"Reflection","values":[{"documentation":"Argument is an enum type.","name":"AT_ENUM"},{"documentation":"Argument is an object type.","name":"AT_OBJECT"},{"documentation":"Argument is a primitive type.","name":"AT_PRIMITIVE"},{"documentation":"Argument is void.","name":"AT_VOID"},{"documentation":"Argument has no type. If an argument has this type it means something went wrong during parsing.","name":"AT_NONE"}]},{"documentation":"Compare type.","name":"CompareType","namespace":"String","values":[{"documentation":"","name":"CaseInsensitive"},{"documentation":"","name":"CaseSensitive"}]}],"funcDefs":[{"documentation":"FuncDef for hook","name":"HookReturnCode ClientDisconnectHook(CBasePlayer@)","namespace":""},{"documentation":"FuncDef for hook","name":"HookReturnCode ClientPutInServerHook(CBasePlayer@)","namespace":""},{"documentation":"FuncDef for hook","name":"HookReturnCode ClientSayHook(SayParameters@)","namespace":""},{"documentation":"FuncDef for hook","name":"HookReturnCode CanPlayerUseReservedSlotHook(edict_t@, const string& in, const string& in, bool& out)","namespace":""},{"documentation":"FuncDef for hook","name":"HookReturnCode ClientConnectedHook(edict_t@, const string& in, const string& in, bool& out, string& out)","namespace":""},{"documentation":"FuncDef for hook","name":"HookReturnCode PlayerSpawnHook(CBasePlayer@)","namespace":""},{"documentation":"FuncDef for hook","name":"HookReturnCode PlayerCanRespawnHook(CBasePlayer@, bool& out)","namespace":""},{"documentation":"FuncDef for hook","name":"HookReturnCode PlayerKilledHook(CBasePlayer@, CBaseEntity@, int)","namespace":""},{"documentation":"FuncDef for hook","name":"HookReturnCode PlayerUseHook(CBasePlayer@, uint& out)","namespace":""},{"documentation":"FuncDef for hook","name":"HookReturnCode PlayerPreThinkHook(CBasePlayer@, uint& out)","namespace":""},{"documentation":"FuncDef for hook","name":"HookReturnCode PlayerPostThinkHook(CBasePlayer@)","namespace":""},{"documentation":"FuncDef for hook","name":"HookReturnCode GetPlayerSpawnSpotHook(CBasePlayer@ pPlayer, CBaseEntity@& out ppEntSpawnSpot)","namespace":""},{"documentation":"FuncDef for hook","name":"HookReturnCode PlayerDecalHook(CBasePlayer@, const TraceResult& in trace)","namespace":""},{"documentation":"FuncDef for hook","name":"HookReturnCode WeaponPrimaryAttackHook(CBasePlayer@, CBasePlayerWeapon@)","namespace":""},{"documentation":"FuncDef for hook","name":"HookReturnCode WeaponSecondaryAttackHook(CBasePlayer@, CBasePlayerWeapon@)","namespace":""},{"documentation":"FuncDef for hook","name":"HookReturnCode WeaponTertiaryAttackHook(CBasePlayer@, CBasePlayerWeapon@)","namespace":""},{"documentation":"FuncDef for hook","name":"HookReturnCode MapChangeHook()","namespace":""},{"documentation":"Callback for cvars.","name":"void CVarCallback(CCVar@ cvar, const string& in szOldValue, float flOldValue)","namespace":""},{"documentation":"Callback for client console commands.","name":"void ClientCommandCallback(const CCommand@ args)","namespace":""},{"documentation":"Callback for server console commands.","name":"void ConCommandCallback(const CCommand@ args)","namespace":""},{"documentation":"Funcdef for vote ended callbacks. If fResult is true, users voted for yes. Otherwise, voted for no.","name":"void VoteEnd(Vote@ pVote, bool fResult, int iVoters)","namespace":""},{"documentation":"Funcdef for vote blocked callbacks. The given time is when the active vote has ended.","name":"void VoteBlocked(Vote@ pVote, float flTime)","namespace":""},{"documentation":"Player slot callback for text menus.","name":"void TextMenuPlayerSlotCallback(CTextMenu@ menu, CBasePlayer@ pPlayer, int iSlot, const CTextMenuItem@ pItem)","namespace":""},{"documentation":"Function definition for custom entity Blocked functions","name":"void BlockedFunction(CBaseEntity@ pOther)","namespace":""},{"documentation":"Function definition for custom entity Touch functions","name":"void TouchFunction(CBaseEntity@ pOther)","namespace":""},{"documentation":"Function definition for custom entity Use functions","name":"void UseFunction(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue)","namespace":""},{"documentation":"Function definition for custom entity Think functions","name":"void ThinkFunction()","namespace":""}],"functions":[{"declaration":"CModule@ get_g_Module()","documentation":"Gets the current script's module.","namespace":""},{"declaration":"CModuleHookManager@ get_g_Hooks()","documentation":"Gets the current script's hook manager.","namespace":""},{"declaration":"time_t UnixTimestamp()","documentation":"Gets the current time as a unix timestamp.","namespace":""},{"declaration":"CPersistence@ get_g_Persistence()","documentation":"Gets the map script's persistence manager.","namespace":""},{"declaration":"CPathTrack@ PathTrackEntity_Instance(edict_t@ pEdict)","documentation":"","namespace":""},{"declaration":"CSoundEnt@ GetSoundEntInstance()","documentation":"Gets the current global sound manager entity","namespace":""},{"declaration":"bool FNullEnt(CBaseEntity@ pEnt)","documentation":"Checks Entity for nullity","namespace":""},{"declaration":"bool FNullEnt(entvars_t@ pev)","documentation":"Checks entvars for nullity","namespace":""},{"declaration":"bool FNullEnt(const edict_t@ pEnt)","documentation":"Checks edict for nullity","namespace":""},{"declaration":"int TrainSpeed(int iSpeed, int iMax)","documentation":"","namespace":""},{"declaration":"Vector CrossProduct(const Vector& in, const Vector& in)","documentation":"Returns the cross product of the given vectors","namespace":""},{"declaration":"float DotProduct(const Vector& in lhs, const Vector& in rhs)","documentation":"Returns the dot product of the given vectors","namespace":""},{"declaration":"float DotProduct(const Vector2D& in lhs, const Vector2D& in rhs)","documentation":"Returns a dot product of the given vectors","namespace":""},{"declaration":"CScheduler@ get_g_Scheduler()","documentation":"Gets the current script's scheduler.","namespace":""},{"declaration":"bool FormatOpenFlags(OpenFileFlags_t uiOpenFlags, string& out szOutFlags)","documentation":"Formats the open flags into a string that represents the flags.","namespace":"FileSystem"},{"declaration":"OpenFileFlags_t FilterFlags(OpenFileFlags_t uiOpenFlags)","documentation":"Filters the given flags, removing unnecessary flags.","namespace":"FileSystem"},{"declaration":"bool FlagsValid(const OpenFileFlags_t uiOpenFlags)","documentation":"Returns whether the given open flags are valid.","namespace":"FileSystem"},{"declaration":"string Replace(const string& in szString, const Regex@ pRegex, const string& in szFormat, MatchFlagType flags = match_default)","documentation":"Makes a copy of the target sequence (the subject) with all matches of the regular expression pRegex (the pattern) replaced by szFormat (the replacement).","namespace":"Regex"},{"declaration":"bool Search(const string& in szString, MatchResults@ pResults, const Regex@ pRegex, MatchFlagType flags = match_default)","documentation":"Returns whether some sub-sequence in the target sequence (the subject) matches the regular expression pRegex.<br/>pResults will contain the results of the operation, if any.","namespace":"Regex"},{"declaration":"bool Search(const string& in szString, const Regex@ pRegex, MatchFlagType flags = match_default)","documentation":"Returns whether some sub-sequence in the target sequence (the subject) matches the regular expression pRegex.","namespace":"Regex"},{"declaration":"bool Match(const string& in szString, MatchResults@ pResults, const Regex@ pRegex, MatchFlagType flags = match_default)","documentation":"Performs are regular expression matching operation.<br/>Returns true if the match succeeded, false otherwise.<br/>pResults will contain the results of the operation, if any.","namespace":"Regex"},{"declaration":"bool Match(const string& in szString, const Regex@ pRegex, MatchFlagType flags = match_default)","documentation":"Performs are regular expression matching operation.<br/>Returns true if the match succeeded, false otherwise","namespace":"Regex"},{"declaration":"bool snprintf(string& out szOutBuffer, const string& in szFormat, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in)","documentation":"Prints the format string to the destination buffer. Uses SC printf formatting style.","namespace":""},{"declaration":"bool snprintf(string& out szOutBuffer, const string& in szFormat, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in)","documentation":"Prints the format string to the destination buffer. Uses SC printf formatting style.","namespace":""},{"declaration":"bool snprintf(string& out szOutBuffer, const string& in szFormat, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in)","documentation":"Prints the format string to the destination buffer. Uses SC printf formatting style.","namespace":""},{"declaration":"bool snprintf(string& out szOutBuffer, const string& in szFormat, ?& in, ?& in, ?& in, ?& in, ?& in)","documentation":"Prints the format string to the destination buffer. Uses SC printf formatting style.","namespace":""},{"declaration":"bool snprintf(string& out szOutBuffer, const string& in szFormat, ?& in, ?& in, ?& in, ?& in)","documentation":"Prints the format string to the destination buffer. Uses SC printf formatting style.","namespace":""},{"declaration":"bool snprintf(string& out szOutBuffer, const string& in szFormat, ?& in, ?& in, ?& in)","documentation":"Prints the format string to the destination buffer. Uses SC printf formatting style.","namespace":""},{"declaration":"bool snprintf(string& out szOutBuffer, const string& in szFormat, ?& in, ?& in)","documentation":"Prints the format string to the destination buffer. Uses SC printf formatting style.","namespace":""},{"declaration":"bool snprintf(string& out szOutBuffer, const string& in szFormat, ?& in)","documentation":"Prints the format string to the destination buffer. Uses SC printf formatting style.","namespace":""},{"declaration":"bool snprintf(string& out szOutBuffer, const string& in szFormat)","documentation":"Prints the format string to the destination buffer. Uses SC printf formatting style.","namespace":""},{"declaration":"string toupper(const string& in )","documentation":"Converts the given character to upper case","namespace":""},{"declaration":"string tolower(const string& in )","documentation":"Converts the given character to lower case","namespace":""},{"declaration":"bool isxdigit(const string& in)","documentation":"Returns whether character is xdigit","namespace":""},{"declaration":"bool isupper(const string& in)","documentation":"Returns whether character is upper","namespace":""},{"declaration":"bool isspace(const string& in)","documentation":"Returns whether character is space","namespace":""},{"declaration":"bool ispunct(const string& in)","documentation":"Returns whether character is punctuality","namespace":""},{"declaration":"bool isprint(const string& in)","documentation":"Returns whether character is print","namespace":""},{"declaration":"bool islower(const string& in)","documentation":"Returns whether character is lower","namespace":""},{"declaration":"bool isgraph(const string& in)","documentation":"Returns whether character is graph","namespace":""},{"declaration":"bool isdigit(const string& in)","documentation":"Returns whether character is digit","namespace":""},{"declaration":"bool iscntrl(const string& in)","documentation":"Returns whether character is control","namespace":""},{"declaration":"bool isalpha(const string& in)","documentation":"Returns whether character is alphabetic","namespace":""},{"declaration":"bool isalnum(const string& in)","documentation":"Returns whether character is alphanumeric","namespace":""},{"declaration":"bool atobool(const string& in, bool& out fIsValid)","documentation":"Converts the given string to a boolean. fIsValid is true if the given string was a valid boolean value.","namespace":""},{"declaration":"bool atobool(const string& in)","documentation":"Converts the given string to a boolean","namespace":""},{"declaration":"uint64 atoui64(const string& in, int radix = 10)","documentation":"Converts the given string to a 64 bit unsigned integer","namespace":""},{"declaration":"uint atoui(const string& in, int radix = 10)","documentation":"Converts the given string to an unsigned integer","namespace":""},{"declaration":"int64 atoi64(const string& in, int radix = 10)","documentation":"Converts the given string to a 64 bit integer","namespace":""},{"declaration":"int atoi(const string& in, int radix = 10)","documentation":"Converts the given string to an integer","namespace":""},{"declaration":"double atod(const string& in)","documentation":"Converts the given string to a double","namespace":""},{"declaration":"float atof(const string& in)","documentation":"Converts the given string to a float","namespace":""},{"declaration":"char toupper(char character)","documentation":"Converts the given character to upper case","namespace":""},{"declaration":"char tolower(char character)","documentation":"Converts the given character to lower case","namespace":""},{"declaration":"bool isxdigit(char character)","documentation":"Returns whether character is xdigit","namespace":""},{"declaration":"bool isupper(char character)","documentation":"Returns whether character is upper","namespace":""},{"declaration":"bool isspace(char character)","documentation":"Returns whether character is space","namespace":""},{"declaration":"bool ispunct(char character)","documentation":"Returns whether character is punctuality","namespace":""},{"declaration":"bool isprint(char character)","documentation":"Returns whether character is print","namespace":""},{"declaration":"bool islower(char character)","documentation":"Returns whether character is lower","namespace":""},{"declaration":"bool isgraph(char character)","documentation":"Returns whether character is graph","namespace":""},{"declaration":"bool isdigit(char character)","documentation":"Returns whether character is digit","namespace":""},{"declaration":"bool iscntrl(char character)","documentation":"Returns whether character is control","namespace":""},{"declaration":"bool isalpha(char character)","documentation":"Returns whether character is alphabetic","namespace":""},{"declaration":"bool isalnum(char character)","documentation":"Returns whether character is alphanumeric","namespace":""}],"interfaces":[{"methods":[{"declaration":"void PlayerDetected(const bool fInVolume, CBasePlayer@ pPlayer)","documentation":"Called whenever a player is detected."}],"documentation":"Listener for CountPlayersInBrushVolume.","interfaceName":"PlayerInVolumeListener","namespace":""},{"methods":[],"documentation":"Script class interface","interfaceName":"ScriptClassInterface","namespace":""}],"properties":[{"namespace":"Hooks::Player","declaration":"const uint32 ClientDisconnect","documentation":"ClientDisconnect function"},{"namespace":"Hooks::Player","declaration":"const uint32 ClientPutInServer","documentation":"ClientPutInServer function"},{"namespace":"Hooks::Player","declaration":"const uint32 ClientSay","documentation":"ClientSay function"},{"namespace":"Hooks::Player","declaration":"const uint32 CanPlayerUseReservedSlot","documentation":"CanPlayerUseReservedSlot function"},{"namespace":"Hooks::Player","declaration":"const uint32 ClientConnected","documentation":"ClientConnected function"},{"namespace":"Hooks::Player","declaration":"const uint32 PlayerSpawn","documentation":"PlayerSpawn function"},{"namespace":"Hooks::Player","declaration":"const uint32 PlayerCanRespawn","documentation":"PlayerCanRespawn function"},{"namespace":"Hooks::Player","declaration":"const uint32 PlayerKilled","documentation":"PlayerKilled function"},{"namespace":"Hooks::Player","declaration":"const uint32 PlayerUse","documentation":"Player use hook function"},{"namespace":"Hooks::Player","declaration":"const uint32 PlayerPreThink","documentation":"Player PreThink hook function"},{"namespace":"Hooks::Player","declaration":"const uint32 PlayerPostThink","documentation":"Player PostThink hook function"},{"namespace":"Hooks::Player","declaration":"const uint32 GetPlayerSpawnSpot","documentation":"Is called when a player spawns to get a spawn point for the player"},{"namespace":"Hooks::Player","declaration":"const uint32 PlayerDecal","documentation":"Player sprayed a decal"},{"namespace":"Hooks::Weapon","declaration":"const uint32 WeaponPrimaryAttack","documentation":"Weapon Primary attack function"},{"namespace":"Hooks::Weapon","declaration":"const uint32 WeaponSecondaryAttack","documentation":"Weapon Secondary attack function"},{"namespace":"Hooks::Weapon","declaration":"const uint32 WeaponTertiaryAttack","documentation":"Weapon Tertiary attack function"},{"namespace":"Hooks::Game","declaration":"const uint32 MapChange","documentation":"Map change function. Called on all modules regardless of the HookReturnCode returned by a call."},{"namespace":"","declaration":"CClassicMode g_ClassicMode","documentation":"Classic Mode global instance."},{"namespace":"","declaration":"CConCommandSystem g_ConCommandSystem","documentation":"CConCommandSystem global instance"},{"namespace":"","declaration":"CLog g_Log","documentation":"Log global instance"},{"namespace":"","declaration":"CAdminControl g_AdminControl","documentation":"CAdminControl instance for plugins"},{"namespace":"","declaration":"CTextMenus g_TextMenus","documentation":"Text menu manager global instance"},{"namespace":"","declaration":"CStartInventory g_StartInventory","documentation":"Player start inventory manager instance"},{"namespace":"","declaration":"CPluginManager g_PluginManager","documentation":"Plugin manager global instance."},{"namespace":"","declaration":"const CMap g_Map","documentation":"Map state variables instance"},{"namespace":"","declaration":"CMapCycle g_MapCycle","documentation":"Map cycle manager instance"},{"namespace":"","declaration":"CAngelscript g_Angelscript","documentation":"Angelscript debugging functions instance"},{"namespace":"","declaration":"CGlobalState g_GlobalState","documentation":"Global state manager instance"},{"namespace":"","declaration":"CWeaponFuncs g_WeaponFuncs","documentation":"Weapon functions global instance."},{"namespace":"","declaration":"CPlayerFuncs g_PlayerFuncs","documentation":"Global player functions instance"},{"namespace":"","declaration":"CEntityFuncs g_EntityFuncs","documentation":"Global entity functions instance"},{"namespace":"","declaration":"const uint FTRACE_SIMPLEBOX","documentation":"Goes into g_Engine.trace_flags<br/>Traceline with a simple box"},{"namespace":"","declaration":"const CEngine g_Engine","documentation":"Engine global variables instance"},{"namespace":"","declaration":"CSoundEngine g_SoundSystem","documentation":"Sound engine instance"},{"namespace":"","declaration":"const float VOL_NORM","documentation":"Volume value normal"},{"namespace":"","declaration":"const float ATTN_STATIC","documentation":""},{"namespace":"","declaration":"const float ATTN_IDLE","documentation":""},{"namespace":"","declaration":"const float ATTN_NORM","documentation":""},{"namespace":"","declaration":"const float ATTN_NONE","documentation":""},{"namespace":"","declaration":"CGame g_Game","documentation":"Game functions instance"},{"namespace":"","declaration":"CUtility g_Utility","documentation":"Utility methods instance"},{"namespace":"","declaration":"CCustomEntityFuncs g_CustomEntityFuncs","documentation":"Custom entity functions global instance."},{"namespace":"","declaration":"CEntityLoader g_EntityLoader","documentation":"Entity loader global instance"},{"namespace":"","declaration":"CItemRegistry g_ItemRegistry","documentation":"Item registry global instance."},{"namespace":"","declaration":"const int WEAPON_NOCLIP","documentation":"Used for clips that don't use ammo."},{"namespace":"","declaration":"const Vector VECTOR_CONE_20DEGREES","documentation":""},{"namespace":"","declaration":"const Vector VECTOR_CONE_15DEGREES","documentation":""},{"namespace":"","declaration":"const Vector VECTOR_CONE_10DEGREES","documentation":""},{"namespace":"","declaration":"const Vector VECTOR_CONE_9DEGREES","documentation":""},{"namespace":"","declaration":"const Vector VECTOR_CONE_8DEGREES","documentation":""},{"namespace":"","declaration":"const Vector VECTOR_CONE_7DEGREES","documentation":""},{"namespace":"","declaration":"const Vector VECTOR_CONE_6DEGREES","documentation":""},{"namespace":"","declaration":"const Vector VECTOR_CONE_5DEGREES","documentation":""},{"namespace":"","declaration":"const Vector VECTOR_CONE_4DEGREES","documentation":""},{"namespace":"","declaration":"const Vector VECTOR_CONE_3DEGREES","documentation":""},{"namespace":"","declaration":"const Vector VECTOR_CONE_2DEGREES","documentation":""},{"namespace":"","declaration":"const Vector VECTOR_CONE_1DEGREES","documentation":""},{"namespace":"","declaration":"const int WEAPON_ACTIVITY_VOLUME","documentation":"Parameter for CSoundEnt::InsertSound iVolume"},{"namespace":"","declaration":"const int SMALL_EXPLOSION_VOLUME","documentation":"Parameter for CSoundEnt::InsertSound iVolume"},{"namespace":"","declaration":"const int NORMAL_EXPLOSION_VOLUME","documentation":"Parameter for CSoundEnt::InsertSound iVolume"},{"namespace":"","declaration":"const int BIG_EXPLOSION_VOLUME","documentation":"Parameter for CSoundEnt::InsertSound iVolume"},{"namespace":"","declaration":"const int DIM_GUN_FLASH","documentation":"Value used in CBasePlayer::m_iWeaponFlash"},{"namespace":"","declaration":"const int NORMAL_GUN_FLASH","documentation":"Value used in CBasePlayer::m_iWeaponFlash"},{"namespace":"","declaration":"const int BRIGHT_GUN_FLASH","documentation":"Value used in CBasePlayer::m_iWeaponFlash"},{"namespace":"","declaration":"const int QUIET_GUN_VOLUME","documentation":"Parameter for CSoundEnt::InsertSound iVolume"},{"namespace":"","declaration":"const int NORMAL_GUN_VOLUME","documentation":"Parameter for CSoundEnt::InsertSound iVolume"},{"namespace":"","declaration":"const int LOUD_GUN_VOLUME","documentation":"Parameter for CSoundEnt::InsertSound iVolume"},{"namespace":"","declaration":"CInventoryMisc g_InventoryMisc","documentation":"Inventory misc functions instance"},{"namespace":"","declaration":"const int SOUND_NEVER_EXPIRE","documentation":"With this set as a sound's ExpireTime, the sound will never expire.<br/>See CSoundEnt."},{"namespace":"","declaration":"const int SOUNDLISTTYPE_ACTIVE","documentation":"Identifiers passed to functions that can operate on either list, to indicate which list to operate on.<br/>See CSoundEnt."},{"namespace":"","declaration":"const int SOUNDLISTTYPE_FREE","documentation":"Identifiers passed to functions that can operate on either list, to indicate which list to operate on.<br/>See CSoundEnt."},{"namespace":"","declaration":"const int SOUNDLIST_EMPTY","documentation":"Indicates that the sound list is empty.<br/>See CSoundEnt."},{"namespace":"","declaration":"const size_t MAX_WORLD_SOUNDS","documentation":"maximum number of sounds handled by the world at one time.<br/>See CSoundEnt."},{"namespace":"","declaration":"CEngineFuncs g_EngineFuncs","documentation":"Engine functions instance"},{"namespace":"","declaration":"const float PLAYERCOMMAND_WAIT","documentation":"Time between player vocal client commands"},{"namespace":"","declaration":"const float AUTOAIM_10DEGREES","documentation":"Autoaim"},{"namespace":"","declaration":"const float AUTOAIM_8DEGREES","documentation":"Autoaim"},{"namespace":"","declaration":"const float AUTOAIM_5DEGREES","documentation":"Autoaim"},{"namespace":"","declaration":"const float AUTOAIM_2DEGREES","documentation":"Autoaim"},{"namespace":"","declaration":"const size_t MAX_ITEM_TYPES","documentation":"HUD item selection slots"},{"namespace":"","declaration":"const size_t MAX_AMMO_SLOTS","documentation":"Not really slots"},{"namespace":"","declaration":"const Vector VEC_DUCK_VIEW","documentation":"Hull view offset while ducking."},{"namespace":"","declaration":"const Vector VEC_DUCK_HULL_MAX","documentation":"Hull maximum while ducking. Used with CEntityFuncs::SetSize"},{"namespace":"","declaration":"const Vector VEC_DUCK_HULL_MIN","documentation":"Hull minimum while ducking. Used with CEntityFuncs::SetSize"},{"namespace":"","declaration":"const Vector VEC_VIEW","documentation":"View offset."},{"namespace":"","declaration":"const Vector VEC_HUMAN_HULL_DUCK","documentation":"Default human hull maximum while ducking. Used with CEntityFuncs::SetSize"},{"namespace":"","declaration":"const Vector VEC_HUMAN_HULL_MAX","documentation":"Default human hull maximum while standing. Used with CEntityFuncs::SetSize"},{"namespace":"","declaration":"const Vector VEC_HUMAN_HULL_MIN","documentation":"Default human hull maximum. Used with CEntityFuncs::SetSize"},{"namespace":"","declaration":"const Vector VEC_HULL_MAX","documentation":"Default hull maximum. Used with CEntityFuncs::SetSize"},{"namespace":"","declaration":"const Vector VEC_HULL_MIN","documentation":"Default hull minimum. Used with CEntityFuncs::SetSize"},{"namespace":"","declaration":"const size_t ROUTE_SIZE","documentation":"How many waypoints a monster can store at one time"},{"namespace":"","declaration":"const size_t MAX_OLD_ENEMIES","documentation":"How many old enemies to remember"},{"namespace":"Schedules","declaration":"Schedule slFail","documentation":""},{"namespace":"Schedules","declaration":"Schedule slTakeCoverFromBestSound","documentation":""},{"namespace":"Schedules","declaration":"Schedule slWaitScript","documentation":""},{"namespace":"Schedules","declaration":"Schedule slRunToScript","documentation":""},{"namespace":"Schedules","declaration":"Schedule slWalkToScript","documentation":""},{"namespace":"Schedules","declaration":"Schedule slError","documentation":""},{"namespace":"Schedules","declaration":"Schedule slDie","documentation":""},{"namespace":"Schedules","declaration":"Schedule slSmallFlinch","documentation":""},{"namespace":"Schedules","declaration":"Schedule slChaseEnemy","documentation":""},{"namespace":"Schedules","declaration":"Schedule slRangeAttack2","documentation":""},{"namespace":"Schedules","declaration":"Schedule slRangeAttack1","documentation":""},{"namespace":"Schedules","declaration":"Schedule slReload","documentation":""},{"namespace":"Schedules","declaration":"Schedule slCombatFace","documentation":""},{"namespace":"Schedules","declaration":"Schedule slCombatStand","documentation":""},{"namespace":"Schedules","declaration":"Schedule slAlertStand","documentation":""},{"namespace":"Schedules","declaration":"Schedule slAlertFace","documentation":""},{"namespace":"Schedules","declaration":"Schedule slWakeAngry","documentation":""},{"namespace":"Schedules","declaration":"Schedule slIdleWalk","documentation":""},{"namespace":"Schedules","declaration":"Schedule slIdleTrigger","documentation":""},{"namespace":"Schedules","declaration":"Schedule slIdleStand","documentation":""},{"namespace":"","declaration":"CActivityMap g_ActivityMap","documentation":"Activity map instance"},{"namespace":"","declaration":"CDecals g_Decals","documentation":"Dynamic decal manager instance"},{"namespace":"","declaration":"const float VIEW_FIELD_ULTRA_NARROW","documentation":"Ultra narrow view field"},{"namespace":"","declaration":"const float VIEW_FIELD_NARROW","documentation":"Narrow view field"},{"namespace":"","declaration":"const float VIEW_FIELD_WIDE","documentation":"Wide view field"},{"namespace":"","declaration":"const float VIEW_FIELD_FULL","documentation":"Full view field"},{"namespace":"","declaration":"CMath Math","documentation":"Math functions instance"},{"namespace":"","declaration":"const Vector g_vecZero","documentation":"Zero vector (0, 0, 0)"},{"namespace":"","declaration":" CDebugger g_Debugger","documentation":"Debugger instance."},{"namespace":"","declaration":"CVirtualFileSystem g_FileSystem","documentation":"Global file system instance"},{"namespace":"Reflection","declaration":"CReflection g_Reflection","documentation":"Reflection global class instance."},{"namespace":"String","declaration":"const size_t INVALID_INDEX","documentation":"Sentinel value used by string methods"},{"namespace":"String","declaration":"const string WHITESPACE_CHARACTERS","documentation":"A string that contains one instance of every whitespace character."},{"namespace":"String","declaration":"const string EMPTY_STRING","documentation":"Empty string. Useful when a reference to a string is needed."},{"namespace":"String","declaration":"const CompareType DEFAULT_COMPARE","documentation":"Default comparison type."},{"namespace":"","declaration":"const float WORLD_BOUNDARY","documentation":"Distance from the world origin to the world boundary in a single axis"}],"typedefs":[{"documentation":"Type to store console command flags in","name":"ConCommandFlags_t","namespace":"","type":"uint32"},{"documentation":"Unix timestamp type.","name":"time_t","namespace":"","type":"uint64"},{"documentation":"Menu id.","name":"TextMenuId_t","namespace":"","type":"int32"},{"documentation":"Persistence object id type.","name":"PersistID_t","namespace":"","type":"uint"},{"documentation":"Open File Flags","name":"OpenFileFlags_t","namespace":"","type":"uint8"},{"documentation":"Size type used for denoting sizes","name":"size_t","namespace":"","type":"uint32"}]}